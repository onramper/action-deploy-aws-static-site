"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MetricSet=exports.allMetricsGraphJson=void 0;const drop_empty_object_at_the_end_of_an_array_token_1=require("./drop-empty-object-at-the-end-of-an-array-token"),env_tokens_1=require("./env-tokens"),metric_util_1=require("./metric-util"),object_1=require("./object");function allMetricsGraphJson(left,right){const mset=new MetricSet;return mset.addTopLevel("left",...left),mset.addTopLevel("right",...right),mset.entries.map(entry=>new drop_empty_object_at_the_end_of_an_array_token_1.DropEmptyObjectAtTheEndOfAnArray(metricGraphJson(entry.metric,entry.tag,entry.id)))}exports.allMetricsGraphJson=allMetricsGraphJson;function metricGraphJson(metric,yAxis,id){const config=metric.toMetricConfig(),ret=[],options={...config.renderingProperties};(0,metric_util_1.dispatchMetric)(metric,{withStat(stat){ret.push(stat.namespace,stat.metricName);for(const dim of stat.dimensions||[])ret.push(dim.name,dim.value);stat.account&&(options.accountId=(0,env_tokens_1.accountIfDifferentFromStack)(stat.account)),stat.region&&(options.region=(0,env_tokens_1.regionIfDifferentFromStack)(stat.region)),stat.period&&stat.period.toSeconds()!==300&&(options.period=stat.period.toSeconds()),stat.statistic&&stat.statistic!=="Average"&&(options.stat=stat.statistic)},withExpression(expr){options.expression=expr.expression,expr.searchAccount&&(options.accountId=(0,env_tokens_1.accountIfDifferentFromStack)(expr.searchAccount)),expr.searchRegion&&(options.region=(0,env_tokens_1.regionIfDifferentFromStack)(expr.searchRegion)),expr.period&&expr.period!==300&&(options.period=expr.period)}}),yAxis||(options.visible=!1),yAxis!=="left"&&(options.yAxis=yAxis),id&&(options.id=id),options.visible!==!1&&options.expression&&!options.label&&(options.label=options.label===""?void 0:metric.toString());const renderedOpts=(0,object_1.dropUndefined)(options);return Object.keys(renderedOpts).length!==0&&ret.push(renderedOpts),ret}class MetricSet{constructor(){this.metrics=new Array,this.metricById=new Map,this.metricByKey=new Map}addTopLevel(tag,...metrics){for(const metric of metrics)this.addOne(metric,tag)}get entries(){return this.metrics}addOne(metric,tag,id){const key=(0,metric_util_1.metricKey)(metric);let existingEntry;if(id&&(existingEntry=this.metricById.get(id),existingEntry&&(0,metric_util_1.metricKey)(existingEntry.metric)!==key))throw new Error(`Cannot have two different metrics share the same id ('${id}') in one Alarm or Graph. Rename one of them.`);existingEntry||(existingEntry=this.metricByKey.get(key),existingEntry?.id&&id&&(existingEntry=void 0));let entry;existingEntry?entry=existingEntry:(entry={metric},this.metrics.push(entry),this.metricByKey.set(key,entry)),!entry.id&&id&&(entry.id=id,this.metricById.set(id,entry)),!entry.tag&&tag&&(entry.tag=tag);const conf=metric.toMetricConfig();if(conf.mathExpression)for(const[subId,subMetric]of Object.entries(conf.mathExpression.usingMetrics))this.addOne(subMetric,void 0,subId)}}exports.MetricSet=MetricSet;

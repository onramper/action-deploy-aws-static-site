"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prepareApp=void 0;const constructs_1=require("constructs"),refs_1=require("./refs"),cfn_resource_1=require("../cfn-resource"),stack_1=require("../stack"),stage_1=require("../stage");function prepareApp(root){for(const dependency of findTransitiveDeps(root)){const targetCfnResources=findCfnResources(dependency.target),sourceCfnResources=findCfnResources(dependency.source);for(const target of targetCfnResources)for(const source of sourceCfnResources)source.addDependency(target)}(0,refs_1.resolveReferences)(root);const queue=findAllNestedStacks(root);if(queue.length>0){for(;queue.length>0;){const nested=queue.shift();defineNestedStackAsset(nested)}(0,refs_1.resolveReferences)(root)}}exports.prepareApp=prepareApp;function defineNestedStackAsset(nestedStack){nestedStack._prepareTemplateAsset()}function findAllNestedStacks(root){const result=new Array,includeStack=stack=>!stack_1.Stack.isStack(stack)||!stack.nested?!1:stage_1.Stage.of(stack)?stage_1.Stage.of(stack)===root:!0;for(const stack of root.node.findAll(constructs_1.ConstructOrder.POSTORDER))includeStack(stack)&&result.push(stack);return result}function findCfnResources(root){return root.node.findAll().filter(cfn_resource_1.CfnResource.isCfnResource)}function findTransitiveDeps(root){const found=new Map,ret=new Array;for(const source of root.node.findAll())for(const dependable of source.node.dependencies)for(const target of constructs_1.Dependable.of(dependable).dependencyRoots){let foundTargets=found.get(source);foundTargets||found.set(source,foundTargets=new Set),foundTargets.has(target)||(ret.push({source,target}),foundTargets.add(target))}return ret}

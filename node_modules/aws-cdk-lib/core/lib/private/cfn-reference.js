"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CfnReference=exports.ReferenceRendering=void 0;const reference_1=require("../reference"),CFN_REFERENCE_SYMBOL=Symbol.for("@aws-cdk/core.CfnReference");var ReferenceRendering;(function(ReferenceRendering2){ReferenceRendering2[ReferenceRendering2.FN_SUB=0]="FN_SUB",ReferenceRendering2[ReferenceRendering2.GET_ATT_STRING=1]="GET_ATT_STRING"})(ReferenceRendering||(exports.ReferenceRendering=ReferenceRendering={}));class CfnReference extends reference_1.Reference{static isCfnReference(x){return CFN_REFERENCE_SYMBOL in x}static for(target,attribute,refRender,typeHint){return CfnReference.singletonReference(target,attribute,refRender,()=>{const cfnIntrinsic=refRender===ReferenceRendering.FN_SUB?"${"+target.logicalId+(attribute==="Ref"?"":`.${attribute}`)+"}":attribute==="Ref"?{Ref:target.logicalId}:{"Fn::GetAtt":refRender===ReferenceRendering.GET_ATT_STRING?`${target.logicalId}.${attribute}`:[target.logicalId,attribute]};return new CfnReference(cfnIntrinsic,attribute,target,typeHint)})}static forPseudo(pseudoName,scope){return CfnReference.singletonReference(scope,`Pseudo:${pseudoName}`,void 0,()=>{const cfnIntrinsic={Ref:pseudoName};return new CfnReference(cfnIntrinsic,pseudoName,scope)})}static singletonReference(target,attribKey,refRender,fresh){let attribs=CfnReference.referenceTable.get(target);attribs||(attribs=new Map,CfnReference.referenceTable.set(target,attribs));let cacheKey=attribKey;switch(refRender){case ReferenceRendering.FN_SUB:cacheKey+="Fn::Sub";break;case ReferenceRendering.GET_ATT_STRING:cacheKey+="Fn::GetAtt::String";break}let ref=attribs.get(cacheKey);return ref||(ref=fresh(),attribs.set(cacheKey,ref)),ref}constructor(value,displayName,target,typeHint){super(value,target,displayName,typeHint),this.target=target,this.replacementTokens=new Map,this.targetStack=stack_1.Stack.of(target),Object.defineProperty(this,CFN_REFERENCE_SYMBOL,{value:!0})}resolve(context){const consumingStack=stack_1.Stack.of(context.scope),token=this.replacementTokens.get(consumingStack);return token?token.resolve(context):super.resolve(context)}hasValueForStack(stack){return stack===this.targetStack?!0:this.replacementTokens.has(stack)}assignValueForStack(stack,value){if(stack===this.targetStack)throw new Error("cannot assign a value for the same stack");if(this.hasValueForStack(stack))throw new Error("Cannot assign a reference value twice to the same stack. Use hasValueForStack to check first");this.replacementTokens.set(stack,value)}toString(){return token_1.Token.asString(this,{displayHint:`${this.target.node.id}.${this.displayName}`})}}exports.CfnReference=CfnReference,CfnReference.referenceTable=new Map;const stack_1=require("../stack"),token_1=require("../token");

"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isDefined=exports.partition=exports.maybeSuffix=exports.noUndefined=exports.noEmptyObject=exports.mkdict=exports.mapValues=exports.filterEmpty=exports.flatten=exports.expectProp=exports.enumerate=exports.flatMap=exports.extract=exports.addAll=void 0;function addAll(into,from){for(const x of from)into.add(x)}exports.addAll=addAll;function extract(from,key){const ret=from.get(key);return from.delete(key),ret}exports.extract=extract;function*flatMap(xs,fn){for(const x of xs)for(const y of fn(x))yield y}exports.flatMap=flatMap;function*enumerate(xs){let i=0;for(const x of xs)yield[i++,x]}exports.enumerate=enumerate;function expectProp(obj,key){if(!obj[key])throw new Error(`Expecting '${String(key)}' to be set!`);return obj[key]}exports.expectProp=expectProp;function*flatten(xs){for(const x of xs)for(const y of x)yield y}exports.flatten=flatten;function filterEmpty(xs){return xs.filter(x=>x)}exports.filterEmpty=filterEmpty;function mapValues(xs,fn){const ret={};for(const[k,v]of Object.entries(xs))ret[k]=fn(v);return ret}exports.mapValues=mapValues;function mkdict(xs){const ret={};for(const[k,v]of xs)ret[k]=v;return ret}exports.mkdict=mkdict;function noEmptyObject(xs){if(Object.keys(xs).length!==0)return xs}exports.noEmptyObject=noEmptyObject;function noUndefined(xs){return mkdict(Object.entries(xs).filter(([_,v])=>isDefined(v)))}exports.noUndefined=noUndefined;function maybeSuffix(x,suffix){if(x!==void 0)return`${x}${suffix}`}exports.maybeSuffix=maybeSuffix;function partition(xs,pred){const yes=[],no=[];for(const x of xs)(pred(x)?yes:no).push(x);return[yes,no]}exports.partition=partition;function isDefined(x){return x!==void 0}exports.isDefined=isDefined;

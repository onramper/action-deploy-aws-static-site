"use strict";var _a;Object.defineProperty(exports,"__esModule",{value:!0}),exports.mergeBuildSpecs=exports.BuildSpec=void 0;const JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti"),yaml_cfn=require("./private/yaml-cfn"),s3_assets=require("../../aws-s3-assets"),core_1=require("../../core");class BuildSpec{static fromObject(value){return new ObjectBuildSpec(value)}static fromObjectToYaml(value){return new YamlBuildSpec(value)}static fromSourceFilename(filename){return new FilenameBuildSpec(filename)}static fromAsset(path){return new AssetBuildSpec(path)}constructor(){}}exports.BuildSpec=BuildSpec,_a=JSII_RTTI_SYMBOL_1,BuildSpec[_a]={fqn:"aws-cdk-lib.aws_codebuild.BuildSpec",version:"2.94.0"};class AssetBuildSpec extends BuildSpec{constructor(path,options={}){super(),this.path=path,this.options=options,this.isImmediate=!0}toBuildSpec(scope){if(!scope)throw new Error("`AssetBuildSpec` requires a `scope` argument");if(!this.asset)this.asset=new s3_assets.Asset(scope,"Code",{path:this.path,...this.options});else if(core_1.Stack.of(this.asset)!==core_1.Stack.of(scope))throw new Error(`Asset is already associated with another stack '${core_1.Stack.of(this.asset).stackName}'. Create a new BuildSpec instance for every stack.`);return this.asset.grantRead(scope),this.asset.bucket.arnForObjects(this.asset.s3ObjectKey)}toString(){return`<buildspec file: ${this.path}>`}}class FilenameBuildSpec extends BuildSpec{constructor(filename){super(),this.filename=filename,this.isImmediate=!1}toBuildSpec(){return this.filename}toString(){return`<buildspec file: ${this.filename}>`}}class ObjectBuildSpec extends BuildSpec{constructor(spec){super(),this.spec=spec,this.isImmediate=!0}toBuildSpec(){return core_1.Lazy.uncachedString({produce:ctx=>core_1.Stack.of(ctx.scope).toJsonString(this.spec,2)})}}class YamlBuildSpec extends BuildSpec{constructor(spec){super(),this.spec=spec,this.isImmediate=!0}toBuildSpec(){return yaml_cfn.serialize(this.spec)}}function mergeBuildSpecs(lhs,rhs){if(!(lhs instanceof ObjectBuildSpec)||!(rhs instanceof ObjectBuildSpec))throw new Error("Can only merge buildspecs created using BuildSpec.fromObject()");if(lhs.spec.version==="0.1")throw new Error('Cannot extend buildspec at version "0.1". Set the version to "0.2" or higher instead.');if(lhs.spec.artifacts&&rhs.spec.artifacts)throw new Error("Only one build spec is allowed to specify artifacts.");const lhsSpec=JSON.parse(JSON.stringify(lhs.spec)),rhsSpec=JSON.parse(JSON.stringify(rhs.spec));normalizeSpec(lhsSpec),normalizeSpec(rhsSpec);const merged=mergeDeep(lhsSpec,rhsSpec);return lhsSpec.reports&&rhsSpec.reports&&(merged.reports={...lhsSpec.reports,...rhsSpec.reports}),new ObjectBuildSpec(merged)}exports.mergeBuildSpecs=mergeBuildSpecs;function normalizeSpec(spec){spec.env&&typeof spec.env["exported-variables"]=="string"&&(spec.env["exported-variables"]=[spec.env["exported-variables"]]);for(const key in spec.phases)Object.prototype.hasOwnProperty.call(spec.phases,key)&&normalizeSpecPhase(spec.phases[key]);if(spec.reports){for(const key in spec.reports)if(Object.prototype.hasOwnProperty.call(spec.reports,key)){const report=spec.reports[key];typeof report.files=="string"&&(report.files=[report.files])}}if(spec.artifacts){typeof spec.artifacts.files=="string"&&(spec.artifacts.files=[spec.artifacts.files]);for(const key in spec.artifacts["secondary-artifacts"])if(Object.prototype.hasOwnProperty.call(spec.artifacts["secondary-artifacts"],key)){const secArtifact=spec.artifacts["secondary-artifacts"][key];typeof secArtifact.files=="string"&&(secArtifact.files=[secArtifact.files])}}spec.cache&&typeof spec.cache.paths=="string"&&(spec.cache.paths=[spec.cache.paths])}function normalizeSpecPhase(phase){phase.commands&&typeof phase.commands=="string"&&(phase.commands=[phase.commands]),phase.finally&&typeof phase.finally=="string"&&(phase.finally=[phase.finally])}function mergeDeep(lhs,rhs){if(Array.isArray(lhs)&&Array.isArray(rhs))return[...lhs,...rhs];if(Array.isArray(lhs)||Array.isArray(rhs))return rhs;const isObject=obj=>obj&&typeof obj=="object";if(isObject(lhs)&&isObject(rhs)){const ret={...lhs};for(const k of Object.keys(rhs))ret[k]=k in lhs?mergeDeep(lhs[k],rhs[k]):rhs[k];return ret}return rhs}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable import/order */
const cx_api_1 = require("@aws-cdk/cx-api");
const mock_sdk_1 = require("./mock-sdk");
const cloudformation_1 = require("../../lib/api/util/cloudformation");
const PARAM = 'TheParameter';
const DEFAULT = 'TheDefault';
const OVERRIDE = 'TheOverride';
const USE_OVERRIDE = { ParameterKey: PARAM, ParameterValue: OVERRIDE };
const USE_PREVIOUS = { ParameterKey: PARAM, UsePreviousValue: true };
let sdkProvider;
let describeStackMock;
let getTemplateMock;
let cfnMocks;
let cfn;
beforeEach(async () => {
    sdkProvider = new mock_sdk_1.MockSdkProvider();
    describeStackMock = jest.fn();
    getTemplateMock = jest.fn();
    cfnMocks = {
        describeStacks: describeStackMock,
        getTemplate: getTemplateMock,
    };
    sdkProvider.stubCloudFormation(cfnMocks);
    cfn = (await sdkProvider.forEnvironment()).sdk.cloudFormation();
});
test('A non-existent stack pretends to have an empty template', async () => {
    // GIVEN
    describeStackMock.mockImplementation(() => ({ Stacks: [] })); // No stacks exist
    // WHEN
    const stack = await cloudformation_1.CloudFormationStack.lookup(cfn, 'Dummy');
    // THEN
    expect(await stack.template()).toEqual({});
});
test("Retrieving a processed template passes 'Processed' to CloudFormation", async () => {
    // GIVEN
    describeStackMock.mockImplementation(() => ({
        Stacks: [
            {
                StackName: 'Dummy',
            },
        ],
    }));
    getTemplateMock.mockImplementation(() => ({
        TemplateBody: '{}',
    }));
    // WHEN
    const retrieveProcessedTemplate = true;
    const cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, 'Dummy', retrieveProcessedTemplate);
    await cloudFormationStack.template();
    // THEN
    expect(getTemplateMock).toHaveBeenCalledWith({
        StackName: 'Dummy',
        TemplateStage: 'Processed',
    });
});
test.each([
    [false, false],
    [false, true],
    [true, false],
    [true, true],
])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)', (haveDefault, havePrevious) => {
    expect(makeParams(haveDefault, havePrevious, true)).toEqual({
        apiParameters: [USE_OVERRIDE],
        changed: true,
    });
});
test('no default, no prev, no override => error', () => {
    expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);
});
test('no default, yes prev, no override => use previous', () => {
    expect(makeParams(false, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('default, no prev, no override => empty param set (and obviously changes to be applied)', () => {
    expect(makeParams(true, false, false)).toEqual({
        apiParameters: [],
        changed: true,
    });
});
test('default, prev, no override => use previous', () => {
    expect(makeParams(true, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
            },
        },
    });
    const oldValues = { Foo: '/Some/Key' };
    // If we don't pass a new value
    expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual('ssm');
    // If we do pass a new value but it's the same as the old one
    expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual('ssm');
});
test('if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
                Description: `blabla ${cx_api_1.SSMPARAM_NO_INVALIDATE}`,
            },
        },
    });
    const oldValues = { Foo: '/Some/Key' };
    // If we don't pass a new value
    expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual(false);
    // If we do pass a new value but it's the same as the old one
    expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual(false);
    // If we do pass a new value and it's different
    expect(params.updateExisting({ Foo: '/OTHER/Key' }, oldValues).hasChanges(oldValues)).toEqual(true);
});
test('empty string is a valid update value', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.updateExisting({ Foo: '' }, { Foo: 'ThisIsOld' }).apiParameters).toEqual([
        { ParameterKey: 'Foo', ParameterValue: '' },
    ]);
});
test('unknown parameter in overrides, pass it anyway', () => {
    // Not sure if we really want this. It seems like it would be nice
    // to not pass parameters that aren't expected, given that CFN will
    // just error out. But maybe we want to be warned of typos...
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.updateExisting({ Bar: 'Bar' }, {}).apiParameters).toEqual([
        { ParameterKey: 'Bar', ParameterValue: 'Bar' },
    ]);
});
test('if an unsupplied parameter reverts to its default, it can still be dirty', () => {
    // GIVEN
    const templateParams = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    // WHEN
    const stackParams = templateParams.supplyAll({});
    // THEN
    expect(stackParams.hasChanges({ Foo: 'NonStandard' })).toEqual(true);
    expect(stackParams.hasChanges({ Foo: 'Foo' })).toEqual(false);
});
function makeParams(defaultValue, hasPrevValue, override) {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            [PARAM]: {
                Type: 'String',
                Default: defaultValue ? DEFAULT : undefined,
            },
        },
    });
    const prevParams = hasPrevValue ? { [PARAM]: 'Foo' } : {};
    const stackParams = params.updateExisting({ [PARAM]: override ? OVERRIDE : undefined }, prevParams);
    return { apiParameters: stackParams.apiParameters, changed: stackParams.hasChanges(prevParams) };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkZm9ybWF0aW9uLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBaUM7QUFDakMsNENBQXlEO0FBQ3pELHlDQUFnRjtBQUNoRixzRUFBNEY7QUFFNUYsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDO0FBQzdCLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQztBQUM3QixNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUM7QUFFL0IsTUFBTSxZQUFZLEdBQUcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsQ0FBQztBQUN2RSxNQUFNLFlBQVksR0FBRyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLENBQUM7QUFFckUsSUFBSSxXQUE0QixDQUFDO0FBQ2pDLElBQUksaUJBQTRCLENBQUM7QUFDakMsSUFBSSxlQUEwQixDQUFDO0FBQy9CLElBQUksUUFBK0QsQ0FBQztBQUNwRSxJQUFJLEdBQXVCLENBQUM7QUFDNUIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0lBQ3BCLFdBQVcsR0FBRyxJQUFJLDBCQUFlLEVBQUUsQ0FBQztJQUVwQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDOUIsZUFBZSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUM1QixRQUFRLEdBQUc7UUFDVCxjQUFjLEVBQUUsaUJBQWlCO1FBQ2pDLFdBQVcsRUFBRSxlQUFlO0tBQzdCLENBQUM7SUFDRixXQUFXLENBQUMsa0JBQWtCLENBQUMsUUFBZSxDQUFDLENBQUM7SUFDaEQsR0FBRyxHQUFHLENBQUMsTUFBTSxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDbEUsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENB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TyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hFLENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxVQUFVLENBQUMsWUFBcUIsRUFBRSxZQUFxQixFQUFFLFFBQWlCO0lBQ2pGLE1BQU0sTUFBTSxHQUFHLG1DQUFrQixDQUFDLFlBQVksQ0FBQztRQUM3QyxVQUFVLEVBQUU7WUFDVixDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNQLElBQUksRUFBRSxRQUFRO2dCQUNkLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUzthQUM1QztTQUNGO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxVQUFVLEdBQTJCLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbEYsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRXBHLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxDQUFDLGFBQWEsRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO0FBQ25HLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvb3JkZXIgKi9cbmltcG9ydCB7IFNTTVBBUkFNX05PX0lOVkFMSURBVEUgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgTW9ja2VkT2JqZWN0LCBNb2NrU2RrUHJvdmlkZXIsIFN5bmNIYW5kbGVyU3Vic2V0T2YgfSBmcm9tICcuL21vY2stc2RrJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2ssIFRlbXBsYXRlUGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL2xpYi9hcGkvdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5cbmNvbnN0IFBBUkFNID0gJ1RoZVBhcmFtZXRlcic7XG5jb25zdCBERUZBVUxUID0gJ1RoZURlZmF1bHQnO1xuY29uc3QgT1ZFUlJJREUgPSAnVGhlT3ZlcnJpZGUnO1xuXG5jb25zdCBVU0VfT1ZFUlJJREUgPSB7IFBhcmFtZXRlcktleTogUEFSQU0sIFBhcmFtZXRlclZhbHVlOiBPVkVSUklERSB9O1xuY29uc3QgVVNFX1BSRVZJT1VTID0geyBQYXJhbWV0ZXJLZXk6IFBBUkFNLCBVc2VQcmV2aW91c1ZhbHVlOiB0cnVlIH07XG5cbmxldCBzZGtQcm92aWRlcjogTW9ja1Nka1Byb3ZpZGVyO1xubGV0IGRlc2NyaWJlU3RhY2tNb2NrOiBqZXN0Lk1vY2s7XG5sZXQgZ2V0VGVtcGxhdGVNb2NrOiBqZXN0Lk1vY2s7XG5sZXQgY2ZuTW9ja3M6IE1vY2tlZE9iamVjdDxTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5DbG91ZEZvcm1hdGlvbj4+O1xubGV0IGNmbjogQVdTLkNsb3VkRm9ybWF0aW9uO1xuYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gIHNka1Byb3ZpZGVyID0gbmV3IE1vY2tTZGtQcm92aWRlcigpO1xuXG4gIGRlc2NyaWJlU3RhY2tNb2NrID0gamVzdC5mbigpO1xuICBnZXRUZW1wbGF0ZU1vY2sgPSBqZXN0LmZuKCk7XG4gIGNmbk1vY2tzID0ge1xuICAgIGRlc2NyaWJlU3RhY2tzOiBkZXNjcmliZVN0YWNrTW9jayxcbiAgICBnZXRUZW1wbGF0ZTogZ2V0VGVtcGxhdGVNb2NrLFxuICB9O1xuICBzZGtQcm92aWRlci5zdHViQ2xvdWRGb3JtYXRpb24oY2ZuTW9ja3MgYXMgYW55KTtcbiAgY2ZuID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KCkpLnNkay5jbG91ZEZvcm1hdGlvbigpO1xufSk7XG5cbnRlc3QoJ0Egbm9uLWV4aXN0ZW50IHN0YWNrIHByZXRlbmRzIHRvIGhhdmUgYW4gZW1wdHkgdGVtcGxhdGUnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGRlc2NyaWJlU3RhY2tNb2NrLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoeyBTdGFja3M6IFtdIH0pKTsgLy8gTm8gc3RhY2tzIGV4aXN0XG5cbiAgLy8gV0hFTlxuICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgJ0R1bW15Jyk7XG5cbiAgLy8gVEhFTlxuICBleHBlY3QoYXdhaXQgc3RhY2sudGVtcGxhdGUoKSkudG9FcXVhbCh7fSk7XG59KTtcblxudGVzdChcIlJldHJpZXZpbmcgYSBwcm9jZXNzZWQgdGVtcGxhdGUgcGFzc2VzICdQcm9jZXNzZWQnIHRvIENsb3VkRm9ybWF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgZGVzY3JpYmVTdGFja01vY2subW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgU3RhY2tzOiBbXG4gICAgICB7XG4gICAgICAgIFN0YWNrTmFtZTogJ0R1bW15JyxcbiAgICAgIH0sXG4gICAgXSxcbiAgfSkpO1xuICBnZXRUZW1wbGF0ZU1vY2subW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgVGVtcGxhdGVCb2R5OiAne30nLFxuICB9KSk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlID0gdHJ1ZTtcbiAgY29uc3QgY2xvdWRGb3JtYXRpb25TdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgJ0R1bW15JywgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZSk7XG4gIGF3YWl0IGNsb3VkRm9ybWF0aW9uU3RhY2sudGVtcGxhdGUoKTtcblxuICAvLyBUSEVOXG4gIGV4cGVjdChnZXRUZW1wbGF0ZU1vY2spLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICBTdGFja05hbWU6ICdEdW1teScsXG4gICAgVGVtcGxhdGVTdGFnZTogJ1Byb2Nlc3NlZCcsXG4gIH0pO1xufSk7XG5cbnRlc3QuZWFjaChbXG4gIFtmYWxzZSwgZmFsc2VdLFxuICBbZmFsc2UsIHRydWVdLFxuICBbdHJ1ZSwgZmFsc2VdLFxuICBbdHJ1ZSwgdHJ1ZV0sXG5dKSgnZ2l2ZW4gb3ZlcnJpZGUsIGFsd2F5cyB1c2UgdGhlIG92ZXJyaWRlIChwYXJhbWV0ZXIgaGFzIGEgZGVmYXVsdDogJXAsIHBhcmFtZXRlciBwcmV2aW91c2x5IHN1cHBsaWVkOiAlcCknLFxuICAoaGF2ZURlZmF1bHQsIGhhdmVQcmV2aW91cykgPT4ge1xuICAgIGV4cGVjdChtYWtlUGFyYW1zKGhhdmVEZWZhdWx0LCBoYXZlUHJldmlvdXMsIHRydWUpKS50b0VxdWFsKHtcbiAgICAgIGFwaVBhcmFtZXRlcnM6IFtVU0VfT1ZFUlJJREVdLFxuICAgICAgY2hhbmdlZDogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbnRlc3QoJ25vIGRlZmF1bHQsIG5vIHByZXYsIG5vIG92ZXJyaWRlID0+IGVycm9yJywgKCkgPT4ge1xuICBleHBlY3QoKCkgPT4gbWFrZVBhcmFtcyhmYWxzZSwgZmFsc2UsIGZhbHNlKSkudG9UaHJvdygvbWlzc2luZyBhIHZhbHVlOiBUaGVQYXJhbWV0ZXIvKTtcbn0pO1xuXG50ZXN0KCdubyBkZWZhdWx0LCB5ZXMgcHJldiwgbm8gb3ZlcnJpZGUgPT4gdXNlIHByZXZpb3VzJywgKCkgPT4ge1xuICBleHBlY3QobWFrZVBhcmFtcyhmYWxzZSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKHtcbiAgICBhcGlQYXJhbWV0ZXJzOiBbVVNFX1BSRVZJT1VTXSxcbiAgICBjaGFuZ2VkOiBmYWxzZSxcbiAgfSk7XG59KTtcblxudGVzdCgnZGVmYXVsdCwgbm8gcHJldiwgbm8gb3ZlcnJpZGUgPT4gZW1wdHkgcGFyYW0gc2V0IChhbmQgb2J2aW91c2x5IGNoYW5nZXMgdG8gYmUgYXBwbGllZCknLCAoKSA9PiB7XG4gIGV4cGVjdChtYWtlUGFyYW1zKHRydWUsIGZhbHNlLCBmYWxzZSkpLnRvRXF1YWwoe1xuICAgIGFwaVBhcmFtZXRlcnM6IFtdLFxuICAgIGNoYW5nZWQ6IHRydWUsXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2RlZmF1bHQsIHByZXYsIG5vIG92ZXJyaWRlID0+IHVzZSBwcmV2aW91cycsICgpID0+IHtcbiAgZXhwZWN0KG1ha2VQYXJhbXModHJ1ZSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKHtcbiAgICBhcGlQYXJhbWV0ZXJzOiBbVVNFX1BSRVZJT1VTXSxcbiAgICBjaGFuZ2VkOiBmYWxzZSxcbiAgfSk7XG59KTtcblxudGVzdCgnaWYgYSBwYXJhbWV0ZXIgaXMgcmV0cmlldmVkIGZyb20gU1NNLCB0aGUgcGFyYW1ldGVycyBhbHdheXMgY291bnQgYXMgY2hhbmdlZCcsICgpID0+IHtcbiAgY29uc3QgcGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgRm9vOiB7XG4gICAgICAgIFR5cGU6ICdBV1M6OlNTTTo6UGFyYW1ldGVyOjpOYW1lJyxcbiAgICAgICAgRGVmYXVsdDogJy9Tb21lL0tleScsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICBjb25zdCBvbGRWYWx1ZXMgPSB7IEZvbzogJy9Tb21lL0tleScgfTtcblxuICAvLyBJZiB3ZSBkb24ndCBwYXNzIGEgbmV3IHZhbHVlXG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3Rpbmcoe30sIG9sZFZhbHVlcykuaGFzQ2hhbmdlcyhvbGRWYWx1ZXMpKS50b0VxdWFsKCdzc20nKTtcblxuICAvLyBJZiB3ZSBkbyBwYXNzIGEgbmV3IHZhbHVlIGJ1dCBpdCdzIHRoZSBzYW1lIGFzIHRoZSBvbGQgb25lXG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3RpbmcoeyBGb286ICcvU29tZS9LZXknIH0sIG9sZFZhbHVlcykuaGFzQ2hhbmdlcyhvbGRWYWx1ZXMpKS50b0VxdWFsKCdzc20nKTtcbn0pO1xuXG50ZXN0KCdpZiBhIHBhcmFtZXRlciBpcyByZXRyaWV2ZWQgZnJvbSBTU00sIHRoZSBwYXJhbWV0ZXJzIGRvZXNudCBjb3VudCBhcyBjaGFuZ2VkIGlmIGl0IGhhcyB0aGUgbWFnaWMgbWFya2VyJywgKCkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHtcbiAgICAgICAgVHlwZTogJ0FXUzo6U1NNOjpQYXJhbWV0ZXI6Ok5hbWUnLFxuICAgICAgICBEZWZhdWx0OiAnL1NvbWUvS2V5JyxcbiAgICAgICAgRGVzY3JpcHRpb246IGBibGFibGEgJHtTU01QQVJBTV9OT19JTlZBTElEQVRFfWAsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICBjb25zdCBvbGRWYWx1ZXMgPSB7IEZvbzogJy9Tb21lL0tleScgfTtcblxuICAvLyBJZiB3ZSBkb24ndCBwYXNzIGEgbmV3IHZhbHVlXG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3Rpbmcoe30sIG9sZFZhbHVlcykuaGFzQ2hhbmdlcyhvbGRWYWx1ZXMpKS50b0VxdWFsKGZhbHNlKTtcblxuICAvLyBJZiB3ZSBkbyBwYXNzIGEgbmV3IHZhbHVlIGJ1dCBpdCdzIHRoZSBzYW1lIGFzIHRoZSBvbGQgb25lXG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3RpbmcoeyBGb286ICcvU29tZS9LZXknIH0sIG9sZFZhbHVlcykuaGFzQ2hhbmdlcyhvbGRWYWx1ZXMpKS50b0VxdWFsKGZhbHNlKTtcblxuICAvLyBJZiB3ZSBkbyBwYXNzIGEgbmV3IHZhbHVlIGFuZCBpdCdzIGRpZmZlcmVudFxuICBleHBlY3QocGFyYW1zLnVwZGF0ZUV4aXN0aW5nKHsgRm9vOiAnL09USEVSL0tleScgfSwgb2xkVmFsdWVzKS5oYXNDaGFuZ2VzKG9sZFZhbHVlcykpLnRvRXF1YWwodHJ1ZSk7XG59KTtcblxudGVzdCgnZW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgdXBkYXRlIHZhbHVlJywgKCkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHsgVHlwZTogJ1N0cmluZycsIERlZmF1bHQ6ICdGb28nIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgZXhwZWN0KHBhcmFtcy51cGRhdGVFeGlzdGluZyh7IEZvbzogJycgfSwgeyBGb286ICdUaGlzSXNPbGQnIH0pLmFwaVBhcmFtZXRlcnMpLnRvRXF1YWwoW1xuICAgIHsgUGFyYW1ldGVyS2V5OiAnRm9vJywgUGFyYW1ldGVyVmFsdWU6ICcnIH0sXG4gIF0pO1xufSk7XG5cbnRlc3QoJ3Vua25vd24gcGFyYW1ldGVyIGluIG92ZXJyaWRlcywgcGFzcyBpdCBhbnl3YXknLCAoKSA9PiB7XG4gIC8vIE5vdCBzdXJlIGlmIHdlIHJlYWxseSB3YW50IHRoaXMuIEl0IHNlZW1zIGxpa2UgaXQgd291bGQgYmUgbmljZVxuICAvLyB0byBub3QgcGFzcyBwYXJhbWV0ZXJzIHRoYXQgYXJlbid0IGV4cGVjdGVkLCBnaXZlbiB0aGF0IENGTiB3aWxsXG4gIC8vIGp1c3QgZXJyb3Igb3V0LiBCdXQgbWF5YmUgd2Ugd2FudCB0byBiZSB3YXJuZWQgb2YgdHlwb3MuLi5cbiAgY29uc3QgcGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgRm9vOiB7IFR5cGU6ICdTdHJpbmcnLCBEZWZhdWx0OiAnRm9vJyB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIGV4cGVjdChwYXJhbXMudXBkYXRlRXhpc3RpbmcoeyBCYXI6ICdCYXInIH0sIHt9KS5hcGlQYXJhbWV0ZXJzKS50b0VxdWFsKFtcbiAgICB7IFBhcmFtZXRlcktleTogJ0JhcicsIFBhcmFtZXRlclZhbHVlOiAnQmFyJyB9LFxuICBdKTtcbn0pO1xuXG50ZXN0KCdpZiBhbiB1bnN1cHBsaWVkIHBhcmFtZXRlciByZXZlcnRzIHRvIGl0cyBkZWZhdWx0LCBpdCBjYW4gc3RpbGwgYmUgZGlydHknLCAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgRm9vOiB7IFR5cGU6ICdTdHJpbmcnLCBEZWZhdWx0OiAnRm9vJyB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFdIRU5cbiAgY29uc3Qgc3RhY2tQYXJhbXMgPSB0ZW1wbGF0ZVBhcmFtcy5zdXBwbHlBbGwoe30pO1xuXG4gIC8vIFRIRU5cbiAgZXhwZWN0KHN0YWNrUGFyYW1zLmhhc0NoYW5nZXMoeyBGb286ICdOb25TdGFuZGFyZCcgfSkpLnRvRXF1YWwodHJ1ZSk7XG4gIGV4cGVjdChzdGFja1BhcmFtcy5oYXNDaGFuZ2VzKHsgRm9vOiAnRm9vJyB9KSkudG9FcXVhbChmYWxzZSk7XG59KTtcblxuZnVuY3Rpb24gbWFrZVBhcmFtcyhkZWZhdWx0VmFsdWU6IGJvb2xlYW4sIGhhc1ByZXZWYWx1ZTogYm9vbGVhbiwgb3ZlcnJpZGU6IGJvb2xlYW4pIHtcbiAgY29uc3QgcGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgW1BBUkFNXToge1xuICAgICAgICBUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgRGVmYXVsdDogZGVmYXVsdFZhbHVlID8gREVGQVVMVCA6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IHByZXZQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBoYXNQcmV2VmFsdWUgPyB7IFtQQVJBTV06ICdGb28nIH0gOiB7fTtcbiAgY29uc3Qgc3RhY2tQYXJhbXMgPSBwYXJhbXMudXBkYXRlRXhpc3RpbmcoeyBbUEFSQU1dOiBvdmVycmlkZSA/IE9WRVJSSURFIDogdW5kZWZpbmVkIH0sIHByZXZQYXJhbXMpO1xuXG4gIHJldHVybiB7IGFwaVBhcmFtZXRlcnM6IHN0YWNrUGFyYW1zLmFwaVBhcmFtZXRlcnMsIGNoYW5nZWQ6IHN0YWNrUGFyYW1zLmhhc0NoYW5nZXMocHJldlBhcmFtcykgfTtcbn1cbiJdfQ==
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockSpawn = void 0;
const child_process = require("child_process");
const events = require("events");
if (!child_process.spawn.mockImplementationOnce) {
    throw new Error('Call "jest.mock(\'child_process\');" at the top of the test file!');
}
function mockSpawn(...invocations) {
    let mock = child_process.spawn;
    for (const _invocation of invocations) {
        const invocation = _invocation; // Mirror into variable for closure
        mock = mock.mockImplementationOnce((binary, options) => {
            var _a, _b;
            expect(binary).toEqual(invocation.commandLine);
            if (invocation.cwd != null) {
                expect(options.cwd).toBe(invocation.cwd);
            }
            if (invocation.sideEffect) {
                invocation.sideEffect();
            }
            const child = new events.EventEmitter();
            child.stdin = new events.EventEmitter();
            child.stdin.write = jest.fn();
            child.stdin.end = jest.fn();
            child.stdout = new events.EventEmitter();
            child.stderr = new events.EventEmitter();
            if (invocation.stdout) {
                mockEmit(child.stdout, 'data', invocation.stdout);
            }
            mockEmit(child, 'close', (_a = invocation.exitCode) !== null && _a !== void 0 ? _a : 0);
            mockEmit(child, 'exit', (_b = invocation.exitCode) !== null && _b !== void 0 ? _b : 0);
            return child;
        });
    }
    mock.mockImplementation((binary, _options) => {
        throw new Error(`Did not expect call of ${binary}`);
    });
}
exports.mockSpawn = mockSpawn;
/**
 * Must do this on the next tick, as emitter.emit() expects all listeners to have been attached already
 */
function mockEmit(emitter, event, data) {
    setImmediate(() => {
        emitter.emit(event, data);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1jaGlsZF9wcm9jZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibW9jay1jaGlsZF9wcm9jZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtDQUErQztBQUMvQyxpQ0FBaUM7QUFFakMsSUFBSSxDQUFFLGFBQXFCLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFO0lBQ3hELE1BQU0sSUFBSSxLQUFLLENBQUMsbUVBQW1FLENBQUMsQ0FBQztDQUN0RjtBQWNELFNBQWdCLFNBQVMsQ0FBQyxHQUFHLFdBQXlCO0lBQ3BELElBQUksSUFBSSxHQUFJLGFBQWEsQ0FBQyxLQUFhLENBQUM7SUFDeEMsS0FBSyxNQUFNLFdBQVcsSUFBSSxXQUFXLEVBQUU7UUFDckMsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLENBQUMsbUNBQW1DO1FBQ25FLElBQUksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxNQUFjLEVBQUUsT0FBbUMsRUFBRSxFQUFFOztZQUN6RixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUUvQyxJQUFJLFVBQVUsQ0FBQyxHQUFHLElBQUksSUFBSSxFQUFFO2dCQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDMUM7WUFFRCxJQUFJLFVBQVUsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pCLFVBQVUsQ0FBQyxVQUFVLEVBQUUsQ0FBQzthQUN6QjtZQUVELE1BQU0sS0FBSyxHQUFRLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzdDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzlCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM1QixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFekMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFO2dCQUNyQixRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ25EO1lBQ0QsUUFBUSxDQUFDLEtBQUssRUFBRSxPQUFPLFFBQUUsVUFBVSxDQUFDLFFBQVEsbUNBQUksQ0FBQyxDQUFDLENBQUM7WUFDbkQsUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLFFBQUUsVUFBVSxDQUFDLFFBQVEsbUNBQUksQ0FBQyxDQUFDLENBQUM7WUFFbEQsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztLQUNKO0lBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBYyxFQUFFLFFBQWEsRUFBRSxFQUFFO1FBQ3hELE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDdEQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBbkNELDhCQW1DQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxRQUFRLENBQUMsT0FBNEIsRUFBRSxLQUFhLEVBQUUsSUFBUztJQUN0RSxZQUFZLENBQUMsR0FBRyxFQUFFO1FBQ2hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzVCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBldmVudHMgZnJvbSAnZXZlbnRzJztcblxuaWYgKCEoY2hpbGRfcHJvY2VzcyBhcyBhbnkpLnNwYXduLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIFwiamVzdC5tb2NrKFxcJ2NoaWxkX3Byb2Nlc3NcXCcpO1wiIGF0IHRoZSB0b3Agb2YgdGhlIHRlc3QgZmlsZSEnKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnZvY2F0aW9uIHtcbiAgY29tbWFuZExpbmU6IHN0cmluZztcbiAgY3dkPzogc3RyaW5nO1xuICBleGl0Q29kZT86IG51bWJlcjtcbiAgc3Rkb3V0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSdW4gdGhpcyBmdW5jdGlvbiBhcyBhIHNpZGUgZWZmZWN0LCBpZiBwcmVzZW50XG4gICAqL1xuICBzaWRlRWZmZWN0PzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vY2tTcGF3biguLi5pbnZvY2F0aW9uczogSW52b2NhdGlvbltdKSB7XG4gIGxldCBtb2NrID0gKGNoaWxkX3Byb2Nlc3Muc3Bhd24gYXMgYW55KTtcbiAgZm9yIChjb25zdCBfaW52b2NhdGlvbiBvZiBpbnZvY2F0aW9ucykge1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBfaW52b2NhdGlvbjsgLy8gTWlycm9yIGludG8gdmFyaWFibGUgZm9yIGNsb3N1cmVcbiAgICBtb2NrID0gbW9jay5tb2NrSW1wbGVtZW50YXRpb25PbmNlKChiaW5hcnk6IHN0cmluZywgb3B0aW9uczogY2hpbGRfcHJvY2Vzcy5TcGF3bk9wdGlvbnMpID0+IHtcbiAgICAgIGV4cGVjdChiaW5hcnkpLnRvRXF1YWwoaW52b2NhdGlvbi5jb21tYW5kTGluZSk7XG5cbiAgICAgIGlmIChpbnZvY2F0aW9uLmN3ZCAhPSBudWxsKSB7XG4gICAgICAgIGV4cGVjdChvcHRpb25zLmN3ZCkudG9CZShpbnZvY2F0aW9uLmN3ZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZvY2F0aW9uLnNpZGVFZmZlY3QpIHtcbiAgICAgICAgaW52b2NhdGlvbi5zaWRlRWZmZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkOiBhbnkgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkaW4gPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkaW4ud3JpdGUgPSBqZXN0LmZuKCk7XG4gICAgICBjaGlsZC5zdGRpbi5lbmQgPSBqZXN0LmZuKCk7XG4gICAgICBjaGlsZC5zdGRvdXQgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkZXJyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcblxuICAgICAgaWYgKGludm9jYXRpb24uc3Rkb3V0KSB7XG4gICAgICAgIG1vY2tFbWl0KGNoaWxkLnN0ZG91dCwgJ2RhdGEnLCBpbnZvY2F0aW9uLnN0ZG91dCk7XG4gICAgICB9XG4gICAgICBtb2NrRW1pdChjaGlsZCwgJ2Nsb3NlJywgaW52b2NhdGlvbi5leGl0Q29kZSA/PyAwKTtcbiAgICAgIG1vY2tFbWl0KGNoaWxkLCAnZXhpdCcsIGludm9jYXRpb24uZXhpdENvZGUgPz8gMCk7XG5cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KTtcbiAgfVxuXG4gIG1vY2subW9ja0ltcGxlbWVudGF0aW9uKChiaW5hcnk6IHN0cmluZywgX29wdGlvbnM6IGFueSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGlkIG5vdCBleHBlY3QgY2FsbCBvZiAke2JpbmFyeX1gKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTXVzdCBkbyB0aGlzIG9uIHRoZSBuZXh0IHRpY2ssIGFzIGVtaXR0ZXIuZW1pdCgpIGV4cGVjdHMgYWxsIGxpc3RlbmVycyB0byBoYXZlIGJlZW4gYXR0YWNoZWQgYWxyZWFkeVxuICovXG5mdW5jdGlvbiBtb2NrRW1pdChlbWl0dGVyOiBldmVudHMuRXZlbnRFbWl0dGVyLCBldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBlbWl0dGVyLmVtaXQoZXZlbnQsIGRhdGEpO1xuICB9KTtcbn1cbiJdfQ==
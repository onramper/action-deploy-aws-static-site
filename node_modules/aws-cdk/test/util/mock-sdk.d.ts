/// <reference types="jest" />
import * as cxapi from '@aws-cdk/cx-api';
import * as AWS from 'aws-sdk';
import { Account, ISDK, SdkProvider, SdkForEnvironment } from '../../lib/api/aws-auth';
import { Mode } from '../../lib/api/aws-auth/credentials';
import { ToolkitInfo } from '../../lib/api/toolkit-info';
import { CloudFormationStack } from '../../lib/api/util/cloudformation';
export interface MockSdkProviderOptions {
    /**
     * Whether the mock provider should produce a real SDK
     *
     * Some tests require a real SDK because they use `AWS-mock` to replace
     * the underlying calls. Other tests do their work completely using jest-mocks.
     *
     * @default true
     */
    readonly realSdk?: boolean;
}
/**
 * An SDK that allows replacing (some of) the clients
 *
 * It's the responsibility of the consumer to replace all calls that
 * actually will be called.
 */
export declare class MockSdkProvider extends SdkProvider {
    readonly sdk: ISDK;
    private readonly _mockSdk?;
    constructor(options?: MockSdkProviderOptions);
    get mockSdk(): MockSdk;
    baseCredentialsPartition(_environment: cxapi.Environment, _mode: Mode): Promise<string | undefined>;
    defaultAccount(): Promise<Account | undefined>;
    forEnvironment(): Promise<SdkForEnvironment>;
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs: SyncHandlerSubsetOf<AWS.CloudFormation>): void;
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs: SyncHandlerSubsetOf<AWS.ECR>): void;
    stubEcs(stubs: SyncHandlerSubsetOf<AWS.ECS>, additionalProperties?: {
        [key: string]: any;
    }): void;
    /**
     * Replace the S3 client with the given object
     */
    stubS3(stubs: SyncHandlerSubsetOf<AWS.S3>): void;
    /**
     * Replace the STS client with the given object
     */
    stubSTS(stubs: SyncHandlerSubsetOf<AWS.STS>): void;
    /**
     * Replace the ELBv2 client with the given object
     */
    stubELBv2(stubs: SyncHandlerSubsetOf<AWS.ELBv2>): void;
    /**
     * Replace the SSM client with the given object
     */
    stubSSM(stubs: SyncHandlerSubsetOf<AWS.SSM>): void;
    stubLambda(stubs: SyncHandlerSubsetOf<AWS.Lambda>, additionalProperties?: {
        [key: string]: any;
    }): void;
    stubIam(stubs: SyncHandlerSubsetOf<AWS.IAM>, additionalProperties?: {
        [key: string]: any;
    }): void;
    stubStepFunctions(stubs: SyncHandlerSubsetOf<AWS.StepFunctions>): void;
    stubCodeBuild(stubs: SyncHandlerSubsetOf<AWS.CodeBuild>): void;
    stubCloudWatchLogs(stubs: SyncHandlerSubsetOf<AWS.CloudWatchLogs>): void;
    stubAppSync(stubs: SyncHandlerSubsetOf<AWS.AppSync>): void;
    stubGetEndpointSuffix(stub: () => string): void;
}
export declare class MockSdk implements ISDK {
    readonly currentRegion: string;
    readonly lambda: jest.Mock<any, any, any>;
    readonly iam: jest.Mock<any, any, any>;
    readonly cloudFormation: jest.Mock<any, any, any>;
    readonly ec2: jest.Mock<any, any, any>;
    readonly ssm: jest.Mock<any, any, any>;
    readonly s3: jest.Mock<any, any, any>;
    readonly route53: jest.Mock<any, any, any>;
    readonly ecr: jest.Mock<any, any, any>;
    readonly ecs: jest.Mock<any, any, any>;
    readonly elbv2: jest.Mock<any, any, any>;
    readonly secretsManager: jest.Mock<any, any, any>;
    readonly kms: jest.Mock<any, any, any>;
    readonly stepFunctions: jest.Mock<any, any, any>;
    readonly codeBuild: jest.Mock<any, any, any>;
    readonly cloudWatchLogs: jest.Mock<any, any, any>;
    readonly appsync: jest.Mock<any, any, any>;
    readonly getEndpointSuffix: jest.Mock<any, any, any>;
    readonly appendCustomUserAgent: jest.Mock<any, any, any>;
    readonly removeCustomUserAgent: jest.Mock<any, any, any>;
    currentAccount(): Promise<Account>;
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs: SyncHandlerSubsetOf<AWS.CloudFormation>): void;
    /**
     * Replace the CloudWatch client with the given object
     */
    stubCloudWatchLogs(stubs: SyncHandlerSubsetOf<AWS.CloudWatchLogs>): void;
    /**
     * Replace the AppSync client with the given object
     */
    stubAppSync(stubs: SyncHandlerSubsetOf<AWS.AppSync>): void;
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs: SyncHandlerSubsetOf<AWS.ECR>): void;
    /**
     * Replace the SSM client with the given object
     */
    stubSsm(stubs: SyncHandlerSubsetOf<AWS.SSM>): void;
    /**
     * Replace the getEndpointSuffix client with the given object
     */
    stubGetEndpointSuffix(stub: () => string): void;
}
type AwsCallInputOutput<T> = T extends {
    (args: infer INPUT, callback?: ((err: AWS.AWSError, data: any) => void) | undefined): AWS.Request<infer OUTPUT, AWS.AWSError>;
    (callback?: ((err: AWS.AWSError, data: {}) => void) | undefined): AWS.Request<any, any>;
} ? [INPUT, OUTPUT] : T;
type MockHandlerType<AI> = AI extends [any, any] ? (input: AI[0]) => AI[1] : AI;
export type SyncHandlerSubsetOf<S> = {
    [K in keyof S]?: MockHandlerType<AwsCallInputOutput<S[K]>>;
};
export declare function mockBootstrapStack(sdk: ISDK | undefined, stack?: Partial<AWS.CloudFormation.Stack>): CloudFormationStack;
export declare function mockToolkitInfo(stack?: Partial<AWS.CloudFormation.Stack>): ToolkitInfo;
export declare function mockResolvedEnvironment(): cxapi.Environment;
export type MockedObject<S extends object> = {
    [K in keyof S]: MockedFunction<Required<S>[K]>;
};
type MockedFunction<T> = T extends (...args: any[]) => any ? jest.MockInstance<ReturnType<T>, jest.ArgsType<T>> : T;
export declare function errorWithCode(code: string, message: string): Error;
export {};

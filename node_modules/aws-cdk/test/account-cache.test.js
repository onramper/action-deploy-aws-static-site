"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const account_cache_1 = require("../lib/api/aws-auth/account-cache");
async function makeCache() {
    const dir = await fs.mkdtemp('/tmp/account-cache-test');
    const file = path.join(dir, 'cache.json');
    return {
        cacheDir: dir,
        cacheFile: file,
        cache: new account_cache_1.AccountAccessKeyCache(file),
    };
}
async function nukeCache(cacheDir) {
    await fs.remove(cacheDir);
}
test('default account cache uses CDK_HOME', () => {
    process.env.CDK_HOME = '/banana';
    const cache = new account_cache_1.AccountAccessKeyCache();
    expect(cache.cacheFile).toContain('/banana/');
});
test('account cache does not fail when given a nonwritable directory', async () => {
    const accessError = new Error('Oh no');
    accessError.code = 'EACCES';
    return withMocked(fs, 'mkdirs', async (mkdirs) => {
        // Have to do this because mkdirs has 2 overloads and it confuses TypeScript
        mkdirs.mockRejectedValue(accessError);
        const cache = new account_cache_1.AccountAccessKeyCache('/abc/xyz');
        await cache.fetch('xyz', () => Promise.resolve({ accountId: 'asdf', partition: 'swa' }));
        // No exception
    });
});
test('get(k) when cache is empty', async () => {
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        expect(await cache.get('foo')).toBeUndefined();
        expect(await fs.pathExists(cacheFile)).toBeFalsy();
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test('put(k,v) and then get(k)', async () => {
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        await cache.put('key', { accountId: 'value', partition: 'aws' });
        await cache.put('boo', { accountId: 'bar', partition: 'aws' });
        expect(await cache.get('key')).toEqual({ accountId: 'value', partition: 'aws' });
        // create another cache instance on the same file, should still work
        const cache2 = new account_cache_1.AccountAccessKeyCache(cacheFile);
        expect(await cache2.get('boo')).toEqual({ accountId: 'bar', partition: 'aws' });
        // whitebox: read the file
        expect(await fs.readJson(cacheFile)).toEqual({
            key: { accountId: 'value', partition: 'aws' },
            boo: { accountId: 'bar', partition: 'aws' },
        });
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test('fetch(k, resolver) can be used to "atomically" get + resolve + put', async () => {
    const { cacheDir, cache } = await makeCache();
    try {
        expect(await cache.get('foo')).toBeUndefined();
        expect(await cache.fetch('foo', async () => ({ accountId: 'bar', partition: 'aws' }))).toEqual({ accountId: 'bar', partition: 'aws' });
        expect(await cache.get('foo')).toEqual({ accountId: 'bar', partition: 'aws' });
    }
    finally {
        await nukeCache(cacheDir);
    }
});
test(`cache is nuked if it exceeds ${account_cache_1.AccountAccessKeyCache.MAX_ENTRIES} entries`, async () => {
    // This makes a lot of promises, so it can queue for a while...
    jest.setTimeout(30000);
    const { cacheDir, cacheFile, cache } = await makeCache();
    try {
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            await cache.put(`key${i}`, { accountId: `value${i}`, partition: 'aws' });
        }
        // verify all values are on disk
        const otherCache = new account_cache_1.AccountAccessKeyCache(cacheFile);
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            expect(await otherCache.get(`key${i}`)).toEqual({ accountId: `value${i}`, partition: 'aws' });
        }
        // add another value
        await cache.put('nuke-me', { accountId: 'genesis', partition: 'aws' });
        // now, we expect only `nuke-me` to exist on disk
        expect(await otherCache.get('nuke-me')).toEqual({ accountId: 'genesis', partition: 'aws' });
        for (let i = 0; i < account_cache_1.AccountAccessKeyCache.MAX_ENTRIES; ++i) {
            expect(await otherCache.get(`key${i}`)).toBeUndefined();
        }
    }
    finally {
        await nukeCache(cacheDir);
    }
});
function withMocked(obj, key, block) {
    const original = obj[key];
    const mockFn = jest.fn();
    obj[key] = mockFn;
    let ret;
    try {
        ret = block(mockFn);
    }
    catch (e) {
        obj[key] = original;
        throw e;
    }
    if (!isPromise(ret)) {
        obj[key] = original;
        return ret;
    }
    return ret.finally(() => { obj[key] = original; });
}
function isPromise(object) {
    return Promise.resolve(object) === object;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC1jYWNoZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYWNjb3VudC1jYWNoZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixxRUFBMEU7QUFFMUUsS0FBSyxVQUFVLFNBQVM7SUFDdEIsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDeEQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDMUMsT0FBTztRQUNMLFFBQVEsRUFBRSxHQUFHO1FBQ2IsU0FBUyxFQUFFLElBQUk7UUFDZixLQUFLLEVBQUUsSUFBSSxxQ0FBcUIsQ0FBQyxJQUFJLENBQUM7S0FDdkMsQ0FBQztBQUNKLENBQUM7QUFFRCxLQUFLLFVBQVUsU0FBUyxDQUFDLFFBQWdCO0lBQ3ZDLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRUQsSUFBSSxDQUFDLHFDQUFxQyxFQUFFLEdBQUcsRUFBRTtJQUMvQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7SUFDakMsTUFBTSxLQUFLLEdBQUcsSUFBSSxxQ0FBcUIsRUFBRSxDQUFDO0lBQzFDLE1BQU0sQ0FBRSxLQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3pELENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLGdFQUFnRSxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ2hGLE1BQU0sV0FBVyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLFdBQW1CLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztJQUVyQyxPQUFPLFVBQVUsQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUss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RyxHQUFHLEtBQUssQ0FBQyxNQUFhLENBQUMsQ0FBQztLQUM1QjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUNwQixNQUFNLENBQUMsQ0FBQztLQUNUO0lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNuQixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDO1FBQ3BCLE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFFRCxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBUSxDQUFDO0FBQzVELENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBSSxNQUFXO0lBQy9CLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxNQUFNLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUgfSBmcm9tICcuLi9saWIvYXBpL2F3cy1hdXRoL2FjY291bnQtY2FjaGUnO1xuXG5hc3luYyBmdW5jdGlvbiBtYWtlQ2FjaGUoKSB7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLm1rZHRlbXAoJy90bXAvYWNjb3VudC1jYWNoZS10ZXN0Jyk7XG4gIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4oZGlyLCAnY2FjaGUuanNvbicpO1xuICByZXR1cm4ge1xuICAgIGNhY2hlRGlyOiBkaXIsXG4gICAgY2FjaGVGaWxlOiBmaWxlLFxuICAgIGNhY2hlOiBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKGZpbGUpLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBudWtlQ2FjaGUoY2FjaGVEaXI6IHN0cmluZykge1xuICBhd2FpdCBmcy5yZW1vdmUoY2FjaGVEaXIpO1xufVxuXG50ZXN0KCdkZWZhdWx0IGFjY291bnQgY2FjaGUgdXNlcyBDREtfSE9NRScsICgpID0+IHtcbiAgcHJvY2Vzcy5lbnYuQ0RLX0hPTUUgPSAnL2JhbmFuYSc7XG4gIGNvbnN0IGNhY2hlID0gbmV3IEFjY291bnRBY2Nlc3NLZXlDYWNoZSgpO1xuICBleHBlY3QoKGNhY2hlIGFzIGFueSkuY2FjaGVGaWxlKS50b0NvbnRhaW4oJy9iYW5hbmEvJyk7XG59KTtcblxudGVzdCgnYWNjb3VudCBjYWNoZSBkb2VzIG5vdCBmYWlsIHdoZW4gZ2l2ZW4gYSBub253cml0YWJsZSBkaXJlY3RvcnknLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFjY2Vzc0Vycm9yID0gbmV3IEVycm9yKCdPaCBubycpO1xuICAoYWNjZXNzRXJyb3IgYXMgYW55KS5jb2RlID0gJ0VBQ0NFUyc7XG5cbiAgcmV0dXJuIHdpdGhNb2NrZWQoZnMsICdta2RpcnMnLCBhc3luYyAobWtkaXJzKSA9PiB7XG4gICAgLy8gSGF2ZSB0byBkbyB0aGlzIGJlY2F1c2UgbWtkaXJzIGhhcyAyIG92ZXJsb2FkcyBhbmQgaXQgY29uZnVzZXMgVHlwZVNjcmlwdFxuICAgIChta2RpcnMgYXMgdW5rbm93biBhcyBqZXN0Lk1vY2s8UHJvbWlzZTx2b2lkPiwgW2FueV0+KS5tb2NrUmVqZWN0ZWRWYWx1ZShhY2Nlc3NFcnJvcik7XG5cbiAgICBjb25zdCBjYWNoZSA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoJy9hYmMveHl6Jyk7XG4gICAgYXdhaXQgY2FjaGUuZmV0Y2goJ3h5eicsICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGFjY291bnRJZDogJ2FzZGYnLCBwYXJ0aXRpb246ICdzd2EnIH0pKTtcblxuICAgIC8vIE5vIGV4Y2VwdGlvblxuICB9KTtcbn0pO1xuXG50ZXN0KCdnZXQoaykgd2hlbiBjYWNoZSBpcyBlbXB0eScsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBjYWNoZURpciwgY2FjaGVGaWxlLCBjYWNoZSB9ID0gYXdhaXQgbWFrZUNhY2hlKCk7XG4gIHRyeSB7XG4gICAgZXhwZWN0KGF3YWl0IGNhY2hlLmdldCgnZm9vJykpLnRvQmVVbmRlZmluZWQoKTtcbiAgICBleHBlY3QoYXdhaXQgZnMucGF0aEV4aXN0cyhjYWNoZUZpbGUpKS50b0JlRmFsc3koKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBudWtlQ2FjaGUoY2FjaGVEaXIpO1xuICB9XG59KTtcblxudGVzdCgncHV0KGssdikgYW5kIHRoZW4gZ2V0KGspJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGNhY2hlRGlyLCBjYWNoZUZpbGUsIGNhY2hlIH0gPSBhd2FpdCBtYWtlQ2FjaGUoKTtcblxuICB0cnkge1xuICAgIGF3YWl0IGNhY2hlLnB1dCgna2V5JywgeyBhY2NvdW50SWQ6ICd2YWx1ZScsIHBhcnRpdGlvbjogJ2F3cycgfSk7XG4gICAgYXdhaXQgY2FjaGUucHV0KCdib28nLCB7IGFjY291bnRJZDogJ2JhcicsIHBhcnRpdGlvbjogJ2F3cycgfSk7XG4gICAgZXhwZWN0KGF3YWl0IGNhY2hlLmdldCgna2V5JykpLnRvRXF1YWwoeyBhY2NvdW50SWQ6ICd2YWx1ZScsIHBhcnRpdGlvbjogJ2F3cycgfSk7XG5cbiAgICAvLyBjcmVhdGUgYW5vdGhlciBjYWNoZSBpbnN0YW5jZSBvbiB0aGUgc2FtZSBmaWxlLCBzaG91bGQgc3RpbGwgd29ya1xuICAgIGNvbnN0IGNhY2hlMiA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoY2FjaGVGaWxlKTtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUyLmdldCgnYm9vJykpLnRvRXF1YWwoeyBhY2NvdW50SWQ6ICdiYXInLCBwYXJ0aXRpb246ICdhd3MnIH0pO1xuXG4gICAgLy8gd2hpdGVib3g6IHJlYWQgdGhlIGZpbGVcbiAgICBleHBlY3QoYXdhaXQgZnMucmVhZEpzb24oY2FjaGVGaWxlKSkudG9FcXVhbCh7XG4gICAgICBrZXk6IHsgYWNjb3VudElkOiAndmFsdWUnLCBwYXJ0aXRpb246ICdhd3MnIH0sXG4gICAgICBib286IHsgYWNjb3VudElkOiAnYmFyJywgcGFydGl0aW9uOiAnYXdzJyB9LFxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IG51a2VDYWNoZShjYWNoZURpcik7XG4gIH1cbn0pO1xuXG50ZXN0KCdmZXRjaChrLCByZXNvbHZlcikgY2FuIGJlIHVzZWQgdG8gXCJhdG9taWNhbGx5XCIgZ2V0ICsgcmVzb2x2ZSArIHB1dCcsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBjYWNoZURpciwgY2FjaGUgfSA9IGF3YWl0IG1ha2VDYWNoZSgpO1xuXG4gIHRyeSB7XG4gICAgZXhwZWN0KGF3YWl0IGNhY2hlLmdldCgnZm9vJykpLnRvQmVVbmRlZmluZWQoKTtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUuZmV0Y2goJ2ZvbycsIGFzeW5jICgpID0+ICh7IGFjY291bnRJZDogJ2JhcicsIHBhcnRpdGlvbjogJ2F3cycgfSkpKS50b0VxdWFsKHsgYWNjb3VudElkOiAnYmFyJywgcGFydGl0aW9uOiAnYXdzJyB9KTtcbiAgICBleHBlY3QoYXdhaXQgY2FjaGUuZ2V0KCdmb28nKSkudG9FcXVhbCh7IGFjY291bnRJZDogJ2JhcicsIHBhcnRpdGlvbjogJ2F3cycgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgbnVrZUNhY2hlKGNhY2hlRGlyKTtcbiAgfVxufSk7XG5cbnRlc3QoYGNhY2hlIGlzIG51a2VkIGlmIGl0IGV4Y2VlZHMgJHtBY2NvdW50QWNjZXNzS2V5Q2FjaGUuTUFYX0VOVFJJRVN9IGVudHJpZXNgLCBhc3luYyAoKSA9PiB7XG4gIC8vIFRoaXMgbWFrZXMgYSBsb3Qgb2YgcHJvbWlzZXMsIHNvIGl0IGNhbiBxdWV1ZSBmb3IgYSB3aGlsZS4uLlxuICBqZXN0LnNldFRpbWVvdXQoMzBfMDAwKTtcblxuICBjb25zdCB7IGNhY2hlRGlyLCBjYWNoZUZpbGUsIGNhY2hlIH0gPSBhd2FpdCBtYWtlQ2FjaGUoKTtcblxuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTOyArK2kpIHtcbiAgICAgIGF3YWl0IGNhY2hlLnB1dChga2V5JHtpfWAsIHsgYWNjb3VudElkOiBgdmFsdWUke2l9YCwgcGFydGl0aW9uOiAnYXdzJyB9KTtcbiAgICB9XG5cbiAgICAvLyB2ZXJpZnkgYWxsIHZhbHVlcyBhcmUgb24gZGlza1xuICAgIGNvbnN0IG90aGVyQ2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKGNhY2hlRmlsZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBY2NvdW50QWNjZXNzS2V5Q2FjaGUuTUFYX0VOVFJJRVM7ICsraSkge1xuICAgICAgZXhwZWN0KGF3YWl0IG90aGVyQ2FjaGUuZ2V0KGBrZXkke2l9YCkpLnRvRXF1YWwoeyBhY2NvdW50SWQ6IGB2YWx1ZSR7aX1gLCBwYXJ0aXRpb246ICdhd3MnIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBhbm90aGVyIHZhbHVlXG4gICAgYXdhaXQgY2FjaGUucHV0KCdudWtlLW1lJywgeyBhY2NvdW50SWQ6ICdnZW5lc2lzJywgcGFydGl0aW9uOiAnYXdzJyB9KTtcblxuICAgIC8vIG5vdywgd2UgZXhwZWN0IG9ubHkgYG51a2UtbWVgIHRvIGV4aXN0IG9uIGRpc2tcbiAgICBleHBlY3QoYXdhaXQgb3RoZXJDYWNoZS5nZXQoJ251a2UtbWUnKSkudG9FcXVhbCh7IGFjY291bnRJZDogJ2dlbmVzaXMnLCBwYXJ0aXRpb246ICdhd3MnIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWNjb3VudEFjY2Vzc0tleUNhY2hlLk1BWF9FTlRSSUVTOyArK2kpIHtcbiAgICAgIGV4cGVjdChhd2FpdCBvdGhlckNhY2hlLmdldChga2V5JHtpfWApKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IG51a2VDYWNoZShjYWNoZURpcik7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3aXRoTW9ja2VkPEEgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBBLCBCPihvYmo6IEEsIGtleTogSywgYmxvY2s6IChmbjogamVzdC5Nb2NrZWQ8QT5bS10pID0+IEIpOiBCIHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBvYmpba2V5XTtcbiAgY29uc3QgbW9ja0ZuID0gamVzdC5mbigpO1xuICAob2JqIGFzIGFueSlba2V5XSA9IG1vY2tGbjtcblxuICBsZXQgcmV0O1xuICB0cnkge1xuICAgIHJldCA9IGJsb2NrKG1vY2tGbiBhcyBhbnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb2JqW2tleV0gPSBvcmlnaW5hbDtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgaWYgKCFpc1Byb21pc2UocmV0KSkge1xuICAgIG9ialtrZXldID0gb3JpZ2luYWw7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiByZXQuZmluYWxseSgoKSA9PiB7IG9ialtrZXldID0gb3JpZ2luYWw7IH0pIGFzIGFueTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlPEE+KG9iamVjdDogYW55KTogb2JqZWN0IGlzIFByb21pc2U8QT4ge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iamVjdCkgPT09IG9iamVjdDtcbn0iXX0=
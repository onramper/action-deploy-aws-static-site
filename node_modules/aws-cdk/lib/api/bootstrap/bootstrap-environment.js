"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const directories_1 = require("../../util/directories");
const aws_auth_1 = require("../aws-auth");
class Bootstrapper {
    constructor(source) {
        this.source = source;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${(0, serialize_1.serializeStructure)(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        if (params.trustedAccounts?.length) {
            throw new Error('--trust can only be passed for the modern bootstrap experience.');
        }
        if (params.cloudFormationExecutionPolicies?.length) {
            throw new Error('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new Error('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new Error('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        const params = options.parameters ?? {};
        const bootstrapTemplate = await this.loadTemplate();
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        const partition = await current.partition();
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new Error('You cannot pass \'--bootstrap-kms-key-id\' and \'--bootstrap-customer-key\' together. Specify one or the other');
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const trustedAccounts = params.trustedAccounts ?? splitCfnArray(current.parameters.TrustedAccounts);
        (0, console_1.info)(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = params.trustedAccountsForLookup ?? splitCfnArray(current.parameters.TrustedAccountsForLookup);
        (0, console_1.info)(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = params.cloudFormationExecutionPolicies ?? splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicitly policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${partition}:iam::aws:policy/AdministratorAccess`;
            (0, logging_1.warning)(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`);
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new Error(`Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:${partition}:iam::aws:policy/<PolicyName>\'.`);
        }
        else {
            // Remind people what the current settings are
            (0, console_1.info)(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = params.kmsKeyId ??
            (params.createCustomerMasterKey === true ? CREATE_NEW_KEY :
                params.createCustomerMasterKey === false || currentKmsKeyId === undefined ? USE_AWS_MANAGED_KEY : undefined);
        /* A permissions boundary can be provided via:
        *    - the flag indicating the example one should be used
        *    - the name indicating the custom permissions boundary to be used
        * Re-bootstrapping will NOT be blocked by either tightening or relaxing the permissions' boundary.
        */
        // InputPermissionsBoundary is an `any` type and if it is not defined it
        // appears as an empty string ''. We need to force it to evaluate an empty string
        // as undefined
        const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary || undefined;
        const inputPolicyName = params.examplePermissionsBoundary ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY : params.customPermissionsBoundary;
        let policyName;
        if (inputPolicyName) {
            // If the example policy is not already in place, it must be created.
            const sdk = (await sdkProvider.forEnvironment(environment, aws_auth_1.Mode.ForWriting)).sdk;
            policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition, params);
        }
        if (currentPermissionsBoundary !== policyName) {
            if (!currentPermissionsBoundary) {
                (0, logging_1.warning)(`Adding new permissions boundary ${policyName}`);
            }
            else if (!policyName) {
                (0, logging_1.warning)(`Removing existing permissions boundary ${currentPermissionsBoundary}`);
            }
            else {
                (0, logging_1.warning)(`Changing permissions boundary from ${currentPermissionsBoundary} to ${policyName}`);
            }
        }
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined ? 'true' : 'false',
            InputPermissionsBoundary: policyName,
        }, {
            ...options,
            terminationProtection: options.terminationProtection ?? current.terminationProtection,
        });
    }
    async getPolicyName(environment, sdk, permissionsBoundary, partition, params) {
        if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
            this.validatePolicyName(permissionsBoundary);
            return Promise.resolve(permissionsBoundary);
        }
        // if no Qualifier is supplied, resort to the default one
        const arn = await this.getExamplePermissionsBoundary(params.qualifier ?? 'hnb659fds', partition, environment.account, sdk);
        const policyName = arn.split('/').pop();
        if (!policyName) {
            throw new Error('Could not retrieve the example permission boundary!');
        }
        return Promise.resolve(policyName);
    }
    async getExamplePermissionsBoundary(qualifier, partition, account, sdk) {
        const iam = sdk.iam();
        let policyName = `cdk-${qualifier}-permissions-boundary`;
        const arn = `arn:${partition}:iam::${account}:policy/${policyName}`;
        try {
            let getPolicyResp = await iam.getPolicy({ PolicyArn: arn }).promise();
            if (getPolicyResp.Policy) {
                return arn;
            }
        }
        catch (e) {
            // https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetPolicy.html#API_GetPolicy_Errors
            if (e.name === 'NoSuchEntity') {
                //noop, proceed with creating the policy
            }
            else {
                throw e;
            }
        }
        const policyDoc = {
            Version: '2012-10-17',
            Statement: [
                {
                    Action: ['*'],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'ExplicitAllowAll',
                },
                {
                    Condition: {
                        StringEquals: {
                            'iam:PermissionsBoundary': `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                        },
                    },
                    Action: [
                        'iam:CreateUser',
                        'iam:CreateRole',
                        'iam:PutRolePermissionsBoundary',
                        'iam:PutUserPermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'DenyAccessIfRequiredPermBoundaryIsNotBeingApplied',
                },
                {
                    Action: [
                        'iam:CreatePolicyVersion',
                        'iam:DeletePolicy',
                        'iam:DeletePolicyVersion',
                        'iam:SetDefaultPolicyVersion',
                    ],
                    Resource: `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                    Effect: 'Deny',
                    Sid: 'DenyPermBoundaryIAMPolicyAlteration',
                },
                {
                    Action: [
                        'iam:DeleteUserPermissionsBoundary',
                        'iam:DeleteRolePermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Deny',
                    Sid: 'DenyRemovalOfPermBoundaryFromAnyUserOrRole',
                },
            ],
        };
        const request = {
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDoc),
        };
        const createPolicyResponse = await iam.createPolicy(request).promise();
        if (createPolicyResponse.Policy?.Arn) {
            return createPolicyResponse.Policy.Arn;
        }
        else {
            throw new Error(`Could not retrieve the example permission boundary ${arn}!`);
        }
    }
    validatePolicyName(permissionsBoundary) {
        // https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html
        // Added support for policy names with a path
        // See https://github.com/aws/aws-cdk/issues/26320
        const regexp = /[\w+\/=,.@-]+/;
        const matches = regexp.exec(permissionsBoundary);
        if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
            throw new Error(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
        }
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = (0, deploy_bootstrap_1.bootstrapVersionFromTemplate)(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return (0, serialize_1.loadStructuredFile)(this.source.templateFile);
            case 'default':
                return (0, serialize_1.loadStructuredFile)(path.join((0, directories_1.rootDir)(), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return (0, legacy_template_1.legacyBootstrapTemplate)(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default key
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Parameter value indicating the use of the default, CDK provided permissions boundary for bootstrap-template.yml
 */
const CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = 'CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFHN0IseURBQWtGO0FBQ2xGLHVEQUE0RDtBQUM1RCwyQ0FBd0M7QUFDeEMsK0NBQXlFO0FBQ3pFLHdEQUFpRDtBQUNqRCwwQ0FBc0Q7QUFVdEQsTUFBYSxZQUFZO0lBQ3ZCLFlBQTZCLE1BQXVCO1FBQXZCLFdBQU0sR0FBTixNQUFNLENBQWlCO0lBQ3BELENBQUM7SUFFTSxvQkFBb0IsQ0FBQyxXQUE4QixFQUFFLFdBQXdCLEVBQUUsVUFBdUMsRUFBRTtRQUM3SCxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQzFCLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2xFO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBYTtRQUNyQyxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMzQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUEsOEJBQWtCLEVBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLGVBQWUsQ0FBQyxXQUE4QixFQUFFLFdBQXdCLEVBQUUs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LEVBQUUsQ0FBQztBQUMxQjs7R0FFRztBQUNILE1BQU0sa0NBQWtDLEdBQUcsb0NBQW9DLENBQUM7QUFFaEY7Ozs7R0FJRztBQUNILFNBQVMsYUFBYSxDQUFDLEVBQXNCO0lBQzNDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssU0FBUyxFQUFFO1FBQUUsT0FBTyxFQUFFLENBQUM7S0FBRTtJQUNqRCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZm8gfSBmcm9tICdjb25zb2xlJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zLCBCb290c3RyYXBwaW5nUGFyYW1ldGVycyB9IGZyb20gJy4vYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IEJvb3RzdHJhcFN0YWNrLCBib290c3RyYXBWZXJzaW9uRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi9kZXBsb3ktYm9vdHN0cmFwJztcbmltcG9ydCB7IGxlZ2FjeUJvb3RzdHJhcFRlbXBsYXRlIH0gZnJvbSAnLi9sZWdhY3ktdGVtcGxhdGUnO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgbG9hZFN0cnVjdHVyZWRGaWxlLCBzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuLi8uLi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgcm9vdERpciB9IGZyb20gJy4uLy4uL3V0aWwvZGlyZWN0b3JpZXMnO1xuaW1wb3J0IHsgSVNESywgTW9kZSwgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveS1zdGFjayc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuZXhwb3J0IHR5cGUgQm9vdHN0cmFwU291cmNlID1cbiAgeyBzb3VyY2U6ICdsZWdhY3knIH1cbiAgfCB7IHNvdXJjZTogJ2RlZmF1bHQnIH1cbiAgfCB7IHNvdXJjZTogJ2N1c3RvbSc7IHRlbXBsYXRlRmlsZTogc3RyaW5nIH07XG5cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBwZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogQm9vdHN0cmFwU291cmNlKSB7XG4gIH1cblxuICBwdWJsaWMgYm9vdHN0cmFwRW52aXJvbm1lbnQoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICByZXR1cm4gdGhpcy5sZWdhY3lCb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaG93VGVtcGxhdGUoanNvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtzZXJpYWxpemVTdHJ1Y3R1cmUodGVtcGxhdGUsIGpzb24pfVxcbmApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBsZWdhY3kgYm9vdHN0cmFwIHN0YWNrXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbWV0ZXJzID8/IHt9O1xuXG4gICAgaWYgKHBhcmFtcy50cnVzdGVkQWNjb3VudHM/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCctLXRydXN0IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1ib290c3RyYXAtY3VzdG9tZXIta2V5IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5xdWFsaWZpZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS1xdWFsaWZpZXIgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBCb290c3RyYXBTdGFjay5sb29rdXAoc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBvcHRpb25zLnRvb2xraXRTdGFja05hbWUpO1xuICAgIHJldHVybiBjdXJyZW50LnVwZGF0ZShhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZShwYXJhbXMpLCB7fSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IENJL0NELXJlYWR5IGJvb3RzdHJhcCBzdGFjayBmcm9tIHRlbXBsYXRlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1vZGVybkJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuXG4gICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbWV0ZXJzID8/IHt9O1xuXG4gICAgY29uc3QgYm9vdHN0cmFwVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IEJvb3RzdHJhcFN0YWNrLmxvb2t1cChzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIG9wdGlvbnMudG9vbGtpdFN0YWNrTmFtZSk7XG4gICAgY29uc3QgcGFydGl0aW9uID0gYXdhaXQgY3VycmVudC5wYXJ0aXRpb24oKTtcblxuICAgIGlmIChwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMua21zS2V5SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBwYXNzIFxcJy0tYm9vdHN0cmFwLWttcy1rZXktaWRcXCcgYW5kIFxcJy0tYm9vdHN0cmFwLWN1c3RvbWVyLWtleVxcJyB0b2dldGhlci4gU3BlY2lmeSBvbmUgb3IgdGhlIG90aGVyJyk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGVvcGxlIHJlLWJvb3RzdHJhcCwgZXhpc3RpbmcgcGFyYW1ldGVyIHZhbHVlcyBhcmUgcmV1c2VkIHNvIHRoYXQgcGVvcGxlIGRvbid0IGFjY2lkZW50YWxseSBjaGFuZ2UgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBvbiB0aGVpciBib290c3RyYXAgc3RhY2sgKHRoaXMgaGFwcGVucyBhdXRvbWF0aWNhbGx5IGluIGRlcGxveVN0YWNrKS4gSG93ZXZlciwgdG8gZG8gcHJvcGVyIHZhbGlkYXRpb24gb24gdGhlXG4gICAgLy8gY29tYmluZWQgYXJndW1lbnRzIChzdWNoIHRoYXQgaWYgLS10cnVzdCBoYXMgYmVlbiBnaXZlbiwgLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMgaXMgbmVjZXNzYXJ5IGFzIHdlbGwpXG4gICAgLy8gd2UgbmVlZCB0byB0YWtlIHRoaXMgcGFyYW1ldGVyIHJldXNlIGludG8gYWNjb3VudC5cbiAgICAvL1xuICAgIC8vIElkZWFsbHkgd2UnZCBkbyB0aGlzIGluc2lkZSB0aGUgdGVtcGxhdGUsIGJ1dCB0aGUgYFJ1bGVzYCBzZWN0aW9uIG9mIENGTlxuICAgIC8vIHRlbXBsYXRlcyBkb2Vzbid0IHNlZW0gdG8gYmUgYWJsZSB0byBleHByZXNzIHRoZSBjb25kaXRpb25zIHRoYXQgd2UgbmVlZFxuICAgIC8vIChjYW4ndCB1c2UgRm46OkpvaW4gb3IgcmVmZXJlbmNlIENvbmRpdGlvbnMpIHNvIHdlIGRvIGl0IGhlcmUgaW5zdGVhZC5cbiAgICBjb25zdCB0cnVzdGVkQWNjb3VudHMgPSBwYXJhbXMudHJ1c3RlZEFjY291bnRzID8/IHNwbGl0Q2ZuQXJyYXkoY3VycmVudC5wYXJhbWV0ZXJzLlRydXN0ZWRBY2NvdW50cyk7XG4gICAgaW5mbyhgVHJ1c3RlZCBhY2NvdW50cyBmb3IgZGVwbG95bWVudDogJHt0cnVzdGVkQWNjb3VudHMubGVuZ3RoID4gMCA/IHRydXN0ZWRBY2NvdW50cy5qb2luKCcsICcpIDogJyhub25lKSd9YCk7XG5cbiAgICBjb25zdCB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAgPSBwYXJhbXMudHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID8/IHNwbGl0Q2ZuQXJyYXkoY3VycmVudC5wYXJhbWV0ZXJzLlRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCk7XG4gICAgaW5mbyhgVHJ1c3RlZCBhY2NvdW50cyBmb3IgbG9va3VwOiAke3RydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5sZW5ndGggPiAwID8gdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmpvaW4oJywgJykgOiAnKG5vbmUpJ31gKTtcblxuICAgIGNvbnN0IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPSBwYXJhbXMuY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5DbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzKTtcbiAgICBpZiAodHJ1c3RlZEFjY291bnRzLmxlbmd0aCA9PT0gMCAmJiBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIHNlbGYtdHJ1c3QgaXQncyBva2F5IHRvIGRlZmF1bHQgdG8gQWRtaW5pc3RyYXRvckFjY2VzcywgYW5kIGl0IGltcHJvdmVzIHRoZSB1c2FiaWxpdHkgb2YgYm9vdHN0cmFwcGluZyBhIGxvdC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBtYWtlIHRoZSBpbXBsaWNpdGx5IHBvbGljeSBhIHBoeXNpY2FsIHBhcmFtZXRlci4gVGhlIHRlbXBsYXRlIHdpbGwgaW5mZXIgaXQgaW5zdGVhZCxcbiAgICAgIC8vIHdlIHNpbXBseSBkbyB0aGUgVUkgYWR2ZXJ0aXNpbmcgdGhhdCBiZWhhdmlvciBoZXJlLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIERJRCBtYWtlIGl0IGFuIGV4cGxpY2l0IHBhcmFtZXRlciwgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2hldGhlclxuICAgICAgLy8gd2UgaW5mZXJyZWQgaXQgb3Igd2hldGhlciB0aGUgdXNlciB0b2xkIHVzLCBhbmQgdGhlIHNlcXVlbmNlOlxuICAgICAgLy9cbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcFxuICAgICAgLy8gJCBjZGsgYm9vdHN0cmFwIC0tdHJ1c3QgMTIzNFxuICAgICAgLy9cbiAgICAgIC8vIFdvdWxkIGxlYXZlIEFkbWluaXN0cmF0b3JBY2Nlc3MgcG9saWNpZXMgd2l0aCBhIHRydXN0IHJlbGF0aW9uc2hpcCwgd2l0aG91dCB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAvLyBhcHByb3ZpbmcgdGhlIHRydXN0IHBvbGljeS5cbiAgICAgIGNvbnN0IGltcGxpY2l0UG9saWN5ID0gYGFybjoke3BhcnRpdGlvbn06aWFtOjphd3M6cG9saWN5L0FkbWluaXN0cmF0b3JBY2Nlc3NgO1xuICAgICAgd2FybmluZyhgVXNpbmcgZGVmYXVsdCBleGVjdXRpb24gcG9saWN5IG9mICcke2ltcGxpY2l0UG9saWN5fScuIFBhc3MgJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzJyB0byBjdXN0b21pemUuYCk7XG4gICAgfSBlbHNlIGlmIChjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgcGFzcyBcXCctLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llc1xcJyB3aGVuIHVzaW5nIFxcJy0tdHJ1c3RcXCcgdG8gc3BlY2lmeSBkZXBsb3ltZW50IHBlcm1pc3Npb25zLiBUcnkgYSBtYW5hZ2VkIHBvbGljeSBvZiB0aGUgZm9ybSBcXCdhcm46JHtwYXJ0aXRpb259OmlhbTo6YXdzOnBvbGljeS88UG9saWN5TmFtZT5cXCcuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbWluZCBwZW9wbGUgd2hhdCB0aGUgY3VycmVudCBzZXR0aW5ncyBhcmVcbiAgICAgIGluZm8oYEV4ZWN1dGlvbiBwb2xpY2llczogJHtjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgLy8gKiBJZiBhbiBBUk4gaXMgZ2l2ZW4sIHRoYXQgQVJOLiBPdGhlcndpc2U6XG4gICAgLy8gICAqICctJyBpZiBjdXN0b21lcktleSA9IGZhbHNlXG4gICAgLy8gICAqICcnIGlmIGN1c3RvbWVyS2V5ID0gdHJ1ZVxuICAgIC8vICAgKiBpZiBjdXN0b21lcktleSBpcyBhbHNvIG5vdCBnaXZlblxuICAgIC8vICAgICAqIHVuZGVmaW5lZCBpZiB3ZSBhbHJlYWR5IGhhZCBhIHZhbHVlIGluIHBsYWNlIChyZXVzaW5nIHdoYXQgd2UgaGFkKVxuICAgIC8vICAgICAqICctJyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGRlcGxveWluZyB0aGlzIHN0YWNrIChvciB1cGdyYWRpbmcgZnJvbSBvbGQgdG8gbmV3IGJvb3RzdHJhcClcbiAgICBjb25zdCBjdXJyZW50S21zS2V5SWQgPSBjdXJyZW50LnBhcmFtZXRlcnMuRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkO1xuICAgIGNvbnN0IGttc0tleUlkID0gcGFyYW1zLmttc0tleUlkID8/XG4gICAgICAgIChwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgPT09IHRydWUgPyBDUkVBVEVfTkVXX0tFWSA6XG4gICAgICAgICAgcGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ID09PSBmYWxzZSB8fCBjdXJyZW50S21zS2V5SWQgPT09IHVuZGVmaW5lZCA/IFVTRV9BV1NfTUFOQUdFRF9LRVkgOiB1bmRlZmluZWQpO1xuXG4gICAgLyogQSBwZXJtaXNzaW9ucyBib3VuZGFyeSBjYW4gYmUgcHJvdmlkZWQgdmlhOlxuICAgICogICAgLSB0aGUgZmxhZyBpbmRpY2F0aW5nIHRoZSBleGFtcGxlIG9uZSBzaG91bGQgYmUgdXNlZFxuICAgICogICAgLSB0aGUgbmFtZSBpbmRpY2F0aW5nIHRoZSBjdXN0b20gcGVybWlzc2lvbnMgYm91bmRhcnkgdG8gYmUgdXNlZFxuICAgICogUmUtYm9vdHN0cmFwcGluZyB3aWxsIE5PVCBiZSBibG9ja2VkIGJ5IGVpdGhlciB0aWdodGVuaW5nIG9yIHJlbGF4aW5nIHRoZSBwZXJtaXNzaW9ucycgYm91bmRhcnkuXG4gICAgKi9cblxuICAgIC8vIElucHV0UGVybWlzc2lvbnNCb3VuZGFyeSBpcyBhbiBgYW55YCB0eXBlIGFuZCBpZiBpdCBpcyBub3QgZGVmaW5lZCBpdFxuICAgIC8vIGFwcGVhcnMgYXMgYW4gZW1wdHkgc3RyaW5nICcnLiBXZSBuZWVkIHRvIGZvcmNlIGl0IHRvIGV2YWx1YXRlIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIGFzIHVuZGVmaW5lZFxuICAgIGNvbnN0IGN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBjdXJyZW50LnBhcmFtZXRlcnMuSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5IHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpbnB1dFBvbGljeU5hbWUgPSBwYXJhbXMuZXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnkgPyBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZIDogcGFyYW1zLmN1c3RvbVBlcm1pc3Npb25zQm91bmRhcnk7XG4gICAgbGV0IHBvbGljeU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5wdXRQb2xpY3lOYW1lKSB7XG4gICAgICAvLyBJZiB0aGUgZXhhbXBsZSBwb2xpY3kgaXMgbm90IGFscmVhZHkgaW4gcGxhY2UsIGl0IG11c3QgYmUgY3JlYXRlZC5cbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgTW9kZS5Gb3JXcml0aW5nKSkuc2RrO1xuICAgICAgcG9saWN5TmFtZSA9IGF3YWl0IHRoaXMuZ2V0UG9saWN5TmFtZShlbnZpcm9ubWVudCwgc2RrLCBpbnB1dFBvbGljeU5hbWUsIHBhcnRpdGlvbiwgcGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBwb2xpY3lOYW1lKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5KSB7XG4gICAgICAgIHdhcm5pbmcoYEFkZGluZyBuZXcgcGVybWlzc2lvbnMgYm91bmRhcnkgJHtwb2xpY3lOYW1lfWApO1xuICAgICAgfSBlbHNlIGlmICghcG9saWN5TmFtZSkge1xuICAgICAgICB3YXJuaW5nKGBSZW1vdmluZyBleGlzdGluZyBwZXJtaXNzaW9ucyBib3VuZGFyeSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhgQ2hhbmdpbmcgcGVybWlzc2lvbnMgYm91bmRhcnkgZnJvbSAke2N1cnJlbnRQZXJtaXNzaW9uc0JvdW5kYXJ5fSB0byAke3BvbGljeU5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQudXBkYXRlKFxuICAgICAgYm9vdHN0cmFwVGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXROYW1lOiBwYXJhbXMuYnVja2V0TmFtZSxcbiAgICAgICAgRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkOiBrbXNLZXlJZCxcbiAgICAgICAgLy8gRW1wdHkgYXJyYXkgYmVjb21lcyBlbXB0eSBzdHJpbmdcbiAgICAgICAgVHJ1c3RlZEFjY291bnRzOiB0cnVzdGVkQWNjb3VudHMuam9pbignLCcpLFxuICAgICAgICBUcnVzdGVkQWNjb3VudHNGb3JMb29rdXA6IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsJyksXG4gICAgICAgIENsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM6IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCcpLFxuICAgICAgICBRdWFsaWZpZXI6IHBhcmFtcy5xdWFsaWZpZXIsXG4gICAgICAgIFB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbjogcGFyYW1zLnB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbiB8fCBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICBJbnB1dFBlcm1pc3Npb25zQm91bmRhcnk6IHBvbGljeU5hbWUsXG4gICAgICB9LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UG9saWN5TmFtZShcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrOiBJU0RLLFxuICAgIHBlcm1pc3Npb25zQm91bmRhcnk6IHN0cmluZyxcbiAgICBwYXJ0aXRpb246IHN0cmluZyxcbiAgICBwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzKTogUHJvbWlzZTxzdHJpbmc+IHtcblxuICAgIGlmIChwZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGVybWlzc2lvbnNCb3VuZGFyeSk7XG4gICAgfVxuICAgIC8vIGlmIG5vIFF1YWxpZmllciBpcyBzdXBwbGllZCwgcmVzb3J0IHRvIHRoZSBkZWZhdWx0IG9uZVxuICAgIGNvbnN0IGFybiA9IGF3YWl0IHRoaXMuZ2V0RXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnkocGFyYW1zLnF1YWxpZmllciA/PyAnaG5iNjU5ZmRzJywgcGFydGl0aW9uLCBlbnZpcm9ubWVudC5hY2NvdW50LCBzZGspO1xuICAgIGNvbnN0IHBvbGljeU5hbWUgPSBhcm4uc3BsaXQoJy8nKS5wb3AoKTtcbiAgICBpZiAoIXBvbGljeU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHRoZSBleGFtcGxlIHBlcm1pc3Npb24gYm91bmRhcnkhJyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocG9saWN5TmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldEV4YW1wbGVQZXJtaXNzaW9uc0JvdW5kYXJ5KHF1YWxpZmllcjogc3RyaW5nLCBwYXJ0aXRpb246IHN0cmluZywgYWNjb3VudDogc3RyaW5nLCBzZGs6IElTREspOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGlhbSA9IHNkay5pYW0oKTtcblxuICAgIGxldCBwb2xpY3lOYW1lID0gYGNkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgO1xuICAgIGNvbnN0IGFybiA9IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6JHthY2NvdW50fTpwb2xpY3kvJHtwb2xpY3lOYW1lfWA7XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGdldFBvbGljeVJlc3AgPSBhd2FpdCBpYW0uZ2V0UG9saWN5KHsgUG9saWN5QXJuOiBhcm4gfSkucHJvbWlzZSgpO1xuICAgICAgaWYgKGdldFBvbGljeVJlc3AuUG9saWN5KSB7XG4gICAgICAgIHJldHVybiBhcm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0dldFBvbGljeS5odG1sI0FQSV9HZXRQb2xpY3lfRXJyb3JzXG4gICAgICBpZiAoZS5uYW1lID09PSAnTm9TdWNoRW50aXR5Jykge1xuICAgICAgICAvL25vb3AsIHByb2NlZWQgd2l0aCBjcmVhdGluZyB0aGUgcG9saWN5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvbGljeURvYyA9IHtcbiAgICAgIFZlcnNpb246ICcyMDEyLTEwLTE3JyxcbiAgICAgIFN0YXRlbWVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgQWN0aW9uOiBbJyonXSxcbiAgICAgICAgICBSZXNvdXJjZTogJyonLFxuICAgICAgICAgIEVmZmVjdDogJ0FsbG93JyxcbiAgICAgICAgICBTaWQ6ICdFeHBsaWNpdEFsbG93QWxsJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIENvbmRpdGlvbjoge1xuICAgICAgICAgICAgU3RyaW5nRXF1YWxzOiB7XG4gICAgICAgICAgICAgICdpYW06UGVybWlzc2lvbnNCb3VuZGFyeSc6IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6JHthY2NvdW50fTpwb2xpY3kvY2RrLSR7cXVhbGlmaWVyfS1wZXJtaXNzaW9ucy1ib3VuZGFyeWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgQWN0aW9uOiBbXG4gICAgICAgICAgICAnaWFtOkNyZWF0ZVVzZXInLFxuICAgICAgICAgICAgJ2lhbTpDcmVhdGVSb2xlJyxcbiAgICAgICAgICAgICdpYW06UHV0Um9sZVBlcm1pc3Npb25zQm91bmRhcnknLFxuICAgICAgICAgICAgJ2lhbTpQdXRVc2VyUGVybWlzc2lvbnNCb3VuZGFyeScsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBSZXNvdXJjZTogJyonLFxuICAgICAgICAgIEVmZmVjdDogJ0FsbG93JyxcbiAgICAgICAgICBTaWQ6ICdEZW55QWNjZXNzSWZSZXF1aXJlZFBlcm1Cb3VuZGFyeUlzTm90QmVpbmdBcHBsaWVkJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIEFjdGlvbjogW1xuICAgICAgICAgICAgJ2lhbTpDcmVhdGVQb2xpY3lWZXJzaW9uJyxcbiAgICAgICAgICAgICdpYW06RGVsZXRlUG9saWN5JyxcbiAgICAgICAgICAgICdpYW06RGVsZXRlUG9saWN5VmVyc2lvbicsXG4gICAgICAgICAgICAnaWFtOlNldERlZmF1bHRQb2xpY3lWZXJzaW9uJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFJlc291cmNlOiBgYXJuOiR7cGFydGl0aW9ufTppYW06OiR7YWNjb3VudH06cG9saWN5L2Nkay0ke3F1YWxpZmllcn0tcGVybWlzc2lvbnMtYm91bmRhcnlgLFxuICAgICAgICAgIEVmZmVjdDogJ0RlbnknLFxuICAgICAgICAgIFNpZDogJ0RlbnlQZXJtQm91bmRhcnlJQU1Qb2xpY3lBbHRlcmF0aW9uJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIEFjdGlvbjogW1xuICAgICAgICAgICAgJ2lhbTpEZWxldGVVc2VyUGVybWlzc2lvbnNCb3VuZGFyeScsXG4gICAgICAgICAgICAnaWFtOkRlbGV0ZVJvbGVQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFJlc291cmNlOiAnKicsXG4gICAgICAgICAgRWZmZWN0OiAnRGVueScsXG4gICAgICAgICAgU2lkOiAnRGVueVJlbW92YWxPZlBlcm1Cb3VuZGFyeUZyb21BbnlVc2VyT3JSb2xlJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgUG9saWN5TmFtZTogcG9saWN5TmFtZSxcbiAgICAgIFBvbGljeURvY3VtZW50OiBKU09OLnN0cmluZ2lmeShwb2xpY3lEb2MpLFxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUG9saWN5UmVzcG9uc2UgPSBhd2FpdCBpYW0uY3JlYXRlUG9saWN5KHJlcXVlc3QpLnByb21pc2UoKTtcbiAgICBpZiAoY3JlYXRlUG9saWN5UmVzcG9uc2UuUG9saWN5Py5Bcm4pIHtcbiAgICAgIHJldHVybiBjcmVhdGVQb2xpY3lSZXNwb25zZS5Qb2xpY3kuQXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSB0aGUgZXhhbXBsZSBwZXJtaXNzaW9uIGJvdW5kYXJ5ICR7YXJufSFgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5OiBzdHJpbmcpIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vSUFNL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0NyZWF0ZVBvbGljeS5odG1sXG4gICAgLy8gQWRkZWQgc3VwcG9ydCBmb3IgcG9saWN5IG5hbWVzIHdpdGggYSBwYXRoXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvMjYzMjBcbiAgICBjb25zdCByZWdleHA6IFJlZ0V4cCA9IC9bXFx3K1xcLz0sLkAtXSsvO1xuICAgIGNvbnN0IG1hdGNoZXMgPSByZWdleHAuZXhlYyhwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICBpZiAoIShtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAxICYmIG1hdGNoZXNbMF0gPT09IHBlcm1pc3Npb25zQm91bmRhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwZXJtaXNzaW9ucyBib3VuZGFyeSBuYW1lICR7cGVybWlzc2lvbnNCb3VuZGFyeX0gZG9lcyBub3QgbWF0Y2ggdGhlIElBTSBjb252ZW50aW9ucy5gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGN1c3RvbUJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuXG4gICAgLy8gTG9vayBhdCB0aGUgdGVtcGxhdGUsIGRlY2lkZSB3aGV0aGVyIGl0J3MgbW9zdCBsaWtlbHkgYSBsZWdhY3kgb3IgbW9kZXJuIGJvb3RzdHJhcFxuICAgIC8vIHRlbXBsYXRlLCBhbmQgdXNlIHRoZSByaWdodCBib290c3RyYXBwZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgdmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUoYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKSk7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRUZW1wbGF0ZShwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHRoaXMuc291cmNlLnRlbXBsYXRlRmlsZSk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIGxvYWRTdHJ1Y3R1cmVkRmlsZShwYXRoLmpvaW4ocm9vdERpcigpLCAnbGliJywgJ2FwaScsICdib290c3RyYXAnLCAnYm9vdHN0cmFwLXRlbXBsYXRlLnlhbWwnKSk7XG4gICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICByZXR1cm4gbGVnYWN5Qm9vdHN0cmFwVGVtcGxhdGUocGFyYW1zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYWdpYyBwYXJhbWV0ZXIgdmFsdWUgdGhhdCB3aWxsIGNhdXNlIHRoZSBib290c3RyYXAtdGVtcGxhdGUueW1sIHRvIE5PVCBjcmVhdGUgYSBDTUsgYnV0IHVzZSB0aGUgZGVmYXVsdCBrZXlcbiAqL1xuY29uc3QgVVNFX0FXU19NQU5BR0VEX0tFWSA9ICdBV1NfTUFOQUdFRF9LRVknO1xuXG4vKipcbiAqIE1hZ2ljIHBhcmFtZXRlciB2YWx1ZSB0aGF0IHdpbGwgY2F1c2UgdGhlIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWwgdG8gY3JlYXRlIGEgQ01LXG4gKi9cbmNvbnN0IENSRUFURV9ORVdfS0VZID0gJyc7XG4vKipcbiAqIFBhcmFtZXRlciB2YWx1ZSBpbmRpY2F0aW5nIHRoZSB1c2Ugb2YgdGhlIGRlZmF1bHQsIENESyBwcm92aWRlZCBwZXJtaXNzaW9ucyBib3VuZGFyeSBmb3IgYm9vdHN0cmFwLXRlbXBsYXRlLnltbFxuICovXG5jb25zdCBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZID0gJ0NES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlknO1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5LWxpa2UgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVyIG9uICxcbiAqXG4gKiBBbiBlbXB0eSBzdHJpbmcgaXMgdGhlIGVtcHR5IGFycmF5IChpbnN0ZWFkIG9mIGBbJyddYCkuXG4gKi9cbmZ1bmN0aW9uIHNwbGl0Q2ZuQXJyYXkoeHM6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZ1tdIHtcbiAgaWYgKHhzID09PSAnJyB8fCB4cyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBbXTsgfVxuICByZXR1cm4geHMuc3BsaXQoJywnKTtcbn1cbiJdfQ==
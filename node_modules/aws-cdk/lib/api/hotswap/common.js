"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyPropertyUpdates = exports.evaluatableProperties = exports.reportNonHotswappableResource = exports.reportNonHotswappableChange = exports.classifyChanges = exports.ClassifiedChanges = exports.upperCaseFirstCharacter = exports.lowerCaseFirstCharacter = exports.transformObjectKeys = exports.HotswappableChangeCandidate = exports.HotswapMode = exports.ICON = void 0;
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(logicalId, oldValue, newValue, propertyUpdates) {
        this.logicalId = logicalId;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
exports.transformObjectKeys = transformObjectKeys;
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
/**
 * This function upper cases the first character of the string provided.
 */
function upperCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toUpperCase()}${str.slice(1)}` : str;
}
exports.upperCaseFirstCharacter = upperCaseFirstCharacter;
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange ? 'Tags are not hotswappable' : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
exports.classifyChanges = classifyChanges;
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps ?? change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
exports.reportNonHotswappableChange = reportNonHotswappableChange;
function reportNonHotswappableResource(change, reason) {
    return [{
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        }];
}
exports.reportNonHotswappableResource = reportNonHotswappableResource;
function detectChangedProps(next, prev) {
    const changedProps = [];
    changedProps.push(...detectAdditions(next, prev));
    changedProps.push(...detectRemovals(next, prev));
    return changedProps;
}
function detectAdditions(next, prev, keys = []) {
    // Compare each value of two objects, detect additions (added or modified properties)
    // If we encounter CFn intrinsic (key.startsWith('Fn::') || key == 'Ref'), stop recursion
    if (typeof next !== 'object') {
        if (next !== prev) {
            // there is an addition or change to the property
            return [{ key: new Array(...keys), type: 'added' }];
        }
        else {
            return [];
        }
    }
    if (typeof prev !== 'object') {
        // there is an addition or change to the property
        return [{ key: new Array(...keys), type: 'added' }];
    }
    // If the next is a CFn intrinsic, don't recurse further.
    const childKeys = Object.keys(next);
    if (childKeys.length === 1 && (childKeys[0].startsWith('Fn::') || childKeys[0] === 'Ref')) {
        if (!deepCompareObject(prev, next)) {
            // there is an addition or change to the property
            return [{ key: new Array(...keys), type: 'added' }];
        }
        else {
            return [];
        }
    }
    const changedProps = [];
    // compare children
    for (const key of childKeys) {
        keys.push(key);
        changedProps.push(...detectAdditions(next[key], prev[key], keys));
        keys.pop();
    }
    return changedProps;
}
function detectRemovals(next, prev, keys = []) {
    // Compare each value of two objects, detect removed properties
    // To do this, find any keys that exist only in prev object.
    // If we encounter CFn intrinsic (key.startsWith('Fn::') || key == 'Ref'), stop recursion
    if (next === undefined) {
        return [{ key: new Array(...keys), type: 'removed' }];
    }
    if (typeof prev !== 'object' || typeof next !== 'object') {
        // either prev or next is not an object nor undefined, then the property is not removed
        return [];
    }
    // If the prev is a CFn intrinsic, don't recurse further.
    const childKeys = Object.keys(prev);
    if (childKeys.length === 1 && (childKeys[0].startsWith('Fn::') || childKeys[0] === 'Ref')) {
        // next is not undefined here, so it is at least not removed
        return [];
    }
    const changedProps = [];
    // compare children
    for (const key of childKeys) {
        keys.push(key);
        changedProps.push(...detectRemovals(next[key], prev[key], keys));
        keys.pop();
    }
    return changedProps;
}
/**
 * return true when two objects are identical
 */
function deepCompareObject(lhs, rhs) {
    if (typeof lhs !== 'object') {
        return lhs === rhs;
    }
    if (typeof rhs !== 'object') {
        return false;
    }
    if (Object.keys(lhs).length != Object.keys(rhs).length) {
        return false;
    }
    for (const key of Object.keys(lhs)) {
        if (!deepCompareObject(lhs[key], rhs[key])) {
            return false;
        }
    }
    return true;
}
/**
 * Diff each property of the changes, and check if each diff can be actually hotswapped (i.e. evaluated by EvaluateCloudFormationTemplate.)
 * If any diff cannot be evaluated, they are reported by unevaluatableUpdates.
 * This method works on more granular level than HotswappableChangeCandidate.propertyUpdates.
 *
 * If propertiesToInclude is specified, we only compare properties that are under keys in the argument.
 */
async function evaluatableProperties(evaluate, change, propertiesToInclude) {
    const prev = change.oldValue.Properties;
    const next = change.newValue.Properties;
    const changedProps = detectChangedProps(next, prev).filter(prop => propertiesToInclude?.includes(prop.key[0]) ?? true);
    const evaluatedUpdates = await Promise.all(changedProps
        .filter((prop) => prop.type === 'added')
        .map(async (prop) => {
        const val = getPropertyFromKey(prop.key, next);
        try {
            const evaluated = await evaluate.evaluateCfnExpression(val);
            return {
                ...prop,
                value: evaluated,
            };
        }
        catch (e) {
            if (e instanceof evaluate_cloudformation_template_1.CfnEvaluationException) {
                return prop;
            }
            throw e;
        }
    }));
    const unevaluatableUpdates = evaluatedUpdates.filter(update => update.value === undefined);
    evaluatedUpdates.push(...changedProps.filter(prop => prop.type == 'removed'));
    return {
        updates: evaluatedUpdates,
        unevaluatableUpdates,
    };
}
exports.evaluatableProperties = evaluatableProperties;
function getPropertyFromKey(key, obj) {
    return key.reduce((prev, cur) => prev?.[cur], obj);
}
function overwriteProperty(key, newValue, target) {
    for (const next of key.slice(0, -1)) {
        if (next in target) {
            target = target[next];
        }
        else if (Array.isArray(target)) {
            // When an element is added to an array, we need explicitly allocate the new element.
            target = {};
            target[next] = {};
        }
        else {
            // This is an unexpected condition. Perhaps the deployed task definition is modified outside of CFn.
            return false;
        }
    }
    if (newValue === undefined) {
        delete target[key[key.length - 1]];
    }
    else {
        target[key[key.length - 1]] = newValue;
    }
    return true;
}
/**
 * Take the old template and property updates, and synthesize a new template.
 */
function applyPropertyUpdates(patches, target) {
    target = JSON.parse(JSON.stringify(target));
    for (const patch of patches) {
        const res = overwriteProperty(patch.key, patch.value, target);
        if (!res) {
            throw new Error(`failed to applying patch to ${patch.key.join('.')}. Please try deploying without hotswap first.`);
        }
    }
    return target;
}
exports.applyPropertyUpdates = applyPropertyUpdates;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLDBGQUE2RztBQUVoRyxRQUFBLElBQUksR0FBRyxHQUFHLENBQUM7QUE4Q3hCLElBQVksV0FlWDtBQWZELFdBQVksV0FBVztJQUNyQjs7T0FFRztJQUNILHNDQUF1QixDQUFBO0lBRXZCOztPQUVHO0lBQ0gsNENBQTZCLENBQUE7SUFFN0I7O09BRUc7SUFDSCxrREFBbUMsQ0FBQTtBQUNyQyxDQUFDLEVBZlcsV0FBVywyQkFBWCxXQUFXLFFBZXRCO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLDJCQUEyQjtJQXFCdEMsWUFBbUIsU0FBaUIsRUFBRSxRQUEyQixFQUFFLFFBQTJCLEVBQUUsZUFBMEI7UUFDeEgsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBM0JELGtFQTJCQztBQUlEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxHQUFRLEVBQUUsU0FBa0MsRUFBRSxVQUFtQixFQUFFO0lBQ3JHLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDMUMsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN0QiwyREFBMkQ7UUFDM0Qsc0ZBQXNGO1FBQ3RGLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ2hGO0lBQ0QsTUFBTSxH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RyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQztLQUNqRDtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQUMsT0FBdUIsRUFBRSxNQUFXO0lBQ3ZFLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM1QyxLQUFLLE1BQU0sS0FBSyxJQUFJLE9BQU8sRUFBRTtRQUMzQixNQUFNLEdBQUcsR0FBRyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO1NBQ3BIO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBVEQsb0RBU0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uLCBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5cbmV4cG9ydCBjb25zdCBJQ09OID0gJ+KcqCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcHBhYmxlQ2hhbmdlIHtcbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlOiB0cnVlO1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcHJvcHNDaGFuZ2VkOiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYmVpbmcgaG90c3dhcHBlZC5cbiAgICogVXNlZCB0byBzZXQgYSBjdXN0b20gVXNlci1BZ2VudCBmb3IgU0RLIGNhbGxzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgb2YgdGhlIHJlc291cmNlcyBiZWluZyBob3Rzd2FwcGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgYXBwbHk6IChzZGs6IElTREspID0+IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9uSG90c3dhcHBhYmxlQ2hhbmdlIHtcbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlOiBmYWxzZTtcbiAgcmVhZG9ubHkgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlamVjdGVkQ2hhbmdlczogQXJyYXk8c3RyaW5nPjtcbiAgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUZWxscyB0aGUgdXNlciBleGFjdGx5IHdoeSB0aGlzIGNoYW5nZSB3YXMgZGVlbWVkIG5vbi1ob3Rzd2FwcGFibGUgYW5kIHdoYXQgaXRzIGxvZ2ljYWwgSUQgaXMuXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIGByZWFzb25gIHdpbGwgYmUgYXV0b2ZpbGxlZCB0byBzdGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGxpc3RlZCBpbiBgcmVqZWN0ZWRDaGFuZ2VzYCBhcmUgbm90IGhvdHN3YXBwYWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IHJlYXNvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhpcyBjaGFuZ2Ugd2hlbiBsaXN0aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyBpbiBIT1RTV0FQX09OTFkgbW9kZS4gRG9lcyBub3QgYWZmZWN0XG4gICAqIGxpc3RpbmcgaW4gRkFMTF9CQUNLIG1vZGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIENoYW5nZUhvdHN3YXBSZXN1bHQgPSBBcnJheTxIb3Rzd2FwcGFibGVDaGFuZ2UgfCBOb25Ib3Rzd2FwcGFibGVDaGFuZ2U+O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXMge1xuICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwcGFibGVDaGFuZ2VbXTtcbiAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogTm9uSG90c3dhcHBhYmxlQ2hhbmdlW107XG59XG5cbmV4cG9ydCBlbnVtIEhvdHN3YXBNb2RlIHtcbiAgLyoqXG4gICAqIFdpbGwgZmFsbCBiYWNrIHRvIENsb3VkRm9ybWF0aW9uIHdoZW4gYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSBpcyBkZXRlY3RlZFxuICAgKi9cbiAgRkFMTF9CQUNLID0gJ2ZhbGwtYmFjaycsXG5cbiAgLyoqXG4gICAqIFdpbGwgbm90IGZhbGwgYmFjayB0byBDbG91ZEZvcm1hdGlvbiB3aGVuIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICovXG4gIEhPVFNXQVBfT05MWSA9ICdob3Rzd2FwLW9ubHknLFxuXG4gIC8qKlxuICAgKiBXaWxsIG5vdCBhdHRlbXB0IHRvIGhvdHN3YXAgYW55dGhpbmcgYW5kIGluc3RlYWQgZ28gc3RyYWlnaHQgdG8gQ2xvdWRGb3JtYXRpb25cbiAgICovXG4gIEZVTExfREVQTE9ZTUVOVCA9ICdmdWxsLWRlcGxveW1lbnQnLFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGFuZ2UgdGhhdCBjYW4gYmUgaG90c3dhcHBlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2Ugd2hpY2ggaXMgYmVpbmcgY2hhbmdlZFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgdGhlIHJlc291cmNlIGlzIGJlaW5nIHVwZGF0ZWQgZnJvbVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG9sZFZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZTtcblxuICAvKipcbiAgICogVGhlIHZhbHVlIHRoZSByZXNvdXJjZSBpcyBiZWluZyB1cGRhdGVkIHRvXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmV3VmFsdWU6IGNmbl9kaWZmLlJlc291cmNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2hhbmdlcyBtYWRlIHRvIHRoZSByZXNvdXJjZSBwcm9wZXJ0aWVzXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHlVcGRhdGVzOiBQcm9wRGlmZnM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGxvZ2ljYWxJZDogc3RyaW5nLCBvbGRWYWx1ZTogY2ZuX2RpZmYuUmVzb3VyY2UsIG5ld1ZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZSwgcHJvcGVydHlVcGRhdGVzOiBQcm9wRGlmZnMpIHtcbiAgICB0aGlzLmxvZ2ljYWxJZCA9IGxvZ2ljYWxJZDtcbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucHJvcGVydHlVcGRhdGVzID0gcHJvcGVydHlVcGRhdGVzO1xuICB9XG59XG5cbnR5cGUgRXhjbHVkZSA9IHsgW2tleTogc3RyaW5nXTogRXhjbHVkZSB8IHRydWUgfVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdHJhbnNmb3JtcyBhbGwga2V5cyAocmVjdXJzaXZlbHkpIGluIHRoZSBwcm92aWRlZCBgdmFsYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbCBUaGUgb2JqZWN0IHdob3NlIGtleXMgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB0cmFuc2Zvcm0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2gga2V5LlxuICogQHBhcmFtIGV4Y2x1ZGUgVGhlIGtleXMgdGhhdCB3aWxsIG5vdCBiZSB0cmFuc2Zvcm1lZCBhbmQgY29waWVkIHRvIG91dHB1dCBkaXJlY3RseVxuICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIGB2YWxgLCBidXQgd2l0aCBhbGwga2V5cyB0cmFuc2Zvcm1lZCBhY2NvcmRpbmcgdG8gYHRyYW5zZm9ybWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1PYmplY3RLZXlzKHZhbDogYW55LCB0cmFuc2Zvcm06IChzdHI6IHN0cmluZykgPT4gc3RyaW5nLCBleGNsdWRlOiBFeGNsdWRlID0ge30pOiBhbnkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAvLyBGb3IgYXJyYXlzIHdlIGp1c3QgcGFzcyBwYXJlbnQncyBleGNsdWRlIG9iamVjdCBkaXJlY3RseVxuICAgIC8vIHNpbmNlIGl0IG1ha2VzIG5vIHNlbnNlIHRvIHNwZWNpZnkgZGlmZmVyZW50IGV4Y2x1ZGUgb3B0aW9ucyBmb3IgZWFjaCBhcnJheSBlbGVtZW50XG4gICAgcmV0dXJuIHZhbC5tYXAoKGlucHV0OiBhbnkpID0+IHRyYW5zZm9ybU9iamVjdEtleXMoaW5wdXQsIHRyYW5zZm9ybSwgZXhjbHVkZSkpO1xuICB9XG4gIGNvbnN0IHJldDogeyBbazogc3RyaW5nXTogYW55OyB9ID0ge307XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICBjb25zdCBjaGlsZEV4Y2x1ZGUgPSBleGNsdWRlW2tdO1xuICAgIGlmIChjaGlsZEV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgIC8vIHdlIGRvbid0IHRyYW5zZm9ybSB0aGlzIG9iamVjdCBpZiB0aGUga2V5IGlzIHNwZWNpZmllZCBpbiBleGNsdWRlXG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFt0cmFuc2Zvcm0oayldID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh2LCB0cmFuc2Zvcm0sIGNoaWxkRXhjbHVkZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsb3dlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnNsaWNlKDEpfWAgOiBzdHI7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB1cHBlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b1VwcGVyQ2FzZSgpfSR7c3RyLnNsaWNlKDEpfWAgOiBzdHI7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BEaWZmcyA9IFJlY29yZDxzdHJpbmcsIGNmbl9kaWZmLlByb3BlcnR5RGlmZmVyZW5jZTxhbnk+PjtcblxuZXhwb3J0IGNsYXNzIENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbm9uSG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyxcbiAgKSB7IH1cblxuICBwdWJsaWMgcmVwb3J0Tm9uSG90c3dhcHBhYmxlUHJvcGVydHlDaGFuZ2VzKHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCk6dm9pZCB7XG4gICAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWdPbmx5Q2hhbmdlID0gbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzLmxlbmd0aCA9PT0gMSAmJiBub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXNbMF0gPT09ICdUYWdzJztcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShcbiAgICAgICAgcmV0LFxuICAgICAgICB0aGlzLmNoYW5nZSxcbiAgICAgICAgdGhpcy5ub25Ib3Rzd2FwcGFibGVQcm9wcyxcbiAgICAgICAgdGFnT25seUNoYW5nZSA/ICdUYWdzIGFyZSBub3QgaG90c3dhcHBhYmxlJyA6IGByZXNvdXJjZSBwcm9wZXJ0aWVzICcke25vbkhvdHN3YXBwYWJsZVByb3BOYW1lc30nIGFyZSBub3QgaG90c3dhcHBhYmxlIG9uIHRoaXMgcmVzb3VyY2UgdHlwZWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZXNPZkhvdHN3YXBwYWJsZVByb3BzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5Q2hhbmdlcyhcbiAgeHM6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgaG90c3dhcHBhYmxlUHJvcE5hbWVzOiBzdHJpbmdbXSxcbik6IENsYXNzaWZpZWRDaGFuZ2VzIHtcbiAgY29uc3QgaG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyA9IHt9O1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVQcm9wczogUHJvcERpZmZzID0ge307XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgcHJvcERpZmZdIG9mIE9iamVjdC5lbnRyaWVzKHhzLnByb3BlcnR5VXBkYXRlcykpIHtcbiAgICBpZiAoaG90c3dhcHBhYmxlUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICBob3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBub25Ib3Rzd2FwcGFibGVQcm9wc1tuYW1lXSA9IHByb3BEaWZmO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQ2xhc3NpZmllZENoYW5nZXMoeHMsIGhvdHN3YXBwYWJsZVByb3BzLCBub25Ib3Rzd2FwcGFibGVQcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gIHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIG5vbkhvdHN3YXBwYWJsZVByb3BzPzogUHJvcERpZmZzLFxuICByZWFzb24/OiBzdHJpbmcsXG4gIGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgbGV0IGhvdHN3YXBPbmx5VmlzaWJpbGl0eSA9IHRydWU7XG4gIGlmIChob3Rzd2FwT25seVZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgaG90c3dhcE9ubHlWaXNpYmlsaXR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0LnB1c2goe1xuICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhub25Ib3Rzd2FwcGFibGVQcm9wcyA/PyBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICBsb2dpY2FsSWQ6IGNoYW5nZS5sb2dpY2FsSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICByZWFzb24sXG4gICAgaG90c3dhcE9ubHlWaXNpYmxlOiBob3Rzd2FwT25seVZpc2liaWxpdHksXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICByZWFzb24/OiBzdHJpbmcsXG4pOiBDaGFuZ2VIb3Rzd2FwUmVzdWx0IHtcbiAgcmV0dXJuIFt7XG4gICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICByZWplY3RlZENoYW5nZXM6IE9iamVjdC5rZXlzKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpLFxuICAgIGxvZ2ljYWxJZDogY2hhbmdlLmxvZ2ljYWxJZCxcbiAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZS5UeXBlLFxuICAgIHJlYXNvbixcbiAgfV07XG59XG5cbnR5cGUgQ2hhbmdlZFByb3BzID0ge1xuICAvKipcbiAgICogQXJyYXkgdG8gc3BlY2lmeSB0aGUgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QuXG4gICAqIGUuZy4gR2l2ZW4gdGhpcyBvYmplY3QgYHsgJ2EnOiB7ICdiJzogMSB9IH1gLCB0aGUga2V5IGFycmF5IGZvciB0aGUgZWxlbWVudCBgMWAgd2lsbCBiZSBgWydhJywgJ2InXWBcbiAgICovXG4gIGtleTogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGFkZGVkIChhbHNvIG1vZGlmaWVkKSBvciByZW1vdmVkLlxuICAgKi9cbiAgdHlwZTogJ3JlbW92ZWQnIHwgJ2FkZGVkJztcblxuICAvKipcbiAgICogZXZhbHVhdGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogdW5kZWZpbmVkIGlmIHR5cGUgPT0gJ3JlbW92ZWQnXG4gICAqL1xuICB2YWx1ZT86IGFueVxufTtcblxuZnVuY3Rpb24gZGV0ZWN0Q2hhbmdlZFByb3BzKG5leHQ6IGFueSwgcHJldjogYW55KTogQ2hhbmdlZFByb3BzW10ge1xuICBjb25zdCBjaGFuZ2VkUHJvcHM6IENoYW5nZWRQcm9wc1tdID0gW107XG4gIGNoYW5nZWRQcm9wcy5wdXNoKC4uLmRldGVjdEFkZGl0aW9ucyhuZXh0LCBwcmV2KSk7XG4gIGNoYW5nZWRQcm9wcy5wdXNoKC4uLmRldGVjdFJlbW92YWxzKG5leHQsIHByZXYpKTtcbiAgcmV0dXJuIGNoYW5nZWRQcm9wcztcbn1cblxuZnVuY3Rpb24gZGV0ZWN0QWRkaXRpb25zKG5leHQ6IGFueSwgcHJldjogYW55LCBrZXlzOiBzdHJpbmdbXSA9IFtdKTogQ2hhbmdlZFByb3BzW10ge1xuICAvLyBDb21wYXJlIGVhY2ggdmFsdWUgb2YgdHdvIG9iamVjdHMsIGRldGVjdCBhZGRpdGlvbnMgKGFkZGVkIG9yIG1vZGlmaWVkIHByb3BlcnRpZXMpXG4gIC8vIElmIHdlIGVuY291bnRlciBDRm4gaW50cmluc2ljIChrZXkuc3RhcnRzV2l0aCgnRm46OicpIHx8IGtleSA9PSAnUmVmJyksIHN0b3AgcmVjdXJzaW9uXG5cbiAgaWYgKHR5cGVvZiBuZXh0ICE9PSAnb2JqZWN0Jykge1xuICAgIGlmIChuZXh0ICE9PSBwcmV2KSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbiBhZGRpdGlvbiBvciBjaGFuZ2UgdG8gdGhlIHByb3BlcnR5XG4gICAgICByZXR1cm4gW3sga2V5OiBuZXcgQXJyYXkoLi4ua2V5cyksIHR5cGU6ICdhZGRlZCcgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHByZXYgIT09ICdvYmplY3QnKSB7XG4gICAgLy8gdGhlcmUgaXMgYW4gYWRkaXRpb24gb3IgY2hhbmdlIHRvIHRoZSBwcm9wZXJ0eVxuICAgIHJldHVybiBbeyBrZXk6IG5ldyBBcnJheSguLi5rZXlzKSwgdHlwZTogJ2FkZGVkJyB9XTtcbiAgfVxuXG4gIC8vIElmIHRoZSBuZXh0IGlzIGEgQ0ZuIGludHJpbnNpYywgZG9uJ3QgcmVjdXJzZSBmdXJ0aGVyLlxuICBjb25zdCBjaGlsZEtleXMgPSBPYmplY3Qua2V5cyhuZXh0KTtcbiAgaWYgKGNoaWxkS2V5cy5sZW5ndGggPT09IDEgJiYgKGNoaWxkS2V5c1swXS5zdGFydHNXaXRoKCdGbjo6JykgfHwgY2hpbGRLZXlzWzBdID09PSAnUmVmJykpIHtcbiAgICBpZiAoIWRlZXBDb21wYXJlT2JqZWN0KHByZXYsIG5leHQpKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbiBhZGRpdGlvbiBvciBjaGFuZ2UgdG8gdGhlIHByb3BlcnR5XG4gICAgICByZXR1cm4gW3sga2V5OiBuZXcgQXJyYXkoLi4ua2V5cyksIHR5cGU6ICdhZGRlZCcgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGFuZ2VkUHJvcHM6IENoYW5nZWRQcm9wc1tdID0gW107XG4gIC8vIGNvbXBhcmUgY2hpbGRyZW5cbiAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRLZXlzKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgY2hhbmdlZFByb3BzLnB1c2goLi4uZGV0ZWN0QWRkaXRpb25zKChuZXh0IGFzIGFueSlba2V5XSwgKHByZXYgYXMgYW55KVtrZXldLCBrZXlzKSk7XG4gICAga2V5cy5wb3AoKTtcbiAgfVxuICByZXR1cm4gY2hhbmdlZFByb3BzO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RSZW1vdmFscyhuZXh0OiBhbnksIHByZXY6IGFueSwga2V5czogc3RyaW5nW10gPSBbXSk6IENoYW5nZWRQcm9wc1tdIHtcbiAgLy8gQ29tcGFyZSBlYWNoIHZhbHVlIG9mIHR3byBvYmplY3RzLCBkZXRlY3QgcmVtb3ZlZCBwcm9wZXJ0aWVzXG4gIC8vIFRvIGRvIHRoaXMsIGZpbmQgYW55IGtleXMgdGhhdCBleGlzdCBvbmx5IGluIHByZXYgb2JqZWN0LlxuICAvLyBJZiB3ZSBlbmNvdW50ZXIgQ0ZuIGludHJpbnNpYyAoa2V5LnN0YXJ0c1dpdGgoJ0ZuOjonKSB8fCBrZXkgPT0gJ1JlZicpLCBzdG9wIHJlY3Vyc2lvblxuICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7IGtleTogbmV3IEFycmF5KC4uLmtleXMpLCB0eXBlOiAncmVtb3ZlZCcgfV07XG4gIH1cblxuICBpZiAodHlwZW9mIHByZXYgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXh0ICE9PSAnb2JqZWN0Jykge1xuICAgIC8vIGVpdGhlciBwcmV2IG9yIG5leHQgaXMgbm90IGFuIG9iamVjdCBub3IgdW5kZWZpbmVkLCB0aGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgcmVtb3ZlZFxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwcmV2IGlzIGEgQ0ZuIGludHJpbnNpYywgZG9uJ3QgcmVjdXJzZSBmdXJ0aGVyLlxuICBjb25zdCBjaGlsZEtleXMgPSBPYmplY3Qua2V5cyhwcmV2KTtcbiAgaWYgKGNoaWxkS2V5cy5sZW5ndGggPT09IDEgJiYgKGNoaWxkS2V5c1swXS5zdGFydHNXaXRoKCdGbjo6JykgfHwgY2hpbGRLZXlzWzBdID09PSAnUmVmJykpIHtcbiAgICAvLyBuZXh0IGlzIG5vdCB1bmRlZmluZWQgaGVyZSwgc28gaXQgaXMgYXQgbGVhc3Qgbm90IHJlbW92ZWRcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjaGFuZ2VkUHJvcHM6IENoYW5nZWRQcm9wc1tdID0gW107XG4gIC8vIGNvbXBhcmUgY2hpbGRyZW5cbiAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRLZXlzKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgY2hhbmdlZFByb3BzLnB1c2goLi4uZGV0ZWN0UmVtb3ZhbHMoKG5leHQgYXMgYW55KVtrZXldLCAocHJldiBhcyBhbnkpW2tleV0sIGtleXMpKTtcbiAgICBrZXlzLnBvcCgpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VkUHJvcHM7XG59XG5cbi8qKlxuICogcmV0dXJuIHRydWUgd2hlbiB0d28gb2JqZWN0cyBhcmUgaWRlbnRpY2FsXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb21wYXJlT2JqZWN0KGxoczogYW55LCByaHM6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIGxocyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbGhzID09PSByaHM7XG4gIH1cbiAgaWYgKHR5cGVvZiByaHMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhsaHMpLmxlbmd0aCAhPSBPYmplY3Qua2V5cyhyaHMpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhsaHMpKSB7XG4gICAgaWYgKCFkZWVwQ29tcGFyZU9iamVjdCgobGhzIGFzIGFueSlba2V5XSwgKHJocyBhcyBhbnkpW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5pbnRlcmZhY2UgRXZhbHVhdGVkUHJvcGVydHlVcGRhdGVzIHtcbiAgcmVhZG9ubHkgdXBkYXRlczogQ2hhbmdlZFByb3BzW107XG4gIHJlYWRvbmx5IHVuZXZhbHVhdGFibGVVcGRhdGVzOiBDaGFuZ2VkUHJvcHNbXTtcbn1cblxuLyoqXG4gKiBEaWZmIGVhY2ggcHJvcGVydHkgb2YgdGhlIGNoYW5nZXMsIGFuZCBjaGVjayBpZiBlYWNoIGRpZmYgY2FuIGJlIGFjdHVhbGx5IGhvdHN3YXBwZWQgKGkuZS4gZXZhbHVhdGVkIGJ5IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZS4pXG4gKiBJZiBhbnkgZGlmZiBjYW5ub3QgYmUgZXZhbHVhdGVkLCB0aGV5IGFyZSByZXBvcnRlZCBieSB1bmV2YWx1YXRhYmxlVXBkYXRlcy5cbiAqIFRoaXMgbWV0aG9kIHdvcmtzIG9uIG1vcmUgZ3JhbnVsYXIgbGV2ZWwgdGhhbiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUucHJvcGVydHlVcGRhdGVzLlxuICpcbiAqIElmIHByb3BlcnRpZXNUb0luY2x1ZGUgaXMgc3BlY2lmaWVkLCB3ZSBvbmx5IGNvbXBhcmUgcHJvcGVydGllcyB0aGF0IGFyZSB1bmRlciBrZXlzIGluIHRoZSBhcmd1bWVudC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRhYmxlUHJvcGVydGllcyhcbiAgZXZhbHVhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIHByb3BlcnRpZXNUb0luY2x1ZGU/OiBzdHJpbmdbXSxcbik6IFByb21pc2U8RXZhbHVhdGVkUHJvcGVydHlVcGRhdGVzPiB7XG4gIGNvbnN0IHByZXYgPSBjaGFuZ2Uub2xkVmFsdWUuUHJvcGVydGllcyE7XG4gIGNvbnN0IG5leHQgPSBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcyE7XG4gIGNvbnN0IGNoYW5nZWRQcm9wcyA9IGRldGVjdENoYW5nZWRQcm9wcyhuZXh0LCBwcmV2KS5maWx0ZXIoXG4gICAgcHJvcCA9PiBwcm9wZXJ0aWVzVG9JbmNsdWRlPy5pbmNsdWRlcyhwcm9wLmtleVswXSkgPz8gdHJ1ZSxcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVkVXBkYXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNoYW5nZWRQcm9wc1xuICAgICAgLmZpbHRlcigocHJvcCkgPT4gcHJvcC50eXBlID09PSAnYWRkZWQnKVxuICAgICAgLm1hcChhc3luYyAocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRQcm9wZXJ0eUZyb21LZXkocHJvcC5rZXksIG5leHQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZCA9IGF3YWl0IGV2YWx1YXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih2YWwpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wcm9wLFxuICAgICAgICAgICAgdmFsdWU6IGV2YWx1YXRlZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICBjb25zdCB1bmV2YWx1YXRhYmxlVXBkYXRlcyA9IGV2YWx1YXRlZFVwZGF0ZXMuZmlsdGVyKHVwZGF0ZSA9PiB1cGRhdGUudmFsdWUgPT09IHVuZGVmaW5lZCk7XG4gIGV2YWx1YXRlZFVwZGF0ZXMucHVzaCguLi5jaGFuZ2VkUHJvcHMuZmlsdGVyKHByb3AgPT4gcHJvcC50eXBlID09ICdyZW1vdmVkJykpO1xuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlczogZXZhbHVhdGVkVXBkYXRlcyxcbiAgICB1bmV2YWx1YXRhYmxlVXBkYXRlcyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlGcm9tS2V5KGtleTogc3RyaW5nW10sIG9iajogb2JqZWN0KSB7XG4gIHJldHVybiBrZXkucmVkdWNlKChwcmV2LCBjdXIpID0+IChwcmV2IGFzIGFueSk/LltjdXJdLCBvYmopO1xufVxuXG5mdW5jdGlvbiBvdmVyd3JpdGVQcm9wZXJ0eShrZXk6IHN0cmluZ1tdLCBuZXdWYWx1ZTogYW55LCB0YXJnZXQ6IG9iamVjdCkge1xuICBmb3IgKGNvbnN0IG5leHQgb2Yga2V5LnNsaWNlKDAsIC0xKSkge1xuICAgIGlmIChuZXh0IGluIHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gKHRhcmdldCBhcyBhbnkpW25leHRdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAvLyBXaGVuIGFuIGVsZW1lbnQgaXMgYWRkZWQgdG8gYW4gYXJyYXksIHdlIG5lZWQgZXhwbGljaXRseSBhbGxvY2F0ZSB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICh0YXJnZXQgYXMgYW55KVtuZXh0XSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uLiBQZXJoYXBzIHRoZSBkZXBsb3llZCB0YXNrIGRlZmluaXRpb24gaXMgbW9kaWZpZWQgb3V0c2lkZSBvZiBDRm4uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlICh0YXJnZXQgYXMgYW55KVtrZXlba2V5Lmxlbmd0aCAtIDFdXTtcbiAgfSBlbHNlIHtcbiAgICAodGFyZ2V0IGFzIGFueSlba2V5W2tleS5sZW5ndGggLSAxXV0gPSBuZXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUYWtlIHRoZSBvbGQgdGVtcGxhdGUgYW5kIHByb3BlcnR5IHVwZGF0ZXMsIGFuZCBzeW50aGVzaXplIGEgbmV3IHRlbXBsYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVVwZGF0ZXMocGF0Y2hlczogQ2hhbmdlZFByb3BzW10sIHRhcmdldDogYW55KSB7XG4gIHRhcmdldCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGFyZ2V0KSk7XG4gIGZvciAoY29uc3QgcGF0Y2ggb2YgcGF0Y2hlcykge1xuICAgIGNvbnN0IHJlcyA9IG92ZXJ3cml0ZVByb3BlcnR5KHBhdGNoLmtleSwgcGF0Y2gudmFsdWUsIHRhcmdldCk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGFwcGx5aW5nIHBhdGNoIHRvICR7cGF0Y2gua2V5LmpvaW4oJy4nKX0uIFBsZWFzZSB0cnkgZGVwbG95aW5nIHdpdGhvdXQgaG90c3dhcCBmaXJzdC5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbiJdfQ==
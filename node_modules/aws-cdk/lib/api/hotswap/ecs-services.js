"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const propertiesToHotswap = ['ContainerDefinitions'];
    const classifiedChanges = (0, common_1.classifyChanges)(change, propertiesToHotswap);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter(r => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const familyName = await getFamilyName(evaluateCfnTemplate, logicalId, change);
        if (familyName === undefined) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'Failed to determine family name of the task definition', false);
            return ret;
        }
        const oldTaskDefinitionArn = await evaluateCfnTemplate.findPhysicalNameFor(logicalId);
        if (oldTaskDefinitionArn === undefined) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'Failed to determine ARN of the task definition', false);
            return ret;
        }
        const changes = await (0, common_1.evaluatableProperties)(evaluateCfnTemplate, change, propertiesToHotswap);
        if (changes.unevaluatableUpdates.length > 0) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `Found changes that cannot be evaluated locally in the task definition - ${changes.unevaluatableUpdates.map(p => p.key.join('.')).join(', ')}`, false);
            return ret;
        }
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${familyName}'`,
                ...ecsServicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // get the task definition of the family and revision corresponding to the old CFn template
                const target = await sdk
                    .ecs()
                    .describeTaskDefinition({
                    taskDefinition: oldTaskDefinitionArn,
                    include: ['TAGS'],
                })
                    .promise();
                if (target.taskDefinition === undefined) {
                    throw new Error(`Could not find a task definition: ${oldTaskDefinitionArn}. Try deploying without hotswap first.`);
                }
                // The describeTaskDefinition response contains several keys that must not exist in a registerTaskDefinition request.
                // We remove these keys here, comparing these two structs:
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTaskDefinition.html#API_DescribeTaskDefinition_ResponseSyntax
                [
                    'compatibilities',
                    'taskDefinitionArn',
                    'revision',
                    'status',
                    'requiresAttributes',
                    'compatibilities',
                    'registeredAt',
                    'registeredBy',
                ].forEach(key => delete target.taskDefinition[key]);
                // the tags field is in a different location in describeTaskDefinition response,
                // moving it as intended for registerTaskDefinition request.
                if (target.tags !== undefined && target.tags.length > 0) {
                    target.taskDefinition.tags = target.tags;
                    delete target.tags;
                }
                // Don't transform the properties that take arbitrary string as keys i.e. { "string" : "string" }
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                const excludeFromTransform = {
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                };
                const excludeFromTransformLowercased = (0, common_1.transformObjectKeys)(excludeFromTransform, common_1.lowerCaseFirstCharacter);
                // We first uppercase the task definition to properly merge it with the one from CloudFormation template.
                const upperCasedTaskDef = (0, common_1.transformObjectKeys)(target.taskDefinition, common_1.upperCaseFirstCharacter, excludeFromTransformLowercased);
                // merge evaluatable diff from CloudFormation template.
                const updatedTaskDef = (0, common_1.applyPropertyUpdates)(changes.updates, upperCasedTaskDef);
                // lowercase the merged task definition to use it in AWS SDK.
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(updatedTaskDef, common_1.lowerCaseFirstCharacter, excludeFromTransform);
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                const servicePerClusterUpdates = {};
                for (const ecsService of ecsServicesReferencingTaskDef) {
                    const clusterName = ecsService.serviceArn.split('/')[1];
                    const existingClusterPromises = servicePerClusterUpdates[clusterName];
                    let clusterPromises;
                    if (existingClusterPromises) {
                        clusterPromises = existingClusterPromises;
                    }
                    else {
                        clusterPromises = [];
                        servicePerClusterUpdates[clusterName] = clusterPromises;
                    }
                    // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                    // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount.
                    clusterPromises.push({
                        promise: sdk.ecs().updateService({
                            service: ecsService.serviceArn,
                            taskDefinition: taskDefRevArn,
                            cluster: clusterName,
                            forceNewDeployment: true,
                            deploymentConfiguration: {
                                minimumHealthyPercent: 0,
                            },
                        }).promise(),
                        ecsService: ecsService,
                    });
                }
                await Promise.all(Object.values(servicePerClusterUpdates)
                    .map(clusterUpdates => {
                    return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
                }));
                // Step 3 - wait for the service deployments triggered in Step 2 to finish
                // configure a custom Waiter
                sdk.ecs().api.waiters.deploymentToFinish = {
                    name: 'DeploymentToFinish',
                    operation: 'describeServices',
                    delay: 10,
                    maxAttempts: 60,
                    acceptors: [
                        {
                            matcher: 'pathAny',
                            argument: 'failures[].reason',
                            expected: 'MISSING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'DRAINING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'INACTIVE',
                            state: 'failure',
                        },
                        {
                            matcher: 'path',
                            argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                            expected: true,
                            state: 'success',
                        },
                    ],
                };
                // create a custom Waiter that uses the deploymentToFinish configuration added above
                const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
                // wait for all of the waiters to finish
                await Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
                    return deploymentWaiter.wait({
                        cluster: clusterName,
                        services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
                    }).promise();
                }));
            },
        });
    }
    return ret;
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
async function getFamilyName(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return family;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixxQ0FBOE87QUFJdk8sS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLEdBQUcsR0FBd0IsRUFBRSxDQUFDO0lBRXBDLHFGQUFxRjtJQUNyRixxRkFBcUY7SUFDckYsdURBQXVEO0lBQ3ZELE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3JELE1BQU0saUJBQWlCLEdBQUcsSUFBQSx3QkFBZSxFQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3ZFLGlCQUFpQixDQUFDLG9DQUFvQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVELHVFQUF1RTtJQUN2RSxNQUFNLDJCQUEyQixHQUFHLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0scUNBQXFDLEdBQUcsMkJBQTJCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3RILE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxLQUFLLEVBQWMsQ0FBQztJQUM5RCxLQUFLLE1BQU0sa0JBQWtCLElBQUkscUNBQXFDLEVBQUU7UUFDdEUsTUFBTSxVQUFVLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvRixJQUFJLFVBQVUsRUFBRTtZQUNkLDZCQUE2QixDQUFDLElBQUksQ0FBQyxFQUFF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QUNiLENBQUM7QUE5TkQsd0VBOE5DO0FBTUQsS0FBSyxVQUFVLGFBQWEsQ0FDMUIsbUJBQW1ELEVBQ25ELFNBQWlCLEVBQ2pCLE1BQW1DO0lBQ25DLE1BQU0sc0JBQXNCLEdBQTRCO1FBQ3RELEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVO1FBQzdCLG9CQUFvQixFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLG9CQUFvQjtLQUN2RSxDQUFDO0lBQ0EsMENBQTBDO0lBQzVDLE1BQU0sZUFBZSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsNkJBQTZCLENBQUMsU0FBUyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzNILElBQUksQ0FBQyxlQUFlLEVBQUU7UUFDcEIsMkZBQTJGO1FBQzNGLHlDQUF5QztRQUN6QyxPQUFPO0tBQ1I7SUFDRCw4R0FBOEc7SUFDOUcsc0JBQXNCO0lBQ3RCLE1BQU0sb0JBQW9CLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4RCxNQUFNLE1BQU0sR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUM5Qyw2SEFBNkg7UUFDN0gsNERBQTREO1FBQzFELENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLGdHQUFnRztRQUM5RixDQUFDLENBQUMsZUFBZSxDQUFDO0lBQ2xCLDhGQUE4RjtJQUVoRyxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcFJlc3VsdCwgY2xhc3NpZnlDaGFuZ2VzLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLCByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UsIHRyYW5zZm9ybU9iamVjdEtleXMsIHVwcGVyQ2FzZUZpcnN0Q2hhcmFjdGVyLCBhcHBseVByb3BlcnR5VXBkYXRlcywgZXZhbHVhdGFibGVQcm9wZXJ0aWVzIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gdGhlIG9ubHkgcmVzb3VyY2UgY2hhbmdlIHdlIGNhbiBldmFsdWF0ZSBoZXJlIGlzIGFuIEVDUyBUYXNrRGVmaW5pdGlvblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gW107XG5cbiAgLy8gV2Ugb25seSBhbGxvdyBhIGNoYW5nZSBpbiB0aGUgQ29udGFpbmVyRGVmaW5pdGlvbnMgb2YgdGhlIFRhc2tEZWZpbml0aW9uIGZvciBub3cgLVxuICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgY29uc3QgcHJvcGVydGllc1RvSG90c3dhcCA9IFsnQ29udGFpbmVyRGVmaW5pdGlvbnMnXTtcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBwcm9wZXJ0aWVzVG9Ib3Rzd2FwKTtcbiAgY2xhc3NpZmllZENoYW5nZXMucmVwb3J0Tm9uSG90c3dhcHBhYmxlUHJvcGVydHlDaGFuZ2VzKHJldCk7XG5cbiAgLy8gZmluZCBhbGwgRUNTIFNlcnZpY2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBUYXNrRGVmaW5pdGlvbiB0aGF0IGNoYW5nZWRcbiAgY29uc3QgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZCk7XG4gIGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlID09PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goeyBzZXJ2aWNlQXJuIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHJlc291cmNlcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgJ05vIEVDUyBzZXJ2aWNlcyByZWZlcmVuY2UgdGhlIGNoYW5nZWQgdGFzayBkZWZpbml0aW9uJywgZmFsc2UpO1xuICB9XG4gIGlmIChyZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgc29tZXRoaW5nIGJlc2lkZXMgYW4gRUNTIFNlcnZpY2UgaXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlIGluIEZBTExfQkFDSyBtb2RlXG4gICAgY29uc3Qgbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihyID0+IHIuVHlwZSAhPT0gJ0FXUzo6RUNTOjpTZXJ2aWNlJyk7XG4gICAgZm9yIChjb25zdCB0YXNrUmVmIG9mIG5vbkVjc1NlcnZpY2VUYXNrRGVmUmVmcykge1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKHJldCwgY2hhbmdlLCB1bmRlZmluZWQsIGBBIHJlc291cmNlICcke3Rhc2tSZWYuTG9naWNhbElkfScgd2l0aCBUeXBlICcke3Rhc2tSZWYuVHlwZX0nIHRoYXQgaXMgbm90IGFuIEVDUyBTZXJ2aWNlIHdhcyBmb3VuZCByZWZlcmVuY2luZyB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiAnJHtsb2dpY2FsSWR9J2ApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzID0gT2JqZWN0LmtleXMoY2xhc3NpZmllZENoYW5nZXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICBpZiAobmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZhbWlseU5hbWUgPSBhd2FpdCBnZXRGYW1pbHlOYW1lKGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGxvZ2ljYWxJZCwgY2hhbmdlKTtcbiAgICBpZiAoZmFtaWx5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgJ0ZhaWxlZCB0byBkZXRlcm1pbmUgZmFtaWx5IG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5pdGlvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbnN0IG9sZFRhc2tEZWZpbml0aW9uQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUGh5c2ljYWxOYW1lRm9yKGxvZ2ljYWxJZCk7XG4gICAgaWYgKG9sZFRhc2tEZWZpbml0aW9uQXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCAnRmFpbGVkIHRvIGRldGVybWluZSBBUk4gb2YgdGhlIHRhc2sgZGVmaW5pdGlvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGV2YWx1YXRhYmxlUHJvcGVydGllcyhldmFsdWF0ZUNmblRlbXBsYXRlLCBjaGFuZ2UsIHByb3BlcnRpZXNUb0hvdHN3YXApO1xuICAgIGlmIChjaGFuZ2VzLnVuZXZhbHVhdGFibGVVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCBgRm91bmQgY2hhbmdlcyB0aGF0IGNhbm5vdCBiZSBldmFsdWF0ZWQgbG9jYWxseSBpbiB0aGUgdGFzayBkZWZpbml0aW9uIC0gJHtcbiAgICAgICAgY2hhbmdlcy51bmV2YWx1YXRhYmxlVXBkYXRlcy5tYXAocCA9PiBwLmtleS5qb2luKCcuJykpLmpvaW4oJywgJylcbiAgICAgIH1gLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldC5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgICBwcm9wc0NoYW5nZWQ6IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgc2VydmljZTogJ2Vjcy1zZXJ2aWNlJyxcbiAgICAgIHJlc291cmNlTmFtZXM6IFtcbiAgICAgICAgYEVDUyBUYXNrIERlZmluaXRpb24gJyR7ZmFtaWx5TmFtZX0nYCxcbiAgICAgICAgLi4uZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubWFwKGVjc1NlcnZpY2UgPT4gYEVDUyBTZXJ2aWNlICcke2Vjc1NlcnZpY2Uuc2VydmljZUFybi5zcGxpdCgnLycpWzJdfSdgKSxcbiAgICAgIF0sXG4gICAgICBhcHBseTogYXN5bmMgKHNkazogSVNESykgPT4ge1xuICAgICAgICAvLyBTdGVwIDEgLSB1cGRhdGUgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24sIGNyZWF0aW5nIGEgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gbG93ZXJjYXNlIHRoZSBldmFsdWF0ZWQgVGFza0RlZiBmcm9tIENsb3VkRm9ybWF0aW9uLFxuICAgICAgICAvLyBhcyB0aGUgQVdTIFNESyB1c2VzIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyBmb3IgdGhlc2VcblxuICAgICAgICAvLyBnZXQgdGhlIHRhc2sgZGVmaW5pdGlvbiBvZiB0aGUgZmFtaWx5IGFuZCByZXZpc2lvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbGQgQ0ZuIHRlbXBsYXRlXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IHNka1xuICAgICAgICAgIC5lY3MoKVxuICAgICAgICAgIC5kZXNjcmliZVRhc2tEZWZpbml0aW9uKHtcbiAgICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiBvbGRUYXNrRGVmaW5pdGlvbkFybixcbiAgICAgICAgICAgIGluY2x1ZGU6IFsnVEFHUyddLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnByb21pc2UoKTtcbiAgICAgICAgaWYgKHRhcmdldC50YXNrRGVmaW5pdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIHRhc2sgZGVmaW5pdGlvbjogJHtvbGRUYXNrRGVmaW5pdGlvbkFybn0uIFRyeSBkZXBsb3lpbmcgd2l0aG91dCBob3Rzd2FwIGZpcnN0LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGRlc2NyaWJlVGFza0RlZmluaXRpb24gcmVzcG9uc2UgY29udGFpbnMgc2V2ZXJhbCBrZXlzIHRoYXQgbXVzdCBub3QgZXhpc3QgaW4gYSByZWdpc3RlclRhc2tEZWZpbml0aW9uIHJlcXVlc3QuXG4gICAgICAgIC8vIFdlIHJlbW92ZSB0aGVzZSBrZXlzIGhlcmUsIGNvbXBhcmluZyB0aGVzZSB0d28gc3RydWN0czpcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkVDUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uLmh0bWwjQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb25fUmVxdWVzdFN5bnRheFxuICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0Rlc2NyaWJlVGFza0RlZmluaXRpb24uaHRtbCNBUElfRGVzY3JpYmVUYXNrRGVmaW5pdGlvbl9SZXNwb25zZVN5bnRheFxuICAgICAgICBbXG4gICAgICAgICAgJ2NvbXBhdGliaWxpdGllcycsXG4gICAgICAgICAgJ3Rhc2tEZWZpbml0aW9uQXJuJyxcbiAgICAgICAgICAncmV2aXNpb24nLFxuICAgICAgICAgICdzdGF0dXMnLFxuICAgICAgICAgICdyZXF1aXJlc0F0dHJpYnV0ZXMnLFxuICAgICAgICAgICdjb21wYXRpYmlsaXRpZXMnLFxuICAgICAgICAgICdyZWdpc3RlcmVkQXQnLFxuICAgICAgICAgICdyZWdpc3RlcmVkQnknLFxuICAgICAgICBdLmZvckVhY2goa2V5PT4gZGVsZXRlICh0YXJnZXQudGFza0RlZmluaXRpb24gYXMgYW55KVtrZXldKTtcblxuICAgICAgICAvLyB0aGUgdGFncyBmaWVsZCBpcyBpbiBhIGRpZmZlcmVudCBsb2NhdGlvbiBpbiBkZXNjcmliZVRhc2tEZWZpbml0aW9uIHJlc3BvbnNlLFxuICAgICAgICAvLyBtb3ZpbmcgaXQgYXMgaW50ZW5kZWQgZm9yIHJlZ2lzdGVyVGFza0RlZmluaXRpb24gcmVxdWVzdC5cbiAgICAgICAgaWYgKHRhcmdldC50YWdzICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICh0YXJnZXQudGFza0RlZmluaXRpb24gYXMgYW55KS50YWdzID0gdGFyZ2V0LnRhZ3M7XG4gICAgICAgICAgZGVsZXRlIHRhcmdldC50YWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgdHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIHRoYXQgdGFrZSBhcmJpdHJhcnkgc3RyaW5nIGFzIGtleXMgaS5lLiB7IFwic3RyaW5nXCIgOiBcInN0cmluZ1wiIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkVDUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uLmh0bWwjQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb25fUmVxdWVzdFN5bnRheFxuICAgICAgICBjb25zdCBleGNsdWRlRnJvbVRyYW5zZm9ybSA9IHtcbiAgICAgICAgICBDb250YWluZXJEZWZpbml0aW9uczoge1xuICAgICAgICAgICAgRG9ja2VyTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgRmlyZWxlbnNDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTG9nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBPcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFZvbHVtZXM6IHtcbiAgICAgICAgICAgIERvY2tlclZvbHVtZUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgRHJpdmVyT3B0czogdHJ1ZSxcbiAgICAgICAgICAgICAgTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIGNvbnN0O1xuICAgICAgICBjb25zdCBleGNsdWRlRnJvbVRyYW5zZm9ybUxvd2VyY2FzZWQgPSB0cmFuc2Zvcm1PYmplY3RLZXlzKGV4Y2x1ZGVGcm9tVHJhbnNmb3JtLCBsb3dlckNhc2VGaXJzdENoYXJhY3Rlcik7XG4gICAgICAgIC8vIFdlIGZpcnN0IHVwcGVyY2FzZSB0aGUgdGFzayBkZWZpbml0aW9uIHRvIHByb3Blcmx5IG1lcmdlIGl0IHdpdGggdGhlIG9uZSBmcm9tIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgICAgICBjb25zdCB1cHBlckNhc2VkVGFza0RlZiA9IHRyYW5zZm9ybU9iamVjdEtleXModGFyZ2V0LnRhc2tEZWZpbml0aW9uLCB1cHBlckNhc2VGaXJzdENoYXJhY3RlciwgZXhjbHVkZUZyb21UcmFuc2Zvcm1Mb3dlcmNhc2VkKTtcbiAgICAgICAgLy8gbWVyZ2UgZXZhbHVhdGFibGUgZGlmZiBmcm9tIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgICAgICBjb25zdCB1cGRhdGVkVGFza0RlZiA9IGFwcGx5UHJvcGVydHlVcGRhdGVzKGNoYW5nZXMudXBkYXRlcywgdXBwZXJDYXNlZFRhc2tEZWYpO1xuICAgICAgICAvLyBsb3dlcmNhc2UgdGhlIG1lcmdlZCB0YXNrIGRlZmluaXRpb24gdG8gdXNlIGl0IGluIEFXUyBTREsuXG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZWRUYXNrRGVmID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh1cGRhdGVkVGFza0RlZiwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIGV4Y2x1ZGVGcm9tVHJhbnNmb3JtKTtcblxuICAgICAgICBjb25zdCByZWdpc3RlclRhc2tEZWZSZXNwb25zZSA9IGF3YWl0IHNkay5lY3MoKS5yZWdpc3RlclRhc2tEZWZpbml0aW9uKGxvd2VyY2FzZWRUYXNrRGVmKS5wcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHRhc2tEZWZSZXZBcm4gPSByZWdpc3RlclRhc2tEZWZSZXNwb25zZS50YXNrRGVmaW5pdGlvbj8udGFza0RlZmluaXRpb25Bcm47XG5cbiAgICAgICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgY29uc3Qgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzOiB7IFtjbHVzdGVyOiBzdHJpbmddOiBBcnJheTx7IHByb21pc2U6IFByb21pc2U8YW55PiwgZWNzU2VydmljZTogRWNzU2VydmljZSB9PiB9ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZWNzU2VydmljZSBvZiBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgICAgICAgIGNvbnN0IGNsdXN0ZXJOYW1lID0gZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMV07XG5cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsdXN0ZXJQcm9taXNlcyA9IHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlc1tjbHVzdGVyTmFtZV07XG4gICAgICAgICAgbGV0IGNsdXN0ZXJQcm9taXNlczogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT4sIGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT47XG4gICAgICAgICAgaWYgKGV4aXN0aW5nQ2x1c3RlclByb21pc2VzKSB7XG4gICAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBleGlzdGluZ0NsdXN0ZXJQcm9taXNlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2x1c3RlclByb21pc2VzID0gW107XG4gICAgICAgICAgICBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdID0gY2x1c3RlclByb21pc2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGb3JjaW5nIE5ldyBEZXBsb3ltZW50IGFuZCBzZXR0aW5nIE1pbmltdW0gSGVhbHRoeSBQZXJjZW50IHRvIDAuXG4gICAgICAgICAgLy8gQXMgQ0RLIEhvdFN3YXAgaXMgZGV2ZWxvcG1lbnQgb25seSwgdGhpcyBzZWVtcyB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGVuc3VyZSBhbGwgdGFza3MgYXJlIHJlcGxhY2VkIGltbWVkaWF0ZWx5LCByZWdhcmRsZXNzIG9mIG9yaWdpbmFsIGFtb3VudC5cbiAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMucHVzaCh7XG4gICAgICAgICAgICBwcm9taXNlOiBzZGsuZWNzKCkudXBkYXRlU2VydmljZSh7XG4gICAgICAgICAgICAgIHNlcnZpY2U6IGVjc1NlcnZpY2Uuc2VydmljZUFybixcbiAgICAgICAgICAgICAgdGFza0RlZmluaXRpb246IHRhc2tEZWZSZXZBcm4sXG4gICAgICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgICAgICBmb3JjZU5ld0RlcGxveW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRlcGxveW1lbnRDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpLFxuICAgICAgICAgICAgZWNzU2VydmljZTogZWNzU2VydmljZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcylcbiAgICAgICAgICAubWFwKGNsdXN0ZXJVcGRhdGVzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjbHVzdGVyVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLnByb21pc2UpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdGVwIDMgLSB3YWl0IGZvciB0aGUgc2VydmljZSBkZXBsb3ltZW50cyB0cmlnZ2VyZWQgaW4gU3RlcCAyIHRvIGZpbmlzaFxuICAgICAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgICAgIChzZGsuZWNzKCkgYXMgYW55KS5hcGkud2FpdGVycy5kZXBsb3ltZW50VG9GaW5pc2ggPSB7XG4gICAgICAgICAgbmFtZTogJ0RlcGxveW1lbnRUb0ZpbmlzaCcsXG4gICAgICAgICAgb3BlcmF0aW9uOiAnZGVzY3JpYmVTZXJ2aWNlcycsXG4gICAgICAgICAgZGVsYXk6IDEwLFxuICAgICAgICAgIG1heEF0dGVtcHRzOiA2MCxcbiAgICAgICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ2ZhaWx1cmVzW10ucmVhc29uJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdNSVNTSU5HJyxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnRFJBSU5JTkcnLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdJTkFDVElWRScsXG4gICAgICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aCcsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiBcImxlbmd0aChzZXJ2aWNlc1tdLmRlcGxveW1lbnRzWz8gc3RhdHVzID09ICdQUklNQVJZJyAmJiBydW5uaW5nQ291bnQgPCBkZXNpcmVkQ291bnRdW10pID09IGAwYFwiLFxuICAgICAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRUb0ZpbmlzaCBjb25maWd1cmF0aW9uIGFkZGVkIGFib3ZlXG4gICAgICAgIGNvbnN0IGRlcGxveW1lbnRXYWl0ZXIgPSBuZXcgKEFXUyBhcyBhbnkpLlJlc291cmNlV2FpdGVyKHNkay5lY3MoKSwgJ2RlcGxveW1lbnRUb0ZpbmlzaCcpO1xuICAgICAgICAvLyB3YWl0IGZvciBhbGwgb2YgdGhlIHdhaXRlcnMgdG8gZmluaXNoXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcykubWFwKChbY2x1c3Rlck5hbWUsIHNlcnZpY2VVcGRhdGVzXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBkZXBsb3ltZW50V2FpdGVyLndhaXQoe1xuICAgICAgICAgICAgY2x1c3RlcjogY2x1c3Rlck5hbWUsXG4gICAgICAgICAgICBzZXJ2aWNlczogc2VydmljZVVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5lY3NTZXJ2aWNlLnNlcnZpY2VBcm4pLFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmludGVyZmFjZSBFY3NTZXJ2aWNlIHtcbiAgcmVhZG9ubHkgc2VydmljZUFybjogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRGYW1pbHlOYW1lKFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSkge1xuICBjb25zdCB0YXNrRGVmaW5pdGlvblJlc291cmNlOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfSA9IHtcbiAgICAuLi5jaGFuZ2Uub2xkVmFsdWUuUHJvcGVydGllcyxcbiAgICBDb250YWluZXJEZWZpbml0aW9uczogY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LkNvbnRhaW5lckRlZmluaXRpb25zLFxuICB9O1xuICAgIC8vIGZpcnN0LCBsZXQncyBnZXQgdGhlIG5hbWUgb2YgdGhlIGZhbWlseVxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZCwgdGFza0RlZmluaXRpb25SZXNvdXJjZT8uRmFtaWx5KTtcbiAgaWYgKCFmYW1pbHlOYW1lT3JBcm4pIHtcbiAgICAvLyBpZiB0aGUgRmFtaWx5IHByb3BlcnR5IGhhcyBub3QgYmVlbiBwcm92aWRlZCwgYW5kIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGN1cnJlbnQgU3RhY2ssXG4gICAgLy8gdGhpcyBtZWFucyBob3Rzd2FwcGluZyBpcyBub3QgcG9zc2libGVcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGhlIHBoeXNpY2FsIG5hbWUgb2YgdGhlIFRhc2sgRGVmaW5pdGlvbiBpbiBDbG91ZEZvcm1hdGlvbiBpbmNsdWRlcyBpdHMgY3VycmVudCByZXZpc2lvbiBudW1iZXIgYXQgdGhlIGVuZCxcbiAgLy8gcmVtb3ZlIGl0IGlmIG5lZWRlZFxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm5QYXJ0cyA9IGZhbWlseU5hbWVPckFybi5zcGxpdCgnOicpO1xuICBjb25zdCBmYW1pbHkgPSBmYW1pbHlOYW1lT3JBcm5QYXJ0cy5sZW5ndGggPiAxXG4gIC8vIGZhbWlseU5hbWVPckFybiBpcyBhY3R1YWxseSBhbiBBUk4sIG9mIHRoZSBmb3JtYXQgJ2Fybjphd3M6ZWNzOnJlZ2lvbjphY2NvdW50OnRhc2stZGVmaW5pdGlvbi88ZmFtaWx5LW5hbWU+OjxyZXZpc2lvbi1ucj4nXG4gIC8vIHNvLCB0YWtlIHRoZSA2dGggZWxlbWVudCwgYXQgaW5kZXggNSwgYW5kIHNwbGl0IGl0IG9uICcvJ1xuICAgID8gZmFtaWx5TmFtZU9yQXJuUGFydHNbNV0uc3BsaXQoJy8nKVsxXVxuICAvLyBvdGhlcndpc2UsIGZhbWlseU5hbWVPckFybiBpcyBqdXN0IHRoZSBzaW1wbGUgbmFtZSBldmFsdWF0ZWQgZnJvbSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICA6IGZhbWlseU5hbWVPckFybjtcbiAgICAvLyB0aGVuLCBsZXQncyBldmFsdWF0ZSB0aGUgYm9keSBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBUYXNrRGVmICh3aXRob3V0IHRoZSBGYW1pbHkgcHJvcGVydHkpXG5cbiAgcmV0dXJuIGZhbWlseTtcbn1cbiJdfQ==
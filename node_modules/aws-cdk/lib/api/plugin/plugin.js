"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginHost = void 0;
const util_1 = require("util");
const chalk = require("chalk");
const _env_1 = require("./_env");
const context_provider_plugin_1 = require("./context-provider-plugin");
/**
 * A utility to manage plug-ins.
 *
 */
class PluginHost {
    constructor() {
        /**
         * Access the currently registered CredentialProviderSources. New sources can
         * be registered using the +registerCredentialProviderSource+ method.
         */
        this.credentialProviderSources = new Array();
        this.contextProviderPlugins = {};
        if (PluginHost.instance && PluginHost.instance !== this) {
            throw new Error('New instances of PluginHost must not be built. Use PluginHost.instance instead!');
        }
    }
    /**
     * Loads a plug-in into this PluginHost.
     *
     * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
     */
    load(moduleSpec) {
        try {
            /* eslint-disable @typescript-eslint/no-require-imports */
            const plugin = require(moduleSpec);
            /* eslint-enable */
            if (!isPlugin(plugin)) {
                (0, _env_1.error)(`Module ${chalk.green(moduleSpec)} is not a valid plug-in, or has an unsupported version.`);
                throw new Error(`Module ${moduleSpec} does not define a valid plug-in.`);
            }
            if (plugin.init) {
                plugin.init(PluginHost.instance);
            }
        }
        catch (e) {
            (0, _env_1.error)(`Unable to load ${chalk.green(moduleSpec)}: ${e.stack}`);
            throw new Error(`Unable to load plug-in: ${moduleSpec}`);
        }
        function isPlugin(x) {
            return x != null && x.version === '1';
        }
    }
    /**
     * Allows plug-ins to register new CredentialProviderSources.
     *
     * @param source a new CredentialProviderSource to register.
     */
    registerCredentialProviderSource(source) {
        // Forward to the right credentials-related plugin host
        this.credentialProviderSources.push(source);
    }
    /**
     * (EXPERIMENTAL) Allow plugins to register context providers
     *
     * Context providers are objects with the following method:
     *
     * ```ts
     *   getValue(args: {[key: string]: any}): Promise<any>;
     * ```
     *
     * Currently, they cannot reuse the CDK's authentication mechanisms, so they
     * must be prepared to either not make AWS calls or use their own source of
     * AWS credentials.
     *
     * This feature is experimental, and only intended to be used internally at Amazon
     * as a trial.
     *
     * After registering with 'my-plugin-name', the provider must be addressed as follows:
     *
     * ```ts
     * const value = ContextProvider.getValue(this, {
     *   providerName: 'plugin',
     *   props: {
     *     pluginName: 'my-plugin-name',
     *     myParameter1: 'xyz',
     *   },
     *   includeEnvironment: true | false,
     *   dummyValue: 'what-to-return-on-the-first-pass',
     * })
     * ```
     *
     * @experimental
     */
    registerContextProviderAlpha(pluginProviderName, provider) {
        if (!(0, context_provider_plugin_1.isContextProviderPlugin)(provider)) {
            throw new Error(`Object you gave me does not look like a ContextProviderPlugin: ${(0, util_1.inspect)(provider)}`);
        }
        this.contextProviderPlugins[pluginProviderName] = provider;
    }
}
exports.PluginHost = PluginHost;
PluginHost.instance = new PluginHost();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFFL0IsaUNBQStCO0FBQy9CLHVFQUEyRjtBQWtDM0Y7OztHQUdHO0FBQ0gsTUFBYSxVQUFVO0lBV3JCO1FBUkE7OztXQUdHO1FBQ2EsOEJBQXlCLEdBQUcsSUFBSSxLQUFLLEVBQTRCLENBQUM7UUFFbEUsMkJBQXNCLEdBQTBDLEVBQUUsQ0FBQztRQUdqRixJQUFJLFVBQVUsQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRkFBaUYsQ0FBQyxDQUFDO1NBQ3BHO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxJQUFJLENBQUMsVUFBa0I7UUFDNUIsSUFBSTtZQUNGLDBEQUEwRDtZQUMxRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkMsbUJBQW1CO1lBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ3JCLElBQUEsWUFBSyxFQUFDLFVBQVUsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMseURBQXlELENBQUMsQ0FBQztnQkFDbEcsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLFVBQVUsbUNBQW1DLENBQUMsQ0FBQzthQUMxRTtZQUNELElBQUksTUFBTSxDQUFDLElBQUksRUFBRTtnQkFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUFFO1NBQ3ZEO1FBQUMsT0FBTyxDQUFNLEVBQUU7WUFDZixJQUFBLFlBQUssRUFBQyxrQkFBa0IsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUMvRCxNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsU0FBUyxRQUFRLENBQUMsQ0FBTTtZQUN0QixPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxHQUFHLENBQUM7UUFDeEMsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksZ0NBQWdDLENBQUMsTUFBZ0M7UUFDdEUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JHO0lBQ0ksNEJBQTRCLENBQUMsa0JBQTBCLEVBQUUsUUFBK0I7UUFDN0YsSUFBSSxDQUFDLElBQUEsaURBQXVCLEVBQUMsUUFBUSxDQUFDLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRUFBa0UsSUFBQSxjQUFPLEVBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3hHO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGtCQUFrQixDQUFDLEdBQUcsUUFBUSxDQUFDO0lBQzdELENBQUM7O0FBekZILGdDQTBGQztBQXpGZSxtQkFBUSxHQUFHLElBQUksVUFBVSxFQUFFLEFBQW5CLENBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuXG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4vX2Vudic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4sIGlzQ29udGV4dFByb3ZpZGVyUGx1Z2luIH0gZnJvbSAnLi9jb250ZXh0LXByb3ZpZGVyLXBsdWdpbic7XG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UgfSBmcm9tICcuL2NyZWRlbnRpYWwtcHJvdmlkZXItc291cmNlJztcblxuLyoqXG4gKiBUaGUgYmFzaWMgY29udHJhY3QgZm9yIHBsdWctaW5zIHRvIGFkaGVyZSB0bzo6XG4gKlxuICogICBpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbkhvc3QgfSBmcm9tICdhd3MtY2RrJztcbiAqICAgaW1wb3J0IHsgQ3VzdG9tQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlIH0gZnJvbSAnLi9jdXN0b20tY3JlZGVudGlhbC1wcm92aWRlci1zb3VyY2UnO1xuICpcbiAqICAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9vQ0RLUGx1Z0luIGltcGxlbWVudHMgUGx1Z2luSG9zdCB7XG4gKiAgICAgcHVibGljIHJlYWRvbmx5IHZlcnNpb24gPSAnMSc7XG4gKlxuICogICAgIHB1YmxpYyBpbml0KGhvc3Q6IFBsdWdpbkhvc3QpIHtcbiAqICAgICBob3N0LnJlZ2lzdGVyQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKG5ldyBDdXN0b21DcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UoKSk7XG4gKiAgICAgfVxuICogICB9XG4gKlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpbiB7XG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgcGx1Zy1pbiBpbnRlcmZhY2UgdXNlZCBieSB0aGUgcGx1Zy1pbi4gVGhpcyB3aWxsIGJlIHVzZWQgYnlcbiAgICogdGhlIHBsdWctaW4gaG9zdCB0byBoYW5kbGUgdmVyc2lvbiBjaGFuZ2VzLlxuICAgKi9cbiAgdmVyc2lvbjogJzEnO1xuXG4gIC8qKlxuICAgKiBXaGVuIGRlZmluZWQsIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCByaWdodCBhZnRlciB0aGUgcGx1Zy1pbiBoYXMgYmVlbiBsb2FkZWQsXG4gICAqIHNvIHRoYXQgdGhlIHBsdWctaW4gaXMgYWJsZSB0byBpbml0aWFsaXplIGl0c2VsZi4gSXQgbWF5IGNhbGwgbWV0aG9kcyBvZiB0aGVcbiAgICogYGBQbHVnaW5Ib3N0YGAgaW5zdGFuY2UgaXQgcmVjZWl2ZXMgdG8gcmVnaXN0ZXIgbmV3IGBgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlYGBcbiAgICogaW5zdGFuY2VzLlxuICAgKi9cbiAgaW5pdD86IChob3N0OiBQbHVnaW5Ib3N0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0byBtYW5hZ2UgcGx1Zy1pbnMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGx1Z2luSG9zdCB7XG4gIHB1YmxpYyBzdGF0aWMgaW5zdGFuY2UgPSBuZXcgUGx1Z2luSG9zdCgpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIENyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMuIE5ldyBzb3VyY2VzIGNhblxuICAgKiBiZSByZWdpc3RlcmVkIHVzaW5nIHRoZSArcmVnaXN0ZXJDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UrIG1ldGhvZC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzID0gbmV3IEFycmF5PENyZWRlbnRpYWxQcm92aWRlclNvdXJjZT4oKTtcblxuICBwdWJsaWMgcmVhZG9ubHkgY29udGV4dFByb3ZpZGVyUGx1Z2luczogUmVjb3JkPHN0cmluZywgQ29udGV4dFByb3ZpZGVyUGx1Z2luPiA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmIChQbHVnaW5Ib3N0Lmluc3RhbmNlICYmIFBsdWdpbkhvc3QuaW5zdGFuY2UgIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV3IGluc3RhbmNlcyBvZiBQbHVnaW5Ib3N0IG11c3Qgbm90IGJlIGJ1aWx0LiBVc2UgUGx1Z2luSG9zdC5pbnN0YW5jZSBpbnN0ZWFkIScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIHBsdWctaW4gaW50byB0aGlzIFBsdWdpbkhvc3QuXG4gICAqXG4gICAqIEBwYXJhbSBtb2R1bGVTcGVjIHRoZSBzcGVjaWZpY2F0aW9uIChwYXRoIG9yIG5hbWUpIG9mIHRoZSBwbHVnLWluIG1vZHVsZSB0byBiZSBsb2FkZWQuXG4gICAqL1xuICBwdWJsaWMgbG9hZChtb2R1bGVTcGVjOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuICAgICAgY29uc3QgcGx1Z2luID0gcmVxdWlyZShtb2R1bGVTcGVjKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgIGlmICghaXNQbHVnaW4ocGx1Z2luKSkge1xuICAgICAgICBlcnJvcihgTW9kdWxlICR7Y2hhbGsuZ3JlZW4obW9kdWxlU3BlYyl9IGlzIG5vdCBhIHZhbGlkIHBsdWctaW4sIG9yIGhhcyBhbiB1bnN1cHBvcnRlZCB2ZXJzaW9uLmApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1vZHVsZSAke21vZHVsZVNwZWN9IGRvZXMgbm90IGRlZmluZSBhIHZhbGlkIHBsdWctaW4uYCk7XG4gICAgICB9XG4gICAgICBpZiAocGx1Z2luLmluaXQpIHsgcGx1Z2luLmluaXQoUGx1Z2luSG9zdC5pbnN0YW5jZSk7IH1cbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGVycm9yKGBVbmFibGUgdG8gbG9hZCAke2NoYWxrLmdyZWVuKG1vZHVsZVNwZWMpfTogJHtlLnN0YWNrfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBwbHVnLWluOiAke21vZHVsZVNwZWN9YCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQbHVnaW4oeDogYW55KTogeCBpcyBQbHVnaW4ge1xuICAgICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4LnZlcnNpb24gPT09ICcxJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHBsdWctaW5zIHRvIHJlZ2lzdGVyIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIGEgbmV3IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSB0byByZWdpc3Rlci5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlckNyZWRlbnRpYWxQcm92aWRlclNvdXJjZShzb3VyY2U6IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSkge1xuICAgIC8vIEZvcndhcmQgdG8gdGhlIHJpZ2h0IGNyZWRlbnRpYWxzLXJlbGF0ZWQgcGx1Z2luIGhvc3RcbiAgICB0aGlzLmNyZWRlbnRpYWxQcm92aWRlclNvdXJjZXMucHVzaChzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIChFWFBFUklNRU5UQUwpIEFsbG93IHBsdWdpbnMgdG8gcmVnaXN0ZXIgY29udGV4dCBwcm92aWRlcnNcbiAgICpcbiAgICogQ29udGV4dCBwcm92aWRlcnMgYXJlIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIG1ldGhvZDpcbiAgICpcbiAgICogYGBgdHNcbiAgICogICBnZXRWYWx1ZShhcmdzOiB7W2tleTogc3RyaW5nXTogYW55fSk6IFByb21pc2U8YW55PjtcbiAgICogYGBgXG4gICAqXG4gICAqIEN1cnJlbnRseSwgdGhleSBjYW5ub3QgcmV1c2UgdGhlIENESydzIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbXMsIHNvIHRoZXlcbiAgICogbXVzdCBiZSBwcmVwYXJlZCB0byBlaXRoZXIgbm90IG1ha2UgQVdTIGNhbGxzIG9yIHVzZSB0aGVpciBvd24gc291cmNlIG9mXG4gICAqIEFXUyBjcmVkZW50aWFscy5cbiAgICpcbiAgICogVGhpcyBmZWF0dXJlIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG9ubHkgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGF0IEFtYXpvblxuICAgKiBhcyBhIHRyaWFsLlxuICAgKlxuICAgKiBBZnRlciByZWdpc3RlcmluZyB3aXRoICdteS1wbHVnaW4tbmFtZScsIHRoZSBwcm92aWRlciBtdXN0IGJlIGFkZHJlc3NlZCBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB2YWx1ZSA9IENvbnRleHRQcm92aWRlci5nZXRWYWx1ZSh0aGlzLCB7XG4gICAqICAgcHJvdmlkZXJOYW1lOiAncGx1Z2luJyxcbiAgICogICBwcm9wczoge1xuICAgKiAgICAgcGx1Z2luTmFtZTogJ215LXBsdWdpbi1uYW1lJyxcbiAgICogICAgIG15UGFyYW1ldGVyMTogJ3h5eicsXG4gICAqICAgfSxcbiAgICogICBpbmNsdWRlRW52aXJvbm1lbnQ6IHRydWUgfCBmYWxzZSxcbiAgICogICBkdW1teVZhbHVlOiAnd2hhdC10by1yZXR1cm4tb24tdGhlLWZpcnN0LXBhc3MnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyQ29udGV4dFByb3ZpZGVyQWxwaGEocGx1Z2luUHJvdmlkZXJOYW1lOiBzdHJpbmcsIHByb3ZpZGVyOiBDb250ZXh0UHJvdmlkZXJQbHVnaW4pIHtcbiAgICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyUGx1Z2luKHByb3ZpZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgeW91IGdhdmUgbWUgZG9lcyBub3QgbG9vayBsaWtlIGEgQ29udGV4dFByb3ZpZGVyUGx1Z2luOiAke2luc3BlY3QocHJvdmlkZXIpfWApO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHRQcm92aWRlclBsdWdpbnNbcGx1Z2luUHJvdmlkZXJOYW1lXSA9IHByb3ZpZGVyO1xuICB9XG59XG4iXX0=
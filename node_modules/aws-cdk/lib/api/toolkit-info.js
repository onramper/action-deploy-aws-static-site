"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const chalk = require("chalk");
const bootstrap_props_1 = require("./bootstrap/bootstrap-props");
const cloudformation_1 = require("./util/cloudformation");
const logging_1 = require("../logging");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * The bootstrap template version that introduced ssm:GetParameter
 */
const BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 */
class ToolkitInfo {
    static determineName(overrideName) {
        return overrideName ?? exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    static async lookup(environment, sdk, stackName) {
        const cfn = sdk.cloudFormation();
        const stack = await (0, cloudformation_1.stabilizeStack)(cfn, stackName ?? exports.DEFAULT_TOOLKIT_STACK_NAME);
        if (!stack) {
            (0, logging_1.debug)('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        if (stack.stackStatus.isCreationFailure) {
            // Treat a "failed to create" bootstrap stack as an absent one.
            (0, logging_1.debug)('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`));
            return ToolkitInfo.bootstrapStackNotFoundInfo(sdk);
        }
        return new ExistingToolkitInfo(stack, sdk);
    }
    static fromStack(stack, sdk) {
        return new ExistingToolkitInfo(stack, sdk);
    }
    static bootstraplessDeploymentsOnly(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI.');
    }
    static bootstrapStackNotFoundInfo(sdk) {
        return new BootstrapStackNotFoundInfo(sdk, 'This deployment requires a bootstrap stack with a known name; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)');
    }
    /**
     * Read a version from an SSM parameter, cached
     */
    static async versionFromSsmParameter(sdk, parameterName, ssmCache) {
        const existing = ssmCache?.get(parameterName);
        if (existing !== undefined) {
            return existing;
        }
        const ssm = sdk.ssm();
        try {
            const result = await ssm.getParameter({ Name: parameterName }).promise();
            const asNumber = parseInt(`${result.Parameter?.Value}`, 10);
            if (isNaN(asNumber)) {
                throw new Error(`SSM parameter ${parameterName} not a number: ${result.Parameter?.Value}`);
            }
            ssmCache?.set(parameterName, asNumber);
            return asNumber;
        }
        catch (e) {
            if (e.code === 'ParameterNotFound') {
                throw new Error(`SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run \'cdk bootstrap\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
            }
            throw e;
        }
    }
    constructor(sdk) {
        this.sdk = sdk;
        this.ssmCache = new Map();
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack, sdk) {
        super(sdk);
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_props_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_props_1.BUCKET_NAME_OUTPUT);
    }
    get version() {
        return parseInt(this.bootstrapStack.outputs[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT] ?? '0', 10);
    }
    get variant() {
        return this.bootstrapStack.parameters[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER] ?? bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
    }
    get parameters() {
        return this.bootstrapStack.parameters ?? {};
    }
    get terminationProtection() {
        return this.bootstrapStack.terminationProtection ?? false;
    }
    /**
     * Validate that the bootstrap stack version matches or exceeds the expected version
     *
     * Use the SSM parameter name to read the version number if given, otherwise use the version
     * discovered on the bootstrap stack.
     *
     * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
     * lookup again and again for every artifact.
     */
    async validateVersion(expectedVersion, ssmParameterName) {
        let version = this.version; // Default to the current version, but will be overwritten by a lookup if required.
        if (ssmParameterName !== undefined) {
            try {
                version = await ToolkitInfo.versionFromSsmParameter(this.sdk, ssmParameterName, this.ssmCache);
            }
            catch (e) {
                if (e.code !== 'AccessDeniedException') {
                    throw e;
                }
                // This is a fallback! The bootstrap template that goes along with this change introduces
                // a new 'ssm:GetParameter' permission, but when run using the previous bootstrap template we
                // won't have the permissions yet to read the version, so we won't be able to show the
                // message telling the user they need to update! When we see an AccessDeniedException, fall
                // back to the version we read from Stack Outputs; but ONLY if the version we discovered via
                // outputs is legitimately an old version. If it's newer than that, something else must be broken,
                // so let it fail as it would if we didn't have this fallback.
                if (this.version >= BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
                    throw e;
                }
                (0, logging_1.warning)(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
                // Fall through on purpose
            }
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     */
    async prepareEcrRepository(repositoryName) {
        if (!this.sdk) {
            throw new Error('ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository');
        }
        const ecr = this.sdk.ecr();
        // check if repo already exists
        try {
            (0, logging_1.debug)(`${repositoryName}: checking if ECR repository already exists`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            const existingRepositoryUri = describeResponse.repositories[0]?.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        (0, logging_1.debug)(`${repositoryName}: creating ECR repository`);
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({ repositoryName, tags: [assetTag] }).promise();
        const repositoryUri = response.repository?.repositoryUri;
        if (!repositoryUri) {
            throw new Error(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        (0, logging_1.debug)(`${repositoryName}: enable image scanning`);
        await ecr.putImageScanningConfiguration({ repositoryName, imageScanningConfiguration: { scanOnPush: true } }).promise();
        return { repositoryUri };
    }
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new Error(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(sdk, errorMessage) {
        super(sdk);
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new Error(this.errorMessage);
    }
    get bucketUrl() {
        throw new Error(this.errorMessage);
    }
    get bucketName() {
        throw new Error(this.errorMessage);
    }
    get version() {
        throw new Error(this.errorMessage);
    }
    get variant() {
        throw new Error(this.errorMessage);
    }
    async validateVersion(expectedVersion, ssmParameterName) {
        if (ssmParameterName === undefined) {
            throw new Error(this.errorMessage);
        }
        let version;
        try {
            version = await ToolkitInfo.versionFromSsmParameter(this.sdk, ssmParameterName, this.ssmCache);
        }
        catch (e) {
            if (e.code !== 'AccessDeniedException') {
                throw e;
            }
            // This is a fallback! The bootstrap template that goes along with this change introduces
            // a new 'ssm:GetParameter' permission, but when run using a previous bootstrap template we
            // won't have the permissions yet to read the version, so we won't be able to show the
            // message telling the user they need to update! When we see an AccessDeniedException, fall
            // back to the version we read from Stack Outputs.
            (0, logging_1.warning)(`Could not read SSM parameter ${ssmParameterName}: ${e.message}`);
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found an older version. Please run 'cdk bootstrap'.`);
        }
        if (expectedVersion > version) {
            throw new Error(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
        }
    }
    prepareEcrRepository() {
        throw new Error(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLCtCQUErQjtBQUUvQixpRUFBOEs7QUFDOUssMERBQTRFO0FBQzVFLHdDQUE0QztBQUUvQixRQUFBLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUV2RDs7R0FFRztBQUNILE1BQU0sbURBQW1ELEdBQUcsQ0FBQyxDQUFDO0FBRTlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBc0IsV0FBVztJQUN4QixNQUFNLENBQUMsYUFBYSxDQUFDLFlBQXFCO1FBQy9DLE9BQU8sWUFBWSxJQUFJLGtDQUEwQixDQUFDO0lBQ3BELENBQUM7SUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUE4QixFQUFFLEdBQVMsRUFBRSxTQUE2QjtRQUNqRyxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDakMsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFBLCtCQUFjLEVBQUMsR0FBRyxFQUFFLFNBQVMsSUFBSSxrQ0FBMEIsQ0FBQyxDQUFDO1FBQ2pGLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixJQUFBLGVBQUssRUFBQyxtSUFBbUksRUFDdkksV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNsRixPQUFPLFdBQVcsQ0FBQywwQkFBMEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNwRDtRQUNELElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRTtZQUN2QywrREFBK0Q7WUFDL0QsSUFBQSxlQUFLLEVBQUMsNkdBQTZHLEVBQ2pILFdBQVcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsa0JBQWtC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LGVBQWUsYUFBYSxPQUFPLGdDQUFnQyxDQUFDLENBQUM7U0FDL0k7SUFDSCxDQUFDO0lBRU0sb0JBQW9CO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsIEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQsIEJVQ0tFVF9OQU1FX09VVFBVVCwgQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSLCBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5UIH0gZnJvbSAnLi9ib290c3RyYXAvYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IHN0YWJpbGl6ZVN0YWNrLCBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSA9ICdDREtUb29sa2l0JztcblxuLyoqXG4gKiBUaGUgYm9vdHN0cmFwIHRlbXBsYXRlIHZlcnNpb24gdGhhdCBpbnRyb2R1Y2VkIHNzbTpHZXRQYXJhbWV0ZXJcbiAqL1xuY29uc3QgQk9PVFNUUkFQX1RFTVBMQVRFX1ZFUlNJT05fSU5UUk9EVUNJTkdfR0VUUEFSQU1FVEVSID0gNTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgQm9vdHN0cmFwIHN0YWNrIG9mIHRoZSBlbnZpcm9ubWVudCB3ZSdyZSBkZXBsb3lpbmcgdG8uXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgdG86XG4gKlxuICogLSBJbnNwZWN0IHRoZSBib290c3RyYXAgc3RhY2ssIGFuZCByZXR1cm4gdmFyaW91cyBwcm9wZXJ0aWVzIG9mIGl0IGZvciBzdWNjZXNzZnVsXG4gKiAgIGFzc2V0IGRlcGxveW1lbnQgKGluIGNhc2Ugb2YgbGVnYWN5LXN5bnRoZXNpemVkIHN0YWNrcykuXG4gKiAtIFZhbGlkYXRlIHRoZSB2ZXJzaW9uIG9mIHRoZSB0YXJnZXQgZW52aXJvbm1lbnQsIGFuZCBub3RoaW5nIGVsc2UgKGluIGNhc2Ugb2ZcbiAqICAgZGVmYXVsdC1zeW50aGVzaXplZCBzdGFja3MpLlxuICpcbiAqIEFuIG9iamVjdCBvZiB0aGlzIHR5cGUgbWlnaHQgcmVwcmVzZW50IGEgYm9vdHN0cmFwIHN0YWNrIHRoYXQgY291bGQgbm90IGJlIGZvdW5kLlxuICogVGhpcyBpcyBub3QgYW4gaXNzdWUgdW5sZXNzIGFueSBtZW1iZXJzIGFyZSB1c2VkIHRoYXQgcmVxdWlyZSB0aGUgYm9vdHN0cmFwIHN0YWNrXG4gKiB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgYW4gZXJyb3IgaXMgdGhyb3duIChkZWZhdWx0LXN5bnRoZXNpemVkIHN0YWNrc1xuICogc2hvdWxkIG5ldmVyIHJ1biBpbnRvIHRoaXMgYXMgdGhleSBkb24ndCBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIGJvb3RzdHJhcFxuICogc3RhY2ssIGFsbCBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IGVuY29kZWQgaW50byB0aGUgQ2xvdWQgQXNzZW1ibHkgTWFuaWZlc3QpLlxuICpcbiAqIE5ldmVydGhlbGVzcywgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBleGlzdHMgdG8gc2VydmUgYXMgYSBjYWNoZSBmb3IgU1NNXG4gKiBwYXJhbWV0ZXIgbG9va3VwcyAob3RoZXJ3aXNlLCB0aGUgXCJib290c3RyYXAgc3RhY2sgdmVyc2lvblwiIHBhcmFtZXRlciB3b3VsZFxuICogbmVlZCB0byBiZSByZWFkIHJlcGVhdGVkbHkpLlxuICpcbiAqIENhbGxlZCBcIlRvb2xraXRJbmZvXCIgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyBzdGF0aWMgZGV0ZXJtaW5lTmFtZShvdmVycmlkZU5hbWU/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREssIHN0YWNrTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxUb29sa2l0SW5mbz4ge1xuICAgIGNvbnN0IGNmbiA9IHNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUpO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgZG9lc25cXCd0IGhhdmUgdGhlIENESyB0b29sa2l0IHN0YWNrICglcykgaW5zdGFsbGVkLiBVc2UgJXMgdG8gc2V0dXAgeW91ciBlbnZpcm9ubWVudCBmb3IgdXNlIHdpdGggdGhlIHRvb2xraXQuJyxcbiAgICAgICAgZW52aXJvbm1lbnQubmFtZSwgc3RhY2tOYW1lLCBjaGFsay5ibHVlKGBjZGsgYm9vdHN0cmFwIFwiJHtlbnZpcm9ubWVudC5uYW1lfVwiYCkpO1xuICAgICAgcmV0dXJuIFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHNkayk7XG4gICAgfVxuICAgIGlmIChzdGFjay5zdGFja1N0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgICAgLy8gVHJlYXQgYSBcImZhaWxlZCB0byBjcmVhdGVcIiBib290c3RyYXAgc3RhY2sgYXMgYW4gYWJzZW50IG9uZS5cbiAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgaGFzIGEgQ0RLIHRvb2xraXQgc3RhY2sgKCVzKSB0aGF0IGZhaWxlZCB0byBjcmVhdGUuIFVzZSAlcyB0byB0cnkgcHJvdmlzaW9uaW5nIGl0IGFnYWluLicsXG4gICAgICAgIGVudmlyb25tZW50Lm5hbWUsIHN0YWNrTmFtZSwgY2hhbGsuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApKTtcbiAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzZGspO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRXhpc3RpbmdUb29sa2l0SW5mbyhzdGFjaywgc2RrKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YWNrKHN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLCBzZGs6IElTREspOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBFeGlzdGluZ1Rvb2xraXRJbmZvKHN0YWNrLCBzZGspO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBib290c3RyYXBsZXNzRGVwbG95bWVudHNPbmx5KHNkazogSVNESyk6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHNkaywgJ1RyeWluZyB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIGEgYm9vdHN0cmFwIHN0YWNrOyB5b3Ugc2hvdWxkIG5vdCBzZWUgdGhpcyBlcnJvciwgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQ0RLIENMSS4nKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrOiBJU0RLKTogVG9vbGtpdEluZm8ge1xuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc2RrLCAnVGhpcyBkZXBsb3ltZW50IHJlcXVpcmVzIGEgYm9vdHN0cmFwIHN0YWNrIHdpdGggYSBrbm93biBuYW1lOyBwYXNzIFxcJy0tdG9vbGtpdC1zdGFjay1uYW1lXFwnIG9yIHN3aXRjaCB0byB1c2luZyB0aGUgXFwnRGVmYXVsdFN0YWNrU3ludGhlc2l6ZXJcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHZlcnNpb24gZnJvbSBhbiBTU00gcGFyYW1ldGVyLCBjYWNoZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgdmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIoc2RrOiBJU0RLLCBwYXJhbWV0ZXJOYW1lOiBzdHJpbmcsIHNzbUNhY2hlPzogTWFwPHN0cmluZywgbnVtYmVyPik6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzc21DYWNoZT8uZ2V0KHBhcmFtZXRlck5hbWUpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7IHJldHVybiBleGlzdGluZzsgfVxuXG4gICAgY29uc3Qgc3NtID0gc2RrLnNzbSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNzbS5nZXRQYXJhbWV0ZXIoeyBOYW1lOiBwYXJhbWV0ZXJOYW1lIH0pLnByb21pc2UoKTtcblxuICAgICAgY29uc3QgYXNOdW1iZXIgPSBwYXJzZUludChgJHtyZXN1bHQuUGFyYW1ldGVyPy5WYWx1ZX1gLCAxMCk7XG4gICAgICBpZiAoaXNOYU4oYXNOdW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NNIHBhcmFtZXRlciAke3BhcmFtZXRlck5hbWV9IG5vdCBhIG51bWJlcjogJHtyZXN1bHQuUGFyYW1ldGVyPy5WYWx1ZX1gKTtcbiAgICAgIH1cblxuICAgICAgc3NtQ2FjaGU/LnNldChwYXJhbWV0ZXJOYW1lLCBhc051bWJlcik7XG4gICAgICByZXR1cm4gYXNOdW1iZXI7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnUGFyYW1ldGVyTm90Rm91bmQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NNIHBhcmFtZXRlciAke3BhcmFtZXRlck5hbWV9IG5vdCBmb3VuZC4gSGFzIHRoZSBlbnZpcm9ubWVudCBiZWVuIGJvb3RzdHJhcHBlZD8gUGxlYXNlIHJ1biBcXCdjZGsgYm9vdHN0cmFwXFwnIChzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay9sYXRlc3QvZ3VpZGUvYm9vdHN0cmFwcGluZy5odG1sKWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3NtQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZm91bmQ6IGJvb2xlYW47XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBidWNrZXRVcmw6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZlcnNpb246IG51bWJlcjtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHZhcmlhbnQ6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJvb3RzdHJhcFN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBzZGs6IElTREspIHtcbiAgfVxuICBwdWJsaWMgYWJzdHJhY3QgdmFsaWRhdGVWZXJzaW9uKGV4cGVjdGVkVmVyc2lvbjogbnVtYmVyLCBzc21QYXJhbWV0ZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+O1xuICBwdWJsaWMgYWJzdHJhY3QgcHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWU6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+O1xufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBib290c3RyYXAgc3RhY2sgaXMgZm91bmRcbiAqL1xuY2xhc3MgRXhpc3RpbmdUb29sa2l0SW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssIHNkazogSVNESykge1xuICAgIHN1cGVyKHNkayk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnJlcXVpcmVPdXRwdXQoQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCl9YDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlT3V0cHV0KEJVQ0tFVF9OQU1FX09VVFBVVCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVRdID8/ICcwJywgMTApO1xuICB9XG5cbiAgcHVibGljIGdldCB2YXJpYW50KCkge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnBhcmFtZXRlcnNbQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSXSA/PyBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5UO1xuICB9XG5cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnBhcmFtZXRlcnMgPz8ge307XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGUgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gbWF0Y2hlcyBvciBleGNlZWRzIHRoZSBleHBlY3RlZCB2ZXJzaW9uXG4gICAqXG4gICAqIFVzZSB0aGUgU1NNIHBhcmFtZXRlciBuYW1lIHRvIHJlYWQgdGhlIHZlcnNpb24gbnVtYmVyIGlmIGdpdmVuLCBvdGhlcndpc2UgdXNlIHRoZSB2ZXJzaW9uXG4gICAqIGRpc2NvdmVyZWQgb24gdGhlIGJvb3RzdHJhcCBzdGFjay5cbiAgICpcbiAgICogUGFzcyBpbiB0aGUgU1NNIHBhcmFtZXRlciBuYW1lIHNvIHdlIGNhbiBjYWNoZSB0aGUgbG9va3VwcyBhbiBkb24ndCBuZWVkIHRvIGRvIHRoZSBzYW1lXG4gICAqIGxvb2t1cCBhZ2FpbiBhbmQgYWdhaW4gZm9yIGV2ZXJ5IGFydGlmYWN0LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHZhbGlkYXRlVmVyc2lvbihleHBlY3RlZFZlcnNpb246IG51bWJlciwgc3NtUGFyYW1ldGVyTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgbGV0IHZlcnNpb24gPSB0aGlzLnZlcnNpb247IC8vIERlZmF1bHQgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbiwgYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYSBsb29rdXAgaWYgcmVxdWlyZWQuXG5cbiAgICBpZiAoc3NtUGFyYW1ldGVyTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gYXdhaXQgVG9vbGtpdEluZm8udmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIodGhpcy5zZGssIHNzbVBhcmFtZXRlck5hbWUsIHRoaXMuc3NtQ2FjaGUpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGlmIChlLmNvZGUgIT09ICdBY2Nlc3NEZW5pZWRFeGNlcHRpb24nKSB7IHRocm93IGU7IH1cblxuICAgICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2shIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdGhhdCBnb2VzIGFsb25nIHdpdGggdGhpcyBjaGFuZ2UgaW50cm9kdWNlc1xuICAgICAgICAvLyBhIG5ldyAnc3NtOkdldFBhcmFtZXRlcicgcGVybWlzc2lvbiwgYnV0IHdoZW4gcnVuIHVzaW5nIHRoZSBwcmV2aW91cyBib290c3RyYXAgdGVtcGxhdGUgd2VcbiAgICAgICAgLy8gd29uJ3QgaGF2ZSB0aGUgcGVybWlzc2lvbnMgeWV0IHRvIHJlYWQgdGhlIHZlcnNpb24sIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gc2hvdyB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSB0ZWxsaW5nIHRoZSB1c2VyIHRoZXkgbmVlZCB0byB1cGRhdGUhIFdoZW4gd2Ugc2VlIGFuIEFjY2Vzc0RlbmllZEV4Y2VwdGlvbiwgZmFsbFxuICAgICAgICAvLyBiYWNrIHRvIHRoZSB2ZXJzaW9uIHdlIHJlYWQgZnJvbSBTdGFjayBPdXRwdXRzOyBidXQgT05MWSBpZiB0aGUgdmVyc2lvbiB3ZSBkaXNjb3ZlcmVkIHZpYVxuICAgICAgICAvLyBvdXRwdXRzIGlzIGxlZ2l0aW1hdGVseSBhbiBvbGQgdmVyc2lvbi4gSWYgaXQncyBuZXdlciB0aGFuIHRoYXQsIHNvbWV0aGluZyBlbHNlIG11c3QgYmUgYnJva2VuLFxuICAgICAgICAvLyBzbyBsZXQgaXQgZmFpbCBhcyBpdCB3b3VsZCBpZiB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIGZhbGxiYWNrLlxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IEJPT1RTVFJBUF9URU1QTEFURV9WRVJTSU9OX0lOVFJPRFVDSU5HX0dFVFBBUkFNRVRFUikge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKGBDb3VsZCBub3QgcmVhZCBTU00gcGFyYW1ldGVyICR7c3NtUGFyYW1ldGVyTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggb24gcHVycG9zZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBlY3RlZFZlcnNpb24gPiB2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGZvdW5kICcke3ZlcnNpb259Jy4gUGxlYXNlIHJ1biAnY2RrIGJvb3RzdHJhcCcuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW4gRUNSIHJlcG9zaXRvcnkgZm9yIHVwbG9hZGluZyB0byB1c2luZyBEb2NrZXJcbiAgICpcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz4ge1xuICAgIGlmICghdGhpcy5zZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vbGtpdEluZm8gbmVlZHMgdG8gaGF2ZSBiZWVuIGluaXRpYWxpemVkIHdpdGggYW4gc2RrIHRvIGNhbGwgcHJlcGFyZUVjclJlcG9zaXRvcnknKTtcbiAgICB9XG4gICAgY29uc3QgZWNyID0gdGhpcy5zZGsuZWNyKCk7XG5cbiAgICAvLyBjaGVjayBpZiByZXBvIGFscmVhZHkgZXhpc3RzXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY2hlY2tpbmcgaWYgRUNSIHJlcG9zaXRvcnkgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlUmVzcG9uc2UgPSBhd2FpdCBlY3IuZGVzY3JpYmVSZXBvc2l0b3JpZXMoeyByZXBvc2l0b3J5TmFtZXM6IFtyZXBvc2l0b3J5TmFtZV0gfSkucHJvbWlzZSgpO1xuICAgICAgY29uc3QgZXhpc3RpbmdSZXBvc2l0b3J5VXJpID0gZGVzY3JpYmVSZXNwb25zZS5yZXBvc2l0b3JpZXMhWzBdPy5yZXBvc2l0b3J5VXJpO1xuICAgICAgaWYgKGV4aXN0aW5nUmVwb3NpdG9yeVVyaSkge1xuICAgICAgICByZXR1cm4geyByZXBvc2l0b3J5VXJpOiBleGlzdGluZ1JlcG9zaXRvcnlVcmkgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdSZXBvc2l0b3J5Tm90Rm91bmRFeGNlcHRpb24nKSB7IHRocm93IGU7IH1cbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGhlIHJlcG8gKHRhZyBpdCBzbyBpdCB3aWxsIGJlIGVhc2llciB0byBnYXJiYWdlIGNvbGxlY3QgaW4gdGhlIGZ1dHVyZSlcbiAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNyZWF0aW5nIEVDUiByZXBvc2l0b3J5YCk7XG4gICAgY29uc3QgYXNzZXRUYWcgPSB7IEtleTogJ2F3c2Nkazphc3NldCcsIFZhbHVlOiAndHJ1ZScgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjci5jcmVhdGVSZXBvc2l0b3J5KHsgcmVwb3NpdG9yeU5hbWUsIHRhZ3M6IFthc3NldFRhZ10gfSkucHJvbWlzZSgpO1xuICAgIGNvbnN0IHJlcG9zaXRvcnlVcmkgPSByZXNwb25zZS5yZXBvc2l0b3J5Py5yZXBvc2l0b3J5VXJpO1xuICAgIGlmICghcmVwb3NpdG9yeVVyaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDcmVhdGVSZXBvc2l0b3J5IGRpZCBub3QgcmV0dXJuIGEgcmVwb3NpdG9yeSBVUkkgZm9yICR7cmVwb3NpdG9yeVVyaX1gKTtcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmUgaW1hZ2Ugc2Nhbm5pbmcgb24gcHVzaCAoaGVscHMgaW4gaWRlbnRpZnlpbmcgc29mdHdhcmUgdnVsbmVyYWJpbGl0aWVzLCBubyBhZGRpdGlvbmFsIGNoYXJnZSlcbiAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGVuYWJsZSBpbWFnZSBzY2FubmluZ2ApO1xuICAgIGF3YWl0IGVjci5wdXRJbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvbih7IHJlcG9zaXRvcnlOYW1lLCBpbWFnZVNjYW5uaW5nQ29uZmlndXJhdGlvbjogeyBzY2FuT25QdXNoOiB0cnVlIH0gfSkucHJvbWlzZSgpO1xuXG4gICAgcmV0dXJuIHsgcmVwb3NpdG9yeVVyaSB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZXF1aXJlT3V0cHV0KG91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIShvdXRwdXQgaW4gdGhpcy5ib290c3RyYXBTdGFjay5vdXRwdXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgQ0RLIHRvb2xraXQgc3RhY2sgKCR7dGhpcy5ib290c3RyYXBTdGFjay5zdGFja05hbWV9KSBkb2VzIG5vdCBoYXZlIGFuIG91dHB1dCBuYW1lZCAke291dHB1dH0uIFVzZSAnY2RrIGJvb3RzdHJhcCcgdG8gY29ycmVjdCB0aGlzLmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay5vdXRwdXRzW291dHB1dF07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCB3aGVuIGEgYm9vdHN0cmFwIHN0YWNrIGNvdWxkIG5vdCBiZSBmb3VuZFxuICpcbiAqIFRoaXMgaXMgbm90IGFuIGVycm9yIGluIHByaW5jaXBsZSwgVU5USUwgb25lIG9mIHRoZSBtZW1iZXJzIGlzIGNhbGxlZCB0aGF0IHJlcXVpcmVzXG4gKiB0aGUgYm9vdHN0cmFwIHN0YWNrIHRvIGhhdmUgYmVlbiBmb3VuZCwgaW4gd2hpY2ggY2FzZSB0aGUgbG9va3VwIGVycm9yIGlzIHN0aWxsIHRocm93blxuICogYmVsYXRlZGx5LlxuICpcbiAqIFRoZSBlcnJvcnMgYmVsb3cgc2VydmUgYXMgYSBsYXN0IHN0b3AtZ2FwIG1lc3NhZ2UtLW5vcm1hbGx5IGNhbGxpbmcgY29kZSBzaG91bGQgaGF2ZVxuICogY2hlY2tlZCBgdG9vbGtpdC5mb3VuZGAgYW5kIHByb2R1Y2VkIGFuIGFwcHJvcHJpYXRlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmNsYXNzIEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvIGV4dGVuZHMgVG9vbGtpdEluZm8ge1xuICBwdWJsaWMgcmVhZG9ubHkgZm91bmQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihzZGs6IElTREssIHByaXZhdGUgcmVhZG9ubHkgZXJyb3JNZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzZGspO1xuICB9XG5cbiAgcHVibGljIGdldCBib290c3RyYXBTdGFjaygpOiBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXRVcmwoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXROYW1lKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmVyc2lvbigpOiBudW1iZXIge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhcmlhbnQoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHZhbGlkYXRlVmVyc2lvbihleHBlY3RlZFZlcnNpb246IG51bWJlciwgc3NtUGFyYW1ldGVyTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHNzbVBhcmFtZXRlck5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBsZXQgdmVyc2lvbjogbnVtYmVyO1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gYXdhaXQgVG9vbGtpdEluZm8udmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIodGhpcy5zZGssIHNzbVBhcmFtZXRlck5hbWUsIHRoaXMuc3NtQ2FjaGUpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ0FjY2Vzc0RlbmllZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuXG4gICAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2shIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdGhhdCBnb2VzIGFsb25nIHdpdGggdGhpcyBjaGFuZ2UgaW50cm9kdWNlc1xuICAgICAgLy8gYSBuZXcgJ3NzbTpHZXRQYXJhbWV0ZXInIHBlcm1pc3Npb24sIGJ1dCB3aGVuIHJ1biB1c2luZyBhIHByZXZpb3VzIGJvb3RzdHJhcCB0ZW1wbGF0ZSB3ZVxuICAgICAgLy8gd29uJ3QgaGF2ZSB0aGUgcGVybWlzc2lvbnMgeWV0IHRvIHJlYWQgdGhlIHZlcnNpb24sIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gc2hvdyB0aGVcbiAgICAgIC8vIG1lc3NhZ2UgdGVsbGluZyB0aGUgdXNlciB0aGV5IG5lZWQgdG8gdXBkYXRlISBXaGVuIHdlIHNlZSBhbiBBY2Nlc3NEZW5pZWRFeGNlcHRpb24sIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gdGhlIHZlcnNpb24gd2UgcmVhZCBmcm9tIFN0YWNrIE91dHB1dHMuXG4gICAgICB3YXJuaW5nKGBDb3VsZCBub3QgcmVhZCBTU00gcGFyYW1ldGVyICR7c3NtUGFyYW1ldGVyTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBkZXBsb3ltZW50IHJlcXVpcmVzIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke2V4cGVjdGVkVmVyc2lvbn0nLCBmb3VuZCBhbiBvbGRlciB2ZXJzaW9uLiBQbGVhc2UgcnVuICdjZGsgYm9vdHN0cmFwJy5gKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRWZXJzaW9uID4gdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIENESyBkZXBsb3ltZW50IHJlcXVpcmVzIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke2V4cGVjdGVkVmVyc2lvbn0nLCBmb3VuZCAnJHt2ZXJzaW9ufScuIFBsZWFzZSBydW4gJ2NkayBib290c3RyYXAnLmApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwcmVwYXJlRWNyUmVwb3NpdG9yeSgpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjclJlcG9zaXRvcnlJbmZvIHtcbiAgcmVwb3NpdG9yeVVyaTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVjckNyZWRlbnRpYWxzIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgZW5kcG9pbnQ6IHN0cmluZztcbn1cbiJdfQ==
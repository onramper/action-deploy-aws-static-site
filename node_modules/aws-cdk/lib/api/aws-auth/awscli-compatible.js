"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const util = require("util");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const logging_1 = require("../../logging");
const sdk_ini_file_1 = require("./sdk_ini_file");
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * This is similar to the default credential provider chain created by the SDK
     * except:
     *
     * 1. Accepts profile argument in the constructor (the SDK must have it prepopulated
     *    in the environment).
     * 2. Conditionally checks EC2 credentials, because checking for EC2
     *    credentials on a non-EC2 machine may lead to long delays (in the best case)
     *    or an exception (in the worst case).
     * 3. Respects $AWS_SHARED_CREDENTIALS_FILE.
     * 4. Respects $AWS_DEFAULT_PROFILE in addition to $AWS_PROFILE.
     */
    static async credentialChain(profile, ec2creds, containerCreds, httpOptions) {
        await forceSdkToReadConfigIfPresent();
        profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const sources = [
            () => new AWS.EnvironmentCredentials('AWS'),
            () => new AWS.EnvironmentCredentials('AMAZON'),
        ];
        if (await fs.pathExists(credentialsFileName())) {
            sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename: credentialsFileName(), httpOptions }));
        }
        if (await fs.pathExists(configFileName())) {
            sources.push(() => new AWS.SharedIniFileCredentials({ profile, filename: credentialsFileName(), httpOptions }));
        }
        if (containerCreds !== null && containerCreds !== void 0 ? containerCreds : hasEcsCredentials()) {
            sources.push(() => new AWS.ECSCredentials());
        }
        else if (ec2creds !== null && ec2creds !== void 0 ? ec2creds : await hasEc2Credentials()) {
            // else if: don't get EC2 creds if we should have gotten ECS creds--ECS instances also
            // run on EC2 boxes but the creds represent something different. Same behavior as
            // upstream code.
            sources.push(() => new AWS.EC2MetadataCredentials());
        }
        return new AWS.CredentialProviderChain(sources);
    }
    /**
     * Return the default region in a CLI-compatible way
     *
     * Mostly copied from node_loader.js, but with the following differences to make it
     * AWS CLI compatible:
     *
     * 1. Takes a profile name as an argument (instead of forcing it to be taken from $AWS_PROFILE).
     *    This requires having made a copy of the SDK's `SharedIniFile` (the original
     *    does not take an argument).
     * 2. $AWS_DEFAULT_PROFILE and $AWS_DEFAULT_REGION are also respected.
     *
     * Lambda and CodeBuild set the $AWS_REGION variable.
     *
     * FIXME: EC2 instances require querying the metadata service to determine the current region.
     */
    static async region(profile) {
        profile = profile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        // Defaults inside constructor
        const toCheck = [
            { filename: credentialsFileName(), profile },
            { isConfig: true, filename: configFileName(), profile },
            { isConfig: true, filename: configFileName(), profile: 'default' },
        ];
        let region = process.env.AWS_REGION || process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION || process.env.AMAZON_DEFAULT_REGION;
        while (!region && toCheck.length > 0) {
            const options = toCheck.shift();
            if (await fs.pathExists(options.filename)) {
                const configFile = new sdk_ini_file_1.SharedIniFile(options);
                const section = await configFile.getProfile(options.profile);
                region = section === null || section === void 0 ? void 0 : section.region;
            }
        }
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            region = 'us-east-1'; // This is what the AWS CLI does
            logging_1.debug(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${region}'`);
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Return whether it looks like we'll have ECS credentials available
 */
function hasEcsCredentials() {
    return AWS.ECSCredentials.prototype.isConfiguredForEcsCredentials();
}
/**
 * Return whether we're on an EC2 instance
 */
async function hasEc2Credentials() {
    logging_1.debug("Determining whether we're on an EC2 instance.");
    let instance = false;
    if (process.platform === 'win32') {
        // https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/identify_ec2_instances.html
        const result = await util.promisify(child_process.exec)('wmic path win32_computersystemproduct get uuid', { encoding: 'utf-8' });
        // output looks like
        //  UUID
        //  EC2AE145-D1DC-13B2-94ED-01234ABCDEF
        const lines = result.stdout.toString().split('\n');
        instance = lines.some(x => matchesRegex(/^ec2/i, x));
    }
    else {
        // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/identify_ec2_instances.html
        const files = [
            // This recognizes the Xen hypervisor based instances (pre-5th gen)
            ['/sys/hypervisor/uuid', /^ec2/i],
            // This recognizes the new Hypervisor (5th-gen instances and higher)
            // Can't use the advertised file '/sys/devices/virtual/dmi/id/product_uuid' because it requires root to read.
            // Instead, sys_vendor contains something like 'Amazon EC2'.
            ['/sys/devices/virtual/dmi/id/sys_vendor', /ec2/i],
        ];
        for (const [file, re] of files) {
            if (matchesRegex(re, readIfPossible(file))) {
                instance = true;
                break;
            }
        }
    }
    logging_1.debug(instance ? 'Looks like EC2 instance.' : 'Does not look like EC2 instance.');
    return instance;
}
function homeDir() {
    return process.env.HOME || process.env.USERPROFILE
        || (process.env.HOMEPATH ? ((process.env.HOMEDRIVE || 'C:/') + process.env.HOMEPATH) : null) || os.homedir();
}
function credentialsFileName() {
    return process.env.AWS_SHARED_CREDENTIALS_FILE || path.join(homeDir(), '.aws', 'credentials');
}
function configFileName() {
    return process.env.AWS_CONFIG_FILE || path.join(homeDir(), '.aws', 'config');
}
/**
 * Force the JS SDK to honor the ~/.aws/config file (and various settings therein)
 *
 * For example, ther is just *NO* way to do AssumeRole credentials as long as AWS_SDK_LOAD_CONFIG is not set,
 * or read credentials from that file.
 *
 * The SDK crashes if the variable is set but the file does not exist, so conditionally set it.
 */
async function forceSdkToReadConfigIfPresent() {
    if (await fs.pathExists(configFileName())) {
        process.env.AWS_SDK_LOAD_CONFIG = '1';
    }
}
function matchesRegex(re, s) {
    return s !== undefined && re.exec(s) !== null;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwyQ0FBc0M7QUFDdEMsaURBQStDO0FBRS9DOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLGdCQUFnQjtJQUMzQjs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQ2pDLE9BQTJCLEVBQzNCLFFBQTZCLEVBQzdCLGNBQW1DLEVBQ25DLFdBQXdDO1FBQ3hDLE1BQU0sNkJBQTZCLEVBQUUsQ0FBQztRQUV0QyxPQUFPLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLElBQUksU0FBUyxDQUFDO1FBRTdGLE1BQU0sT0FBTyxHQUFHO1lBQ2QsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDO1lBQzNDLEdBQUcsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQztTQUMvQyxDQUFDO1FBRUYsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxFQUFFO1lBQzlDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsd0JBQXdCLENBQUMsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2pIO1FBRUQsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRTtZQUN6QyxPQUFPLENBQUMs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QUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxTQUFTLENBQUM7U0FBRTtRQUN2RCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FDekQ7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLGVBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNULE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBTaGFyZWRJbmlGaWxlIH0gZnJvbSAnLi9zZGtfaW5pX2ZpbGUnO1xuXG4vKipcbiAqIEJlaGF2aW9ycyB0byBtYXRjaCBBV1MgQ0xJXG4gKlxuICogU2VlIHRoZXNlIGxpbmtzOlxuICpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3RvcGljL2NvbmZpZy12YXJzLmh0bWxcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jbGkvbGF0ZXN0L3VzZXJndWlkZS9jbGktY29uZmlndXJlLWVudnZhcnMuaHRtbFxuICovXG5leHBvcnQgY2xhc3MgQXdzQ2xpQ29tcGF0aWJsZSB7XG4gIC8qKlxuICAgKiBCdWlsZCBhbiBBV1MgQ0xJLWNvbXBhdGlibGUgY3JlZGVudGlhbCBjaGFpbiBwcm92aWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiBjcmVhdGVkIGJ5IHRoZSBTREtcbiAgICogZXhjZXB0OlxuICAgKlxuICAgKiAxLiBBY2NlcHRzIHByb2ZpbGUgYXJndW1lbnQgaW4gdGhlIGNvbnN0cnVjdG9yICh0aGUgU0RLIG11c3QgaGF2ZSBpdCBwcmVwb3B1bGF0ZWRcbiAgICogICAgaW4gdGhlIGVudmlyb25tZW50KS5cbiAgICogMi4gQ29uZGl0aW9uYWxseSBjaGVja3MgRUMyIGNyZWRlbnRpYWxzLCBiZWNhdXNlIGNoZWNraW5nIGZvciBFQzJcbiAgICogICAgY3JlZGVudGlhbHMgb24gYSBub24tRUMyIG1hY2hpbmUgbWF5IGxlYWQgdG8gbG9uZyBkZWxheXMgKGluIHRoZSBiZXN0IGNhc2UpXG4gICAqICAgIG9yIGFuIGV4Y2VwdGlvbiAoaW4gdGhlIHdvcnN0IGNhc2UpLlxuICAgKiAzLiBSZXNwZWN0cyAkQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFLlxuICAgKiA0LiBSZXNwZWN0cyAkQVdTX0RFRkFVTFRfUFJPRklMRSBpbiBhZGRpdGlvbiB0byAkQVdTX1BST0ZJTEUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWRlbnRpYWxDaGFpbihcbiAgICBwcm9maWxlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZWMyY3JlZHM6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gICAgY29udGFpbmVyQ3JlZHM6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gICAgaHR0cE9wdGlvbnM6IEFXUy5IVFRQT3B0aW9ucyB8IHVuZGVmaW5lZCkge1xuICAgIGF3YWl0IGZvcmNlU2RrVG9SZWFkQ29uZmlnSWZQcmVzZW50KCk7XG5cbiAgICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgIGNvbnN0IHNvdXJjZXMgPSBbXG4gICAgICAoKSA9PiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpLFxuICAgICAgKCkgPT4gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBTUFaT04nKSxcbiAgICBdO1xuXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoY3JlZGVudGlhbHNGaWxlTmFtZSgpKSkge1xuICAgICAgc291cmNlcy5wdXNoKCgpID0+IG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKHsgcHJvZmlsZSwgZmlsZW5hbWU6IGNyZWRlbnRpYWxzRmlsZU5hbWUoKSwgaHR0cE9wdGlvbnMgfSkpO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGNvbmZpZ0ZpbGVOYW1lKCkpKSB7XG4gICAgICBzb3VyY2VzLnB1c2goKCkgPT4gbmV3IEFXUy5TaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMoeyBwcm9maWxlLCBmaWxlbmFtZTogY3JlZGVudGlhbHNGaWxlTmFtZSgpLCBodHRwT3B0aW9ucyB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lckNyZWRzID8/IGhhc0Vjc0NyZWRlbnRpYWxzKCkpIHtcbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCkpO1xuICAgIH0gZWxzZSBpZiAoZWMyY3JlZHMgPz8gYXdhaXQgaGFzRWMyQ3JlZGVudGlhbHMoKSkge1xuICAgICAgLy8gZWxzZSBpZjogZG9uJ3QgZ2V0IEVDMiBjcmVkcyBpZiB3ZSBzaG91bGQgaGF2ZSBnb3R0ZW4gRUNTIGNyZWRzLS1FQ1MgaW5zdGFuY2VzIGFsc29cbiAgICAgIC8vIHJ1biBvbiBFQzIgYm94ZXMgYnV0IHRoZSBjcmVkcyByZXByZXNlbnQgc29tZXRoaW5nIGRpZmZlcmVudC4gU2FtZSBiZWhhdmlvciBhc1xuICAgICAgLy8gdXBzdHJlYW0gY29kZS5cbiAgICAgIHNvdXJjZXMucHVzaCgoKSA9PiBuZXcgQVdTLkVDMk1ldGFkYXRhQ3JlZGVudGlhbHMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oc291cmNlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZWZhdWx0IHJlZ2lvbiBpbiBhIENMSS1jb21wYXRpYmxlIHdheVxuICAgKlxuICAgKiBNb3N0bHkgY29waWVkIGZyb20gbm9kZV9sb2FkZXIuanMsIGJ1dCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXMgdG8gbWFrZSBpdFxuICAgKiBBV1MgQ0xJIGNvbXBhdGlibGU6XG4gICAqXG4gICAqIDEuIFRha2VzIGEgcHJvZmlsZSBuYW1lIGFzIGFuIGFyZ3VtZW50IChpbnN0ZWFkIG9mIGZvcmNpbmcgaXQgdG8gYmUgdGFrZW4gZnJvbSAkQVdTX1BST0ZJTEUpLlxuICAgKiAgICBUaGlzIHJlcXVpcmVzIGhhdmluZyBtYWRlIGEgY29weSBvZiB0aGUgU0RLJ3MgYFNoYXJlZEluaUZpbGVgICh0aGUgb3JpZ2luYWxcbiAgICogICAgZG9lcyBub3QgdGFrZSBhbiBhcmd1bWVudCkuXG4gICAqIDIuICRBV1NfREVGQVVMVF9QUk9GSUxFIGFuZCAkQVdTX0RFRkFVTFRfUkVHSU9OIGFyZSBhbHNvIHJlc3BlY3RlZC5cbiAgICpcbiAgICogTGFtYmRhIGFuZCBDb2RlQnVpbGQgc2V0IHRoZSAkQVdTX1JFR0lPTiB2YXJpYWJsZS5cbiAgICpcbiAgICogRklYTUU6IEVDMiBpbnN0YW5jZXMgcmVxdWlyZSBxdWVyeWluZyB0aGUgbWV0YWRhdGEgc2VydmljZSB0byBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgcmVnaW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyByZWdpb24ocHJvZmlsZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBwcm9maWxlID0gcHJvZmlsZSB8fCBwcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9QUk9GSUxFIHx8ICdkZWZhdWx0JztcblxuICAgIC8vIERlZmF1bHRzIGluc2lkZSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IHRvQ2hlY2sgPSBbXG4gICAgICB7IGZpbGVuYW1lOiBjcmVkZW50aWFsc0ZpbGVOYW1lKCksIHByb2ZpbGUgfSxcbiAgICAgIHsgaXNDb25maWc6IHRydWUsIGZpbGVuYW1lOiBjb25maWdGaWxlTmFtZSgpLCBwcm9maWxlIH0sXG4gICAgICB7IGlzQ29uZmlnOiB0cnVlLCBmaWxlbmFtZTogY29uZmlnRmlsZU5hbWUoKSwgcHJvZmlsZTogJ2RlZmF1bHQnIH0sXG4gICAgXTtcblxuICAgIGxldCByZWdpb24gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9SRUdJT04gfHxcbiAgICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fCBwcm9jZXNzLmVudi5BTUFaT05fREVGQVVMVF9SRUdJT047XG5cbiAgICB3aGlsZSAoIXJlZ2lvbiAmJiB0b0NoZWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0b0NoZWNrLnNoaWZ0KCkhO1xuICAgICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMob3B0aW9ucy5maWxlbmFtZSkpIHtcbiAgICAgICAgY29uc3QgY29uZmlnRmlsZSA9IG5ldyBTaGFyZWRJbmlGaWxlKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gYXdhaXQgY29uZmlnRmlsZS5nZXRQcm9maWxlKG9wdGlvbnMucHJvZmlsZSk7XG4gICAgICAgIHJlZ2lvbiA9IHNlY3Rpb24/LnJlZ2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgY29uc3QgdXNlZFByb2ZpbGUgPSAhcHJvZmlsZSA/ICcnIDogYCAocHJvZmlsZTogXCIke3Byb2ZpbGV9XCIpYDtcbiAgICAgIHJlZ2lvbiA9ICd1cy1lYXN0LTEnOyAvLyBUaGlzIGlzIHdoYXQgdGhlIEFXUyBDTEkgZG9lc1xuICAgICAgZGVidWcoYFVuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJlZ2lvbiBmcm9tIGVudmlyb25tZW50IG9yIEFXUyBjb25maWd1cmF0aW9uJHt1c2VkUHJvZmlsZX0sIGRlZmF1bHRpbmcgdG8gJyR7cmVnaW9ufSdgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaW9uO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgaXQgbG9va3MgbGlrZSB3ZSdsbCBoYXZlIEVDUyBjcmVkZW50aWFscyBhdmFpbGFibGVcbiAqL1xuZnVuY3Rpb24gaGFzRWNzQ3JlZGVudGlhbHMoKTogYm9vbGVhbiB7XG4gIHJldHVybiAoQVdTLkVDU0NyZWRlbnRpYWxzLnByb3RvdHlwZSBhcyBhbnkpLmlzQ29uZmlndXJlZEZvckVjc0NyZWRlbnRpYWxzKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgd2UncmUgb24gYW4gRUMyIGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0VjMkNyZWRlbnRpYWxzKCkge1xuICBkZWJ1ZyhcIkRldGVybWluaW5nIHdoZXRoZXIgd2UncmUgb24gYW4gRUMyIGluc3RhbmNlLlwiKTtcblxuICBsZXQgaW5zdGFuY2UgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTRUMyL2xhdGVzdC9XaW5kb3dzR3VpZGUvaWRlbnRpZnlfZWMyX2luc3RhbmNlcy5odG1sXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXRpbC5wcm9taXNpZnkoY2hpbGRfcHJvY2Vzcy5leGVjKSgnd21pYyBwYXRoIHdpbjMyX2NvbXB1dGVyc3lzdGVtcHJvZHVjdCBnZXQgdXVpZCcsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgLy8gb3V0cHV0IGxvb2tzIGxpa2VcbiAgICAvLyAgVVVJRFxuICAgIC8vICBFQzJBRTE0NS1EMURDLTEzQjItOTRFRC0wMTIzNEFCQ0RFRlxuICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0LnN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBpbnN0YW5jZSA9IGxpbmVzLnNvbWUoeCA9PiBtYXRjaGVzUmVnZXgoL15lYzIvaSwgeCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NFQzIvbGF0ZXN0L1VzZXJHdWlkZS9pZGVudGlmeV9lYzJfaW5zdGFuY2VzLmh0bWxcbiAgICBjb25zdCBmaWxlczogQXJyYXk8W3N0cmluZywgUmVnRXhwXT4gPSBbXG4gICAgICAvLyBUaGlzIHJlY29nbml6ZXMgdGhlIFhlbiBoeXBlcnZpc29yIGJhc2VkIGluc3RhbmNlcyAocHJlLTV0aCBnZW4pXG4gICAgICBbJy9zeXMvaHlwZXJ2aXNvci91dWlkJywgL15lYzIvaV0sXG5cbiAgICAgIC8vIFRoaXMgcmVjb2duaXplcyB0aGUgbmV3IEh5cGVydmlzb3IgKDV0aC1nZW4gaW5zdGFuY2VzIGFuZCBoaWdoZXIpXG4gICAgICAvLyBDYW4ndCB1c2UgdGhlIGFkdmVydGlzZWQgZmlsZSAnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfdXVpZCcgYmVjYXVzZSBpdCByZXF1aXJlcyByb290IHRvIHJlYWQuXG4gICAgICAvLyBJbnN0ZWFkLCBzeXNfdmVuZG9yIGNvbnRhaW5zIHNvbWV0aGluZyBsaWtlICdBbWF6b24gRUMyJy5cbiAgICAgIFsnL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3N5c192ZW5kb3InLCAvZWMyL2ldLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBbZmlsZSwgcmVdIG9mIGZpbGVzKSB7XG4gICAgICBpZiAobWF0Y2hlc1JlZ2V4KHJlLCByZWFkSWZQb3NzaWJsZShmaWxlKSkpIHtcbiAgICAgICAgaW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWJ1ZyhpbnN0YW5jZSA/ICdMb29rcyBsaWtlIEVDMiBpbnN0YW5jZS4nIDogJ0RvZXMgbm90IGxvb2sgbGlrZSBFQzIgaW5zdGFuY2UuJyk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gaG9tZURpcigpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkhPTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEVcbiAgICB8fCAocHJvY2Vzcy5lbnYuSE9NRVBBVEggPyAoKHByb2Nlc3MuZW52LkhPTUVEUklWRSB8fCAnQzovJykgKyBwcm9jZXNzLmVudi5IT01FUEFUSCkgOiBudWxsKSB8fCBvcy5ob21lZGlyKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWRlbnRpYWxzRmlsZU5hbWUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5BV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUgfHwgcGF0aC5qb2luKGhvbWVEaXIoKSwgJy5hd3MnLCAnY3JlZGVudGlhbHMnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRmlsZU5hbWUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEUgfHwgcGF0aC5qb2luKGhvbWVEaXIoKSwgJy5hd3MnLCAnY29uZmlnJyk7XG59XG5cbi8qKlxuICogRm9yY2UgdGhlIEpTIFNESyB0byBob25vciB0aGUgfi8uYXdzL2NvbmZpZyBmaWxlIChhbmQgdmFyaW91cyBzZXR0aW5ncyB0aGVyZWluKVxuICpcbiAqIEZvciBleGFtcGxlLCB0aGVyIGlzIGp1c3QgKk5PKiB3YXkgdG8gZG8gQXNzdW1lUm9sZSBjcmVkZW50aWFscyBhcyBsb25nIGFzIEFXU19TREtfTE9BRF9DT05GSUcgaXMgbm90IHNldCxcbiAqIG9yIHJlYWQgY3JlZGVudGlhbHMgZnJvbSB0aGF0IGZpbGUuXG4gKlxuICogVGhlIFNESyBjcmFzaGVzIGlmIHRoZSB2YXJpYWJsZSBpcyBzZXQgYnV0IHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCBzbyBjb25kaXRpb25hbGx5IHNldCBpdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZm9yY2VTZGtUb1JlYWRDb25maWdJZlByZXNlbnQoKSB7XG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGNvbmZpZ0ZpbGVOYW1lKCkpKSB7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NES19MT0FEX0NPTkZJRyA9ICcxJztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzUmVnZXgocmU6IFJlZ0V4cCwgczogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIHJldHVybiBzICE9PSB1bmRlZmluZWQgJiYgcmUuZXhlYyhzKSAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWFkIGEgZmlsZSBpZiBpdCBleGlzdHMsIG9yIHJldHVybiB1bmRlZmluZWRcbiAqXG4gKiBOb3QgYXN5bmMgYmVjYXVzZSBpdCBpcyB1c2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiByZWFkSWZQb3NzaWJsZShmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWZzLnBhdGhFeGlzdHNTeW5jKGZpbGVuYW1lKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKGUpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0iXX0=
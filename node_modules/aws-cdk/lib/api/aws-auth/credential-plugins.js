"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialPlugins = void 0;
const _env_1 = require("./_env");
const logging_1 = require("../../logging");
const plugin_1 = require("../plugin");
/**
 * Cache for credential providers.
 *
 * Given an account and an operating mode (read or write) will return an
 * appropriate credential provider for credentials for the given account. The
 * credential provider will be cached so that multiple AWS clients for the same
 * environment will not make multiple network calls to obtain credentials.
 *
 * Will use default credentials if they are for the right account; otherwise,
 * all loaded credential provider plugins will be tried to obtain credentials
 * for the given account.
 */
class CredentialPlugins {
    constructor() {
        this.cache = {};
    }
    async fetchCredentialsFor(awsAccountId, mode) {
        const key = `${awsAccountId}-${mode}`;
        if (!(key in this.cache)) {
            this.cache[key] = await this.lookupCredentials(awsAccountId, mode);
        }
        return this.cache[key];
    }
    get availablePluginNames() {
        return plugin_1.PluginHost.instance.credentialProviderSources.map(s => s.name);
    }
    async lookupCredentials(awsAccountId, mode) {
        const triedSources = [];
        // Otherwise, inspect the various credential sources we have
        for (const source of plugin_1.PluginHost.instance.credentialProviderSources) {
            let available;
            try {
                available = await source.isAvailable();
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${e.message}`);
                available = false;
            }
            if (!available) {
                (0, _env_1.debug)('Credentials source %s is not available, ignoring it.', source.name);
                continue;
            }
            triedSources.push(source);
            let canProvide;
            try {
                canProvide = await source.canProvideCredentials(awsAccountId);
            }
            catch (e) {
                // This shouldn't happen, but let's guard against it anyway
                (0, logging_1.warning)(`Uncaught exception in ${source.name}: ${e.message}`);
                canProvide = false;
            }
            if (!canProvide) {
                continue;
            }
            (0, _env_1.debug)(`Using ${source.name} credentials for account ${awsAccountId}`);
            const providerOrCreds = await source.getProvider(awsAccountId, mode);
            // Backwards compatibility: if the plugin returns a ProviderChain, resolve that chain.
            // Otherwise it must have returned credentials.
            const credentials = providerOrCreds.resolvePromise ? await providerOrCreds.resolvePromise() : providerOrCreds;
            return { credentials, pluginName: source.name };
        }
        return undefined;
    }
}
exports.CredentialPlugins = CredentialPlugins;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlZGVudGlhbC1wbHVnaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY3JlZGVudGlhbC1wbHVnaW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUErQjtBQUUvQiwyQ0FBd0M7QUFDeEMsc0NBQWlFO0FBRWpFOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBYSxpQkFBaUI7SUFBOUI7UUFDbUIsVUFBSyxHQUFtRCxFQUFFLENBQUM7SUFvRDlFLENBQUM7SUFsRFEsS0FBSyxDQUFDLG1CQUFtQixDQUFDLFlBQW9CLEVBQUUsSUFBVTtRQUMvRCxNQUFNLEdBQUcsR0FBRyxHQUFHLFlBQVksSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxJQUFXLG9CQUFvQjtRQUM3QixPQUFPLG1CQUFVLENBQUMsUUFBUSxDQUFDLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLFlBQW9CLEVBQUUsSUFBVTtRQUM5RCxNQUFNLFlBQVksR0FBK0IsRUFBRSxDQUFDO1FBQ3BELDREQUE0RDtRQUM1RCxLQUFLLE1BQU0sTUFBTSxJQUFJLG1CQUFVLENBQUMsUUFBUSxDQUFDLHlCQUF5QixFQUFFO1lBQ2xFLElBQUksU0FBa0IsQ0FBQztZQUN2QixJQUFJO2dCQUNGLFNBQVMsR0FBRyxNQUFNLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUN4QztZQUFDLE9BQU8sQ0FBTSxFQUFFO2dCQUNmLDJEQUEyRDtnQkFDM0QsSUFBQSxpQkFBTyxFQUFDLHlCQUF5QixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUM5RCxTQUFTLEdBQUcsS0FBSyxDQUFDO2FBQ25CO1lBRUQsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDZCxJQUFBLFlBQUssRUFBQyxzREFBc0QsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzNFLFNBQVM7YUFDVjtZQUNELFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUIsSUFBSSxVQUFtQixDQUFDO1lBQ3hCLElBQUk7Z0JBQ0YsVUFBVSxHQUFHLE1BQU0sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQy9EO1lBQUMsT0FBTyxDQUFNLEVBQUU7Z0JBQ2YsMkRBQTJEO2dCQUMzRCxJQUFBLGlCQUFPLEVBQUMseUJBQXlCLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBQzlELFVBQVUsR0FBRyxLQUFLLENBQUM7YUFDcEI7WUFDRCxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUFFLFNBQVM7YUFBRTtZQUM5QixJQUFBLFlBQUssRUFBQyxTQUFTLE1BQU0sQ0FBQyxJQUFJLDRCQUE0QixZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLE1BQU0sZUFBZSxHQUFHLE1BQU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFckUsc0ZBQXNGO1lBQ3RGLCtDQUErQztZQUMvQyxNQUFNLFdBQVcsR0FBSSxlQUF1QixDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTyxlQUF1QixDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7WUFFaEksT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2pEO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBckRELDhDQXFEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9fZW52JztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZSwgUGx1Z2luSG9zdCB9IGZyb20gJy4uL3BsdWdpbic7XG5cbi8qKlxuICogQ2FjaGUgZm9yIGNyZWRlbnRpYWwgcHJvdmlkZXJzLlxuICpcbiAqIEdpdmVuIGFuIGFjY291bnQgYW5kIGFuIG9wZXJhdGluZyBtb2RlIChyZWFkIG9yIHdyaXRlKSB3aWxsIHJldHVybiBhblxuICogYXBwcm9wcmlhdGUgY3JlZGVudGlhbCBwcm92aWRlciBmb3IgY3JlZGVudGlhbHMgZm9yIHRoZSBnaXZlbiBhY2NvdW50LiBUaGVcbiAqIGNyZWRlbnRpYWwgcHJvdmlkZXIgd2lsbCBiZSBjYWNoZWQgc28gdGhhdCBtdWx0aXBsZSBBV1MgY2xpZW50cyBmb3IgdGhlIHNhbWVcbiAqIGVudmlyb25tZW50IHdpbGwgbm90IG1ha2UgbXVsdGlwbGUgbmV0d29yayBjYWxscyB0byBvYnRhaW4gY3JlZGVudGlhbHMuXG4gKlxuICogV2lsbCB1c2UgZGVmYXVsdCBjcmVkZW50aWFscyBpZiB0aGV5IGFyZSBmb3IgdGhlIHJpZ2h0IGFjY291bnQ7IG90aGVyd2lzZSxcbiAqIGFsbCBsb2FkZWQgY3JlZGVudGlhbCBwcm92aWRlciBwbHVnaW5zIHdpbGwgYmUgdHJpZWQgdG8gb2J0YWluIGNyZWRlbnRpYWxzXG4gKiBmb3IgdGhlIGdpdmVuIGFjY291bnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsUGx1Z2lucyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGU6IHtba2V5OiBzdHJpbmddOiBQbHVnaW5DcmVkZW50aWFscyB8IHVuZGVmaW5lZH0gPSB7fTtcblxuICBwdWJsaWMgYXN5bmMgZmV0Y2hDcmVkZW50aWFsc0Zvcihhd3NBY2NvdW50SWQ6IHN0cmluZywgbW9kZTogTW9kZSk6IFByb21pc2U8UGx1Z2luQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBrZXkgPSBgJHthd3NBY2NvdW50SWR9LSR7bW9kZX1gO1xuICAgIGlmICghKGtleSBpbiB0aGlzLmNhY2hlKSkge1xuICAgICAgdGhpcy5jYWNoZVtrZXldID0gYXdhaXQgdGhpcy5sb29rdXBDcmVkZW50aWFscyhhd3NBY2NvdW50SWQsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICB9XG5cbiAgcHVibGljIGdldCBhdmFpbGFibGVQbHVnaW5OYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5tYXAocyA9PiBzLm5hbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb29rdXBDcmVkZW50aWFscyhhd3NBY2NvdW50SWQ6IHN0cmluZywgbW9kZTogTW9kZSk6IFByb21pc2U8UGx1Z2luQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCB0cmllZFNvdXJjZXM6IENyZWRlbnRpYWxQcm92aWRlclNvdXJjZVtdID0gW107XG4gICAgLy8gT3RoZXJ3aXNlLCBpbnNwZWN0IHRoZSB2YXJpb3VzIGNyZWRlbnRpYWwgc291cmNlcyB3ZSBoYXZlXG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgUGx1Z2luSG9zdC5pbnN0YW5jZS5jcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzKSB7XG4gICAgICBsZXQgYXZhaWxhYmxlOiBib29sZWFuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXZhaWxhYmxlID0gYXdhaXQgc291cmNlLmlzQXZhaWxhYmxlKCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgbGV0J3MgZ3VhcmQgYWdhaW5zdCBpdCBhbnl3YXlcbiAgICAgICAgd2FybmluZyhgVW5jYXVnaHQgZXhjZXB0aW9uIGluICR7c291cmNlLm5hbWV9OiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXZhaWxhYmxlKSB7XG4gICAgICAgIGRlYnVnKCdDcmVkZW50aWFscyBzb3VyY2UgJXMgaXMgbm90IGF2YWlsYWJsZSwgaWdub3JpbmcgaXQuJywgc291cmNlLm5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyaWVkU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICBsZXQgY2FuUHJvdmlkZTogYm9vbGVhbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhblByb3ZpZGUgPSBhd2FpdCBzb3VyY2UuY2FuUHJvdmlkZUNyZWRlbnRpYWxzKGF3c0FjY291bnRJZCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgbGV0J3MgZ3VhcmQgYWdhaW5zdCBpdCBhbnl3YXlcbiAgICAgICAgd2FybmluZyhgVW5jYXVnaHQgZXhjZXB0aW9uIGluICR7c291cmNlLm5hbWV9OiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgY2FuUHJvdmlkZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFjYW5Qcm92aWRlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBkZWJ1ZyhgVXNpbmcgJHtzb3VyY2UubmFtZX0gY3JlZGVudGlhbHMgZm9yIGFjY291bnQgJHthd3NBY2NvdW50SWR9YCk7XG4gICAgICBjb25zdCBwcm92aWRlck9yQ3JlZHMgPSBhd2FpdCBzb3VyY2UuZ2V0UHJvdmlkZXIoYXdzQWNjb3VudElkLCBtb2RlKTtcblxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIHRoZSBwbHVnaW4gcmV0dXJucyBhIFByb3ZpZGVyQ2hhaW4sIHJlc29sdmUgdGhhdCBjaGFpbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpdCBtdXN0IGhhdmUgcmV0dXJuZWQgY3JlZGVudGlhbHMuXG4gICAgICBjb25zdCBjcmVkZW50aWFscyA9IChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSA/IGF3YWl0IChwcm92aWRlck9yQ3JlZHMgYXMgYW55KS5yZXNvbHZlUHJvbWlzZSgpIDogcHJvdmlkZXJPckNyZWRzO1xuXG4gICAgICByZXR1cm4geyBjcmVkZW50aWFscywgcGx1Z2luTmFtZTogc291cmNlLm5hbWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpbkNyZWRlbnRpYWxzIHtcbiAgcmVhZG9ubHkgY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFscztcbiAgcmVhZG9ubHkgcGx1Z2luTmFtZTogc3RyaW5nO1xufVxuIl19
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const credentials_1 = require("../api/aws-auth/credentials");
const logging_1 = require("../logging");
class KeyContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const account = args.account;
        const region = args.region;
        const options = { assumeRoleArn: args.lookupRoleArn };
        const kms = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(account, region), credentials_1.Mode.ForReading, options)).sdk.kms();
        const aliasListEntry = await this.findKey(kms, args);
        return this.readKeyProps(aliasListEntry, args);
    }
    async findKey(kms, args) {
        (0, logging_1.debug)(`Listing keys in ${args.account}:${args.region}`);
        let response;
        let nextMarker;
        do {
            response = await kms.listAliases({
                Marker: nextMarker,
            }).promise();
            const aliases = response.Aliases || [];
            for (const alias of aliases) {
                if (alias.AliasName == args.aliasName) {
                    return alias;
                }
            }
            nextMarker = response.NextMarker;
        } while (response.Truncated);
        throw new Error(`Could not find any key with alias named ${args.aliasName}`);
    }
    async readKeyProps(alias, args) {
        if (!alias.TargetKeyId) {
            throw new Error(`Could not find any key with alias named ${args.aliasName}`);
        }
        (0, logging_1.debug)(`Key found ${alias.TargetKeyId}`);
        return {
            keyId: alias.TargetKeyId,
        };
    }
}
exports.KeyContextProviderPlugin = KeyContextProviderPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImtleXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EseUNBQXlDO0FBR3pDLDZEQUFtRDtBQUduRCx3Q0FBbUM7QUFFbkMsTUFBYSx3QkFBd0I7SUFFbkMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUE4QjtRQUNsRCxNQUFNLE9BQU8sR0FBVyxJQUFJLENBQUMsT0FBUSxDQUFDO1FBQ3RDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxNQUFPLENBQUM7UUFFcEMsTUFBTSxPQUFPLEdBQUcsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3RELE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRSxrQkFBSSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUU5SCxNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXJELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBWSxFQUFFLElBQThCO1FBRWhFLElBQUEsZUFBSyxFQUFDLG1CQUFtQixJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBRXhELElBQUksUUFBa0UsQ0FBQztRQUN2RSxJQUFJLFVBQThCLENBQUM7UUFDbkMsR0FBRztZQUNELFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxXQUFXLENBQUM7Z0JBQy9CLE1BQU0sRUFBRSxVQUFVO2FBQ25CLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUViLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO1lBQ3ZDLEtBQUssTUFBTSxLQUFLLElBQUksT0FBTyxFQUFFO2dCQUMzQixJQUFJLEtBQUssQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtvQkFDckMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7YUFDRjtZQUVELFVBQVUsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1NBQ2xDLFFBQVEsUUFBUSxDQUFDLFNBQVMsRUFBRTtRQUU3QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUE2QixFQUFFLElBQThCO1FBQ3RGLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFO1lBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsSUFBQSxlQUFLLEVBQUMsYUFBYSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUV4QyxPQUFPO1lBQ0wsS0FBSyxFQUFFLEtBQUssQ0FBQyxXQUFXO1NBQ3pCLENBQUM7SUFDSixDQUFDO0NBRUY7QUFyREQsNERBcURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBQcm9taXNlUmVzdWx0IH0gZnJvbSAnYXdzLXNkay9saWIvcmVxdWVzdCc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFZhbHVlKGFyZ3M6IGN4c2NoZW1hLktleUNvbnRleHRRdWVyeSkge1xuICAgIGNvbnN0IGFjY291bnQ6IHN0cmluZyA9IGFyZ3MuYWNjb3VudCE7XG4gICAgY29uc3QgcmVnaW9uOiBzdHJpbmcgPSBhcmdzLnJlZ2lvbiE7XG5cbiAgICBjb25zdCBvcHRpb25zID0geyBhc3N1bWVSb2xlQXJuOiBhcmdzLmxvb2t1cFJvbGVBcm4gfTtcbiAgICBjb25zdCBrbXMgPSAoYXdhaXQgdGhpcy5hd3MuZm9yRW52aXJvbm1lbnQoY3hhcGkuRW52aXJvbm1lbnRVdGlscy5tYWtlKGFjY291bnQsIHJlZ2lvbiksIE1vZGUuRm9yUmVhZGluZywgb3B0aW9ucykpLnNkay5rbXMoKTtcblxuICAgIGNvbnN0IGFsaWFzTGlzdEVudHJ5ID0gYXdhaXQgdGhpcy5maW5kS2V5KGttcywgYXJncyk7XG5cbiAgICByZXR1cm4gdGhpcy5yZWFkS2V5UHJvcHMoYWxpYXNMaXN0RW50cnksIGFyZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmaW5kS2V5KGttczogQVdTLktNUywgYXJnczogY3hzY2hlbWEuS2V5Q29udGV4dFF1ZXJ5KTogUHJvbWlzZTxBV1MuS01TLkFsaWFzTGlzdEVudHJ5PiB7XG5cbiAgICBkZWJ1ZyhgTGlzdGluZyBrZXlzIGluICR7YXJncy5hY2NvdW50fToke2FyZ3MucmVnaW9ufWApO1xuXG4gICAgbGV0IHJlc3BvbnNlOiBQcm9taXNlUmVzdWx0PEFXUy5LTVMuTGlzdEFsaWFzZXNSZXNwb25zZSwgQVdTLkFXU0Vycm9yPjtcbiAgICBsZXQgbmV4dE1hcmtlcjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGRvIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQga21zLmxpc3RBbGlhc2VzKHtcbiAgICAgICAgTWFya2VyOiBuZXh0TWFya2VyLFxuICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICBjb25zdCBhbGlhc2VzID0gcmVzcG9uc2UuQWxpYXNlcyB8fCBbXTtcbiAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICBpZiAoYWxpYXMuQWxpYXNOYW1lID09IGFyZ3MuYWxpYXNOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGFsaWFzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRNYXJrZXIgPSByZXNwb25zZS5OZXh0TWFya2VyO1xuICAgIH0gd2hpbGUgKHJlc3BvbnNlLlRydW5jYXRlZCk7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGFueSBrZXkgd2l0aCBhbGlhcyBuYW1lZCAke2FyZ3MuYWxpYXNOYW1lfWApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWFkS2V5UHJvcHMoYWxpYXM6IEFXUy5LTVMuQWxpYXNMaXN0RW50cnksIGFyZ3M6IGN4c2NoZW1hLktleUNvbnRleHRRdWVyeSk6IFByb21pc2U8Y3hhcGkuS2V5Q29udGV4dFJlc3BvbnNlPiB7XG4gICAgaWYgKCFhbGlhcy5UYXJnZXRLZXlJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkga2V5IHdpdGggYWxpYXMgbmFtZWQgJHthcmdzLmFsaWFzTmFtZX1gKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgS2V5IGZvdW5kICR7YWxpYXMuVGFyZ2V0S2V5SWR9YCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5SWQ6IGFsaWFzLlRhcmdldEtleUlkLFxuICAgIH07XG4gIH1cblxufVxuIl19
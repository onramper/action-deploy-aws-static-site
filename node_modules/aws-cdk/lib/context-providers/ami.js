"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmiContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const credentials_1 = require("../api/aws-auth/credentials");
const logging_1 = require("../logging");
/**
 * Plugin to search AMIs for the current account
 */
class AmiContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const region = args.region;
        const account = args.account;
        // Normally we'd do this only as 'debug', but searching AMIs typically takes dozens
        // of seconds, so be little more verbose about it so users know what is going on.
        (0, logging_1.print)(`Searching for AMI in ${account}:${region}`);
        (0, logging_1.debug)(`AMI search parameters: ${JSON.stringify(args)}`);
        const options = { assumeRoleArn: args.lookupRoleArn };
        const ec2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(account, region), credentials_1.Mode.ForReading, options)).sdk.ec2();
        const response = await ec2.describeImages({
            Owners: args.owners,
            Filters: Object.entries(args.filters).map(([key, values]) => ({
                Name: key,
                Values: values,
            })),
        }).promise();
        const images = [...response.Images || []].filter(i => i.ImageId !== undefined);
        if (images.length === 0) {
            throw new Error('No AMI found that matched the search criteria');
        }
        // Return the most recent one
        // Note: Date.parse() is not going to respect the timezone of the string,
        // but since we only care about the relative values that is okay.
        images.sort(descending(i => Date.parse(i.CreationDate || '1970')));
        (0, logging_1.debug)(`Selected image '${images[0].ImageId}' created at '${images[0].CreationDate}'`);
        return images[0].ImageId;
    }
}
exports.AmiContextProviderPlugin = AmiContextProviderPlugin;
/**
 * Make a comparator that sorts in descending order given a sort key extractor
 */
function descending(valueOf) {
    return (a, b) => {
        return valueOf(b) - valueOf(a);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1pLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYW1pLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHlDQUF5QztBQUN6Qyw2REFBbUQ7QUFHbkQsd0NBQTBDO0FBRTFDOztHQUVHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUE4QjtRQUNsRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFFN0IsbUZBQW1GO1FBQ25GLGlGQUFpRjtRQUNqRixJQUFBLGVBQUssRUFBQyx3QkFBd0IsT0FBTyxJQUFJLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDbkQsSUFBQSxlQUFLLEVBQUMsMEJBQTBCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE1BQU0sT0FBTyxHQUFHLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN0RCxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLEVBQUUsa0JBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDOUgsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDO1lBQ3hDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzVELElBQUksRUFBRSxHQUFHO2dCQUNULE1BQU0sRUFBRSxNQUFNO2FBQ2YsQ0FBQyxDQUFDO1NBQ0osQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQztRQUUvRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztTQUNsRTtRQUVELDZCQUE2QjtRQUM3Qix5RUFBeUU7UUFDekUsaUVBQWlFO1FBQ2pFLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVuRSxJQUFBLGVBQUssRUFBQyxtQkFBbUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8saUJBQWlCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3RGLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQVEsQ0FBQztJQUM1QixDQUFDO0NBQ0Y7QUFyQ0QsNERBcUNDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFVBQVUsQ0FBSSxPQUF5QjtJQUM5QyxPQUFPLENBQUMsQ0FBSSxFQUFFLENBQUksRUFBRSxFQUFFO1FBQ3BCLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQyxDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCB7IGRlYnVnLCBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuXG4vKipcbiAqIFBsdWdpbiB0byBzZWFyY2ggQU1JcyBmb3IgdGhlIGN1cnJlbnQgYWNjb3VudFxuICovXG5leHBvcnQgY2xhc3MgQW1pQ29udGV4dFByb3ZpZGVyUGx1Z2luIGltcGxlbWVudHMgQ29udGV4dFByb3ZpZGVyUGx1Z2luIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBhd3M6IFNka1Byb3ZpZGVyKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0VmFsdWUoYXJnczogY3hzY2hlbWEuQW1pQ29udGV4dFF1ZXJ5KSB7XG4gICAgY29uc3QgcmVnaW9uID0gYXJncy5yZWdpb247XG4gICAgY29uc3QgYWNjb3VudCA9IGFyZ3MuYWNjb3VudDtcblxuICAgIC8vIE5vcm1hbGx5IHdlJ2QgZG8gdGhpcyBvbmx5IGFzICdkZWJ1ZycsIGJ1dCBzZWFyY2hpbmcgQU1JcyB0eXBpY2FsbHkgdGFrZXMgZG96ZW5zXG4gICAgLy8gb2Ygc2Vjb25kcywgc28gYmUgbGl0dGxlIG1vcmUgdmVyYm9zZSBhYm91dCBpdCBzbyB1c2VycyBrbm93IHdoYXQgaXMgZ29pbmcgb24uXG4gICAgcHJpbnQoYFNlYXJjaGluZyBmb3IgQU1JIGluICR7YWNjb3VudH06JHtyZWdpb259YCk7XG4gICAgZGVidWcoYEFNSSBzZWFyY2ggcGFyYW1ldGVyczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFzc3VtZVJvbGVBcm46IGFyZ3MubG9va3VwUm9sZUFybiB9O1xuICAgIGNvbnN0IGVjMiA9IChhd2FpdCB0aGlzLmF3cy5mb3JFbnZpcm9ubWVudChjeGFwaS5FbnZpcm9ubWVudFV0aWxzLm1ha2UoYWNjb3VudCwgcmVnaW9uKSwgTW9kZS5Gb3JSZWFkaW5nLCBvcHRpb25zKSkuc2RrLmVjMigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlSW1hZ2VzKHtcbiAgICAgIE93bmVyczogYXJncy5vd25lcnMsXG4gICAgICBGaWx0ZXJzOiBPYmplY3QuZW50cmllcyhhcmdzLmZpbHRlcnMpLm1hcCgoW2tleSwgdmFsdWVzXSkgPT4gKHtcbiAgICAgICAgTmFtZToga2V5LFxuICAgICAgICBWYWx1ZXM6IHZhbHVlcyxcbiAgICAgIH0pKSxcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICBjb25zdCBpbWFnZXMgPSBbLi4ucmVzcG9uc2UuSW1hZ2VzIHx8IFtdXS5maWx0ZXIoaSA9PiBpLkltYWdlSWQgIT09IHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBBTUkgZm91bmQgdGhhdCBtYXRjaGVkIHRoZSBzZWFyY2ggY3JpdGVyaWEnKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1vc3QgcmVjZW50IG9uZVxuICAgIC8vIE5vdGU6IERhdGUucGFyc2UoKSBpcyBub3QgZ29pbmcgdG8gcmVzcGVjdCB0aGUgdGltZXpvbmUgb2YgdGhlIHN0cmluZyxcbiAgICAvLyBidXQgc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IHRoZSByZWxhdGl2ZSB2YWx1ZXMgdGhhdCBpcyBva2F5LlxuICAgIGltYWdlcy5zb3J0KGRlc2NlbmRpbmcoaSA9PiBEYXRlLnBhcnNlKGkuQ3JlYXRpb25EYXRlIHx8ICcxOTcwJykpKTtcblxuICAgIGRlYnVnKGBTZWxlY3RlZCBpbWFnZSAnJHtpbWFnZXNbMF0uSW1hZ2VJZH0nIGNyZWF0ZWQgYXQgJyR7aW1hZ2VzWzBdLkNyZWF0aW9uRGF0ZX0nYCk7XG4gICAgcmV0dXJuIGltYWdlc1swXS5JbWFnZUlkITtcbiAgfVxufVxuXG4vKipcbiAqIE1ha2UgYSBjb21wYXJhdG9yIHRoYXQgc29ydHMgaW4gZGVzY2VuZGluZyBvcmRlciBnaXZlbiBhIHNvcnQga2V5IGV4dHJhY3RvclxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nPEE+KHZhbHVlT2Y6ICh4OiBBKSA9PiBudW1iZXIpIHtcbiAgcmV0dXJuIChhOiBBLCBiOiBBKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlT2YoYikgLSB2YWx1ZU9mKGEpO1xuICB9O1xufVxuIl19
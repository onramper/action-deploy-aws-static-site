import { ResourceDifference } from '@aws-cdk/cloudformation-diff';
import * as cxapi from '@aws-cdk/cx-api';
import { Deployments, DeployStackOptions } from './api/deployments';
import { ResourceIdentifierProperties } from './api/util/cloudformation';
/**
 * Set of parameters that uniquely identify a physical resource of a given type
 * for the import operation, example:
 *
 * ```
 * {
 *   "AWS::S3::Bucket": [["BucketName"]],
 *   "AWS::DynamoDB::GlobalTable": [["TableName"], ["TableArn"], ["TableStreamArn"]],
 *   "AWS::Route53::KeySigningKey": [["HostedZoneId", "Name"]],
 * }
 * ```
 */
export type ResourceIdentifiers = {
    [resourceType: string]: string[][];
};
/**
 * Mapping of CDK resources (L1 constructs) to physical resources to be imported
 * in their place, example:
 *
 * ```
 * {
 *   "MyStack/MyS3Bucket/Resource": {
 *     "BucketName": "my-manually-created-s3-bucket"
 *   },
 *   "MyStack/MyVpc/Resource": {
 *     "VpcId": "vpc-123456789"
 *   }
 * }
 * ```
 */
export type ResourceMap = {
    [logicalResource: string]: ResourceIdentifierProperties;
};
export interface ResourceImporterOptions {
    /**
     * Name of toolkit stack if non-default
     *
     * @default - Default toolkit stack name
     */
    readonly toolkitStackName?: string;
}
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
export declare class ResourceImporter {
    private readonly stack;
    private readonly cfn;
    private readonly options;
    private _currentTemplate;
    constructor(stack: cxapi.CloudFormationStackArtifact, cfn: Deployments, options?: ResourceImporterOptions);
    /**
     * Ask the user for resources to import
     */
    askForResourceIdentifiers(available: ImportableResource[]): Promise<ImportMap>;
    /**
     * Load the resources to import from a file
     */
    loadResourceIdentifiers(available: ImportableResource[], filename: string): Promise<ImportMap>;
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    importResources(importMap: ImportMap, options: DeployStackOptions): Promise<void>;
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    discoverImportableResources(allowNonAdditions?: boolean): Promise<DiscoverImportableResourcesResult>;
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    private currentTemplate;
    /**
     * Return the current template, with the given resources added to it
     */
    private currentTemplateWithAdditions;
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    private resourceIdentifiers;
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    private askForResourceIdentifier;
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    private makeResourcesToImport;
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    private describeResource;
}
/**
 * Information about a resource in the template that is importable
 */
export interface ImportableResource {
    /**
     * The logical ID of the resource
     */
    readonly logicalId: string;
    /**
     * The resource definition in the new template
     */
    readonly resourceDefinition: any;
    /**
     * The diff as reported by `cloudformation-diff`.
     */
    readonly resourceDiff: ResourceDifference;
}
/**
 * The information necessary to execute an import operation
 */
export interface ImportMap {
    /**
     * Mapping logical IDs to physical names
     */
    readonly resourceMap: ResourceMap;
    /**
     * The selection of resources we are actually importing
     *
     * For each of the resources in this list, there is a corresponding entry in
     * the `resourceMap` map.
     */
    readonly importResources: ImportableResource[];
}
export interface DiscoverImportableResourcesResult {
    readonly additions: ImportableResource[];
    readonly hasNonAdditions: boolean;
}

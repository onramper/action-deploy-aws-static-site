"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkGraph = void 0;
const parallel_1 = require("./parallel");
const work_graph_types_1 = require("./work-graph-types");
const logging_1 = require("../logging");
class WorkGraph {
    constructor(nodes = {}) {
        this.readyPool = [];
        this.lazyDependencies = new Map();
        this.nodes = { ...nodes };
    }
    addNodes(...nodes) {
        for (const node of nodes) {
            if (this.nodes[node.id]) {
                throw new Error(`Duplicate use of node id: ${node.id}`);
            }
            const ld = this.lazyDependencies.get(node.id);
            if (ld) {
                for (const x of ld) {
                    node.dependencies.add(x);
                }
                this.lazyDependencies.delete(node.id);
            }
            this.nodes[node.id] = node;
        }
    }
    removeNode(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        const removedNode = this.nodes[id];
        this.lazyDependencies.delete(id);
        delete this.nodes[id];
        if (removedNode) {
            for (const node of Object.values(this.nodes)) {
                node.dependencies.delete(removedNode.id);
            }
        }
    }
    /**
     * Return all nodes of a given type
     */
    nodesOfType(type) {
        return Object.values(this.nodes).filter(n => n.type === type);
    }
    /**
     * Return all nodes that depend on a given node
     */
    dependees(nodeId) {
        const id = typeof nodeId === 'string' ? nodeId : nodeId.id;
        return Object.values(this.nodes).filter(n => n.dependencies.has(id));
    }
    /**
     * Add a dependency, that may come before or after the nodes involved
     */
    addDependency(fromId, toId) {
        const node = this.nodes[fromId];
        if (node) {
            node.dependencies.add(toId);
            return;
        }
        let lazyDeps = this.lazyDependencies.get(fromId);
        if (!lazyDeps) {
            lazyDeps = [];
            this.lazyDependencies.set(fromId, lazyDeps);
        }
        lazyDeps.push(toId);
    }
    tryGetNode(id) {
        return this.nodes[id];
    }
    node(id) {
        const ret = this.nodes[id];
        if (!ret) {
            throw new Error(`No node with id ${id} among ${Object.keys(this.nodes)}`);
        }
        return ret;
    }
    absorb(graph) {
        this.addNodes(...Object.values(graph.nodes));
    }
    hasFailed() {
        return Object.values(this.nodes).some((n) => n.deploymentState === work_graph_types_1.DeploymentState.FAILED);
    }
    doParallel(concurrency, actions) {
        return this.forAllArtifacts(concurrency, async (x) => {
            switch (x.type) {
                case 'stack':
                    await actions.deployStack(x);
                    break;
                case 'asset-build':
                    await actions.buildAsset(x);
                    break;
                case 'asset-publish':
                    await actions.publishAsset(x);
                    break;
            }
        });
    }
    /**
     * Return the set of unblocked nodes
     */
    ready() {
        this.updateReadyPool();
        return this.readyPool;
    }
    forAllArtifacts(n, fn) {
        const graph = this;
        // If 'n' is a number, we limit all concurrency equally (effectively we will be using totalMax)
        // If 'n' is a record, we limit each job independently (effectively we will be using max)
        const max = typeof n === 'number' ?
            {
                'asset-build': n,
                'asset-publish': n,
                'stack': n,
            } : n;
        const totalMax = typeof n === 'number' ? n : sum(Object.values(n));
        return new Promise((ok, fail) => {
            let active = {
                'asset-build': 0,
                'asset-publish': 0,
                'stack': 0,
            };
            function totalActive() {
                return sum(Object.values(active));
            }
            start();
            function start() {
                graph.updateReadyPool();
                for (let i = 0; i < graph.readyPool.length;) {
                    const node = graph.readyPool[i];
                    if (active[node.type] < max[node.type] && totalActive() < totalMax) {
                        graph.readyPool.splice(i, 1);
                        startOne(node);
                    }
                    else {
                        i += 1;
                    }
                }
                if (totalActive() === 0) {
                    if (graph.done()) {
                        ok();
                    }
                    // wait for other active deploys to finish before failing
                    if (graph.hasFailed()) {
                        fail(graph.error);
                    }
                }
            }
            function startOne(x) {
                x.deploymentState = work_graph_types_1.DeploymentState.DEPLOYING;
                active[x.type]++;
                void fn(x)
                    .finally(() => {
                    active[x.type]--;
                })
                    .then(() => {
                    graph.deployed(x);
                    start();
                }).catch((err) => {
                    // By recording the failure immediately as the queued task exits, we prevent the next
                    // queued task from starting.
                    graph.failed(x, err);
                    start();
                });
            }
        });
    }
    done() {
        return Object.values(this.nodes).every((n) => work_graph_types_1.DeploymentState.COMPLETED === n.deploymentState);
    }
    deployed(node) {
        node.deploymentState = work_graph_types_1.DeploymentState.COMPLETED;
    }
    failed(node, error) {
        this.error = error;
        node.deploymentState = work_graph_types_1.DeploymentState.FAILED;
        this.skipRest();
        this.readyPool.splice(0);
    }
    toString() {
        return [
            'digraph D {',
            ...Object.entries(this.nodes).flatMap(([id, node]) => renderNode(id, node)),
            '}',
        ].join('\n');
        function renderNode(id, node) {
            const ret = [];
            if (node.deploymentState === work_graph_types_1.DeploymentState.COMPLETED) {
                ret.push(`  ${gv(id, { style: 'filled', fillcolor: 'yellow', comment: node.note })};`);
            }
            else {
                ret.push(`  ${gv(id, { comment: node.note })};`);
            }
            for (const dep of node.dependencies) {
                ret.push(`  ${gv(id)} -> ${gv(dep)};`);
            }
            return ret;
        }
    }
    /**
     * Ensure all dependencies actually exist. This protects against scenarios such as the following:
     * StackA depends on StackB, but StackB is not selected to deploy. The dependency is redundant
     * and will be dropped.
     * This assumes the manifest comes uncorrupted so we will not fail if a dependency is not found.
     */
    removeUnavailableDependencies() {
        for (const node of Object.values(this.nodes)) {
            const removeDeps = Array.from(node.dependencies).filter((dep) => this.nodes[dep] === undefined);
            removeDeps.forEach((d) => {
                node.dependencies.delete(d);
            });
        }
    }
    /**
     * Remove all asset publishing steps for assets that are already published, and then build
     * that aren't used anymore.
     *
     * Do this in parallel, because there may be a lot of assets in an application (seen in practice: >100 assets)
     */
    async removeUnnecessaryAssets(isUnnecessary) {
        (0, logging_1.debug)('Checking for previously published assets');
        const publishes = this.nodesOfType('asset-publish');
        const classifiedNodes = await (0, parallel_1.parallelPromises)(8, publishes.map((assetNode) => async () => [assetNode, await isUnnecessary(assetNode)]));
        const alreadyPublished = classifiedNodes.filter(([_, unnecessary]) => unnecessary).map(([assetNode, _]) => assetNode);
        for (const assetNode of alreadyPublished) {
            this.removeNode(assetNode);
        }
        (0, logging_1.debug)(`${publishes.length} total assets, ${publishes.length - alreadyPublished.length} still need to be published`);
        // Now also remove any asset build steps that don't have any dependencies on them anymore
        const unusedBuilds = this.nodesOfType('asset-build').filter(build => this.dependees(build).length === 0);
        for (const unusedBuild of unusedBuilds) {
            this.removeNode(unusedBuild);
        }
    }
    updateReadyPool() {
        const activeCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.DEPLOYING).length;
        const pendingCount = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING).length;
        const newlyReady = Object.values(this.nodes).filter((x) => x.deploymentState === work_graph_types_1.DeploymentState.PENDING &&
            Array.from(x.dependencies).every((id) => this.node(id).deploymentState === work_graph_types_1.DeploymentState.COMPLETED));
        // Add newly available nodes to the ready pool
        for (const node of newlyReady) {
            node.deploymentState = work_graph_types_1.DeploymentState.QUEUED;
            this.readyPool.push(node);
        }
        // Remove nodes from the ready pool that have already started deploying
        retainOnly(this.readyPool, (node) => node.deploymentState === work_graph_types_1.DeploymentState.QUEUED);
        // Sort by reverse priority
        this.readyPool.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
        if (this.readyPool.length === 0 && activeCount === 0 && pendingCount > 0) {
            const cycle = this.findCycle() ?? ['No cycle found!'];
            (0, logging_1.trace)(`Cycle ${cycle.join(' -> ')} in graph ${this}`);
            throw new Error(`Unable to make progress anymore, dependency cycle between remaining artifacts: ${cycle.join(' -> ')} (run with -vv for full graph)`);
        }
    }
    skipRest() {
        for (const node of Object.values(this.nodes)) {
            if ([work_graph_types_1.DeploymentState.QUEUED, work_graph_types_1.DeploymentState.PENDING].includes(node.deploymentState)) {
                node.deploymentState = work_graph_types_1.DeploymentState.SKIPPED;
            }
        }
    }
    /**
     * Find cycles in a graph
     *
     * Not the fastest, but effective and should be rare
     */
    findCycle() {
        const seen = new Set();
        const self = this;
        for (const nodeId of Object.keys(this.nodes)) {
            const cycle = recurse(nodeId, [nodeId]);
            if (cycle) {
                return cycle;
            }
        }
        return undefined;
        function recurse(nodeId, path) {
            if (seen.has(nodeId)) {
                return undefined;
            }
            try {
                for (const dep of self.nodes[nodeId].dependencies ?? []) {
                    const index = path.indexOf(dep);
                    if (index > -1) {
                        return [...path.slice(index), dep];
                    }
                    const cycle = recurse(dep, [...path, dep]);
                    if (cycle) {
                        return cycle;
                    }
                }
                return undefined;
            }
            finally {
                seen.add(nodeId);
            }
        }
    }
    /**
     * Whether the `end` node is reachable from the `start` node, following the dependency arrows
     */
    reachable(start, end) {
        const seen = new Set();
        const self = this;
        return recurse(start);
        function recurse(current) {
            if (seen.has(current)) {
                return false;
            }
            seen.add(current);
            if (current === end) {
                return true;
            }
            for (const dep of self.nodes[current].dependencies) {
                if (recurse(dep)) {
                    return true;
                }
            }
            return false;
        }
    }
}
exports.WorkGraph = WorkGraph;
function sum(xs) {
    let ret = 0;
    for (const x of xs) {
        ret += x;
    }
    return ret;
}
function retainOnly(xs, pred) {
    xs.splice(0, xs.length, ...xs.filter(pred));
}
function gv(id, attrs) {
    const attrString = Object.entries(attrs ?? {}).flatMap(([k, v]) => v !== undefined ? [`${k}="${v}"`] : []).join(',');
    return attrString ? `"${simplifyId(id)}" [${attrString}]` : `"${simplifyId(id)}"`;
}
function simplifyId(id) {
    return id.replace(/([0-9a-f]{6})[0-9a-f]{6,}/g, '$1');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yay1ncmFwaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndvcmstZ3JhcGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUNBQThDO0FBQzlDLHlEQUE0RztBQUM1Ryx3Q0FBMEM7QUFJMUMsTUFBYSxTQUFTO0lBTXBCLFlBQW1CLFFBQWtDLEVBQUU7UUFKdEMsY0FBUyxHQUFvQixFQUFFLENBQUM7UUFDaEMscUJBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFJOUQsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVNLFFBQVEsQ0FBQyxHQUFHLEtBQWlCO1FBQ2xDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3hCLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3pEO1lBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDOUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ04sS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUU7b0JBQ2xCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMxQjtnQkFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN2QztZQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztTQUM1QjtJQUNILENBQUM7SUFFTSxVQUFVLENBQUMsTUFBeUI7UUFDekMsTUFBTSxFQUFFLEdBQUcsT0FBTyxNQUFNLEtBQUssUUFBUSxD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QUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFJLEVBQU8sRUFBRSxJQUF1QjtJQUNyRCxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRCxTQUFTLEVBQUUsQ0FBQyxFQUFVLEVBQUUsS0FBMEM7SUFDaEUsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXJILE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztBQUNwRixDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUMsRUFBVTtJQUM1QixPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsNEJBQTRCLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDeEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcmFsbGVsUHJvbWlzZXMgfSBmcm9tICcuL3BhcmFsbGVsJztcbmltcG9ydCB7IFdvcmtOb2RlLCBEZXBsb3ltZW50U3RhdGUsIFN0YWNrTm9kZSwgQXNzZXRCdWlsZE5vZGUsIEFzc2V0UHVibGlzaE5vZGUgfSBmcm9tICcuL3dvcmstZ3JhcGgtdHlwZXMnO1xuaW1wb3J0IHsgZGVidWcsIHRyYWNlIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCB0eXBlIENvbmN1cnJlbmN5ID0gbnVtYmVyIHwgUmVjb3JkPFdvcmtOb2RlWyd0eXBlJ10sIG51bWJlcj47XG5cbmV4cG9ydCBjbGFzcyBXb3JrR3JhcGgge1xuICBwdWJsaWMgcmVhZG9ubHkgbm9kZXM6IFJlY29yZDxzdHJpbmcsIFdvcmtOb2RlPjtcbiAgcHJpdmF0ZSByZWFkb25seSByZWFkeVBvb2w6IEFycmF5PFdvcmtOb2RlPiA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGxhenlEZXBlbmRlbmNpZXMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gIHB1YmxpYyBlcnJvcj86IEVycm9yO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihub2RlczogUmVjb3JkPHN0cmluZywgV29ya05vZGU+ID0ge30pIHtcbiAgICB0aGlzLm5vZGVzID0geyAuLi5ub2RlcyB9O1xuICB9XG5cbiAgcHVibGljIGFkZE5vZGVzKC4uLm5vZGVzOiBXb3JrTm9kZVtdKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAodGhpcy5ub2Rlc1tub2RlLmlkXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2Ygbm9kZSBpZDogJHtub2RlLmlkfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsZCA9IHRoaXMubGF6eURlcGVuZGVuY2llcy5nZXQobm9kZS5pZCk7XG4gICAgICBpZiAobGQpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIGxkKSB7XG4gICAgICAgICAgbm9kZS5kZXBlbmRlbmNpZXMuYWRkKHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF6eURlcGVuZGVuY2llcy5kZWxldGUobm9kZS5pZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVOb2RlKG5vZGVJZDogc3RyaW5nIHwgV29ya05vZGUpIHtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBub2RlSWQgPT09ICdzdHJpbmcnID8gbm9kZUlkIDogbm9kZUlkLmlkO1xuICAgIGNvbnN0IHJlbW92ZWROb2RlID0gdGhpcy5ub2Rlc1tpZF07XG5cbiAgICB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZGVsZXRlKGlkKTtcbiAgICBkZWxldGUgdGhpcy5ub2Rlc1tpZF07XG5cbiAgICBpZiAocmVtb3ZlZE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpKSB7XG4gICAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmRlbGV0ZShyZW1vdmVkTm9kZS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgbm9kZXMgb2YgYSBnaXZlbiB0eXBlXG4gICAqL1xuICBwdWJsaWMgbm9kZXNPZlR5cGU8VCBleHRlbmRzIFdvcmtOb2RlWyd0eXBlJ10+KHR5cGU6IFQpOiBFeHRyYWN0PFdvcmtOb2RlLCB7IHR5cGU6IFQgfT5bXSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZmlsdGVyKG4gPT4gbi50eXBlID09PSB0eXBlKSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBub2RlcyB0aGF0IGRlcGVuZCBvbiBhIGdpdmVuIG5vZGVcbiAgICovXG4gIHB1YmxpYyBkZXBlbmRlZXMobm9kZUlkOiBzdHJpbmcgfCBXb3JrTm9kZSkge1xuICAgIGNvbnN0IGlkID0gdHlwZW9mIG5vZGVJZCA9PT0gJ3N0cmluZycgPyBub2RlSWQgOiBub2RlSWQuaWQ7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZmlsdGVyKG4gPT4gbi5kZXBlbmRlbmNpZXMuaGFzKGlkKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSwgdGhhdCBtYXkgY29tZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5vZGVzIGludm9sdmVkXG4gICAqL1xuICBwdWJsaWMgYWRkRGVwZW5kZW5jeShmcm9tSWQ6IHN0cmluZywgdG9JZDogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbZnJvbUlkXTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5kZXBlbmRlbmNpZXMuYWRkKHRvSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGF6eURlcHMgPSB0aGlzLmxhenlEZXBlbmRlbmNpZXMuZ2V0KGZyb21JZCk7XG4gICAgaWYgKCFsYXp5RGVwcykge1xuICAgICAgbGF6eURlcHMgPSBbXTtcbiAgICAgIHRoaXMubGF6eURlcGVuZGVuY2llcy5zZXQoZnJvbUlkLCBsYXp5RGVwcyk7XG4gICAgfVxuICAgIGxhenlEZXBzLnB1c2godG9JZCk7XG4gIH1cblxuICBwdWJsaWMgdHJ5R2V0Tm9kZShpZDogc3RyaW5nKTogV29ya05vZGUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm5vZGVzW2lkXTtcbiAgfVxuXG4gIHB1YmxpYyBub2RlKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXQgPSB0aGlzLm5vZGVzW2lkXTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBub2RlIHdpdGggaWQgJHtpZH0gYW1vbmcgJHtPYmplY3Qua2V5cyh0aGlzLm5vZGVzKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHB1YmxpYyBhYnNvcmIoZ3JhcGg6IFdvcmtHcmFwaCkge1xuICAgIHRoaXMuYWRkTm9kZXMoLi4uT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNGYWlsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5ub2Rlcykuc29tZSgobikgPT4gbi5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5GQUlMRUQpO1xuICB9XG5cbiAgcHVibGljIGRvUGFyYWxsZWwoY29uY3VycmVuY3k6IENvbmN1cnJlbmN5LCBhY3Rpb25zOiBXb3JrR3JhcGhBY3Rpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yQWxsQXJ0aWZhY3RzKGNvbmN1cnJlbmN5LCBhc3luYyAoeDogV29ya05vZGUpID0+IHtcbiAgICAgIHN3aXRjaCAoeC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0YWNrJzpcbiAgICAgICAgICBhd2FpdCBhY3Rpb25zLmRlcGxveVN0YWNrKHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhc3NldC1idWlsZCc6XG4gICAgICAgICAgYXdhaXQgYWN0aW9ucy5idWlsZEFzc2V0KHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhc3NldC1wdWJsaXNoJzpcbiAgICAgICAgICBhd2FpdCBhY3Rpb25zLnB1Ymxpc2hBc3NldCh4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiB1bmJsb2NrZWQgbm9kZXNcbiAgICovXG4gIHB1YmxpYyByZWFkeSgpOiBSZWFkb25seUFycmF5PFdvcmtOb2RlPiB7XG4gICAgdGhpcy51cGRhdGVSZWFkeVBvb2woKTtcbiAgICByZXR1cm4gdGhpcy5yZWFkeVBvb2w7XG4gIH1cblxuICBwcml2YXRlIGZvckFsbEFydGlmYWN0cyhuOiBDb25jdXJyZW5jeSwgZm46ICh4OiBXb3JrTm9kZSkgPT4gUHJvbWlzZTx2b2lkPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcztcblxuICAgIC8vIElmICduJyBpcyBhIG51bWJlciwgd2UgbGltaXQgYWxsIGNvbmN1cnJlbmN5IGVxdWFsbHkgKGVmZmVjdGl2ZWx5IHdlIHdpbGwgYmUgdXNpbmcgdG90YWxNYXgpXG4gICAgLy8gSWYgJ24nIGlzIGEgcmVjb3JkLCB3ZSBsaW1pdCBlYWNoIGpvYiBpbmRlcGVuZGVudGx5IChlZmZlY3RpdmVseSB3ZSB3aWxsIGJlIHVzaW5nIG1heClcbiAgICBjb25zdCBtYXg6IFJlY29yZDxXb3JrTm9kZVsndHlwZSddLCBudW1iZXI+ID0gdHlwZW9mIG4gPT09ICdudW1iZXInID9cbiAgICAgIHtcbiAgICAgICAgJ2Fzc2V0LWJ1aWxkJzogbixcbiAgICAgICAgJ2Fzc2V0LXB1Ymxpc2gnOiBuLFxuICAgICAgICAnc3RhY2snOiBuLFxuICAgICAgfSA6IG47XG4gICAgY29uc3QgdG90YWxNYXggPSB0eXBlb2YgbiA9PT0gJ251bWJlcicgPyBuIDogc3VtKE9iamVjdC52YWx1ZXMobikpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChvaywgZmFpbCkgPT4ge1xuICAgICAgbGV0IGFjdGl2ZTogUmVjb3JkPFdvcmtOb2RlWyd0eXBlJ10sIG51bWJlcj4gPSB7XG4gICAgICAgICdhc3NldC1idWlsZCc6IDAsXG4gICAgICAgICdhc3NldC1wdWJsaXNoJzogMCxcbiAgICAgICAgJ3N0YWNrJzogMCxcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiB0b3RhbEFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHN1bShPYmplY3QudmFsdWVzKGFjdGl2ZSkpO1xuICAgICAgfVxuXG4gICAgICBzdGFydCgpO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgZ3JhcGgudXBkYXRlUmVhZHlQb29sKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5yZWFkeVBvb2wubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZ3JhcGgucmVhZHlQb29sW2ldO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZVtub2RlLnR5cGVdIDwgbWF4W25vZGUudHlwZV0gJiYgdG90YWxBY3RpdmUoKSA8IHRvdGFsTWF4KSB7XG4gICAgICAgICAgICBncmFwaC5yZWFkeVBvb2wuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgc3RhcnRPbmUobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG90YWxBY3RpdmUoKSA9PT0gMCkge1xuICAgICAgICAgIGlmIChncmFwaC5kb25lKCkpIHtcbiAgICAgICAgICAgIG9rKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdhaXQgZm9yIG90aGVyIGFjdGl2ZSBkZXBsb3lzIHRvIGZpbmlzaCBiZWZvcmUgZmFpbGluZ1xuICAgICAgICAgIGlmIChncmFwaC5oYXNGYWlsZWQoKSkge1xuICAgICAgICAgICAgZmFpbChncmFwaC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0T25lKHg6IFdvcmtOb2RlKSB7XG4gICAgICAgIHguZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkRFUExPWUlORztcbiAgICAgICAgYWN0aXZlW3gudHlwZV0rKztcbiAgICAgICAgdm9pZCBmbih4KVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVt4LnR5cGVdLS07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBncmFwaC5kZXBsb3llZCh4KTtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gQnkgcmVjb3JkaW5nIHRoZSBmYWlsdXJlIGltbWVkaWF0ZWx5IGFzIHRoZSBxdWV1ZWQgdGFzayBleGl0cywgd2UgcHJldmVudCB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gcXVldWVkIHRhc2sgZnJvbSBzdGFydGluZy5cbiAgICAgICAgICAgIGdyYXBoLmZhaWxlZCh4LCBlcnIpO1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZG9uZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5ldmVyeSgobikgPT4gRGVwbG95bWVudFN0YXRlLkNPTVBMRVRFRCA9PT0gbi5kZXBsb3ltZW50U3RhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXBsb3llZChub2RlOiBXb3JrTm9kZSkge1xuICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkNPTVBMRVRFRDtcbiAgfVxuXG4gIHByaXZhdGUgZmFpbGVkKG5vZGU6IFdvcmtOb2RlLCBlcnJvcj86IEVycm9yKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLkZBSUxFRDtcbiAgICB0aGlzLnNraXBSZXN0KCk7XG4gICAgdGhpcy5yZWFkeVBvb2wuc3BsaWNlKDApO1xuICB9XG5cbiAgcHVibGljIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnZGlncmFwaCBEIHsnLFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykuZmxhdE1hcCgoW2lkLCBub2RlXSkgPT4gcmVuZGVyTm9kZShpZCwgbm9kZSkpLFxuICAgICAgJ30nLFxuICAgIF0uam9pbignXFxuJyk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXJOb2RlKGlkOiBzdHJpbmcsIG5vZGU6IFdvcmtOb2RlKTogc3RyaW5nW10ge1xuICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICBpZiAobm9kZS5kZXBsb3ltZW50U3RhdGUgPT09IERlcGxveW1lbnRTdGF0ZS5DT01QTEVURUQpIHtcbiAgICAgICAgcmV0LnB1c2goYCAgJHtndihpZCwgeyBzdHlsZTogJ2ZpbGxlZCcsIGZpbGxjb2xvcjogJ3llbGxvdycsIGNvbW1lbnQ6IG5vZGUubm90ZSB9KX07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaChgICAke2d2KGlkLCB7IGNvbW1lbnQ6IG5vZGUubm90ZSB9KX07YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBub2RlLmRlcGVuZGVuY2llcykge1xuICAgICAgICByZXQucHVzaChgICAke2d2KGlkKX0gLT4gJHtndihkZXApfTtgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBkZXBlbmRlbmNpZXMgYWN0dWFsbHkgZXhpc3QuIFRoaXMgcHJvdGVjdHMgYWdhaW5zdCBzY2VuYXJpb3Mgc3VjaCBhcyB0aGUgZm9sbG93aW5nOlxuICAgKiBTdGFja0EgZGVwZW5kcyBvbiBTdGFja0IsIGJ1dCBTdGFja0IgaXMgbm90IHNlbGVjdGVkIHRvIGRlcGxveS4gVGhlIGRlcGVuZGVuY3kgaXMgcmVkdW5kYW50XG4gICAqIGFuZCB3aWxsIGJlIGRyb3BwZWQuXG4gICAqIFRoaXMgYXNzdW1lcyB0aGUgbWFuaWZlc3QgY29tZXMgdW5jb3JydXB0ZWQgc28gd2Ugd2lsbCBub3QgZmFpbCBpZiBhIGRlcGVuZGVuY3kgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgcHVibGljIHJlbW92ZVVuYXZhaWxhYmxlRGVwZW5kZW5jaWVzKCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpKSB7XG4gICAgICBjb25zdCByZW1vdmVEZXBzID0gQXJyYXkuZnJvbShub2RlLmRlcGVuZGVuY2llcykuZmlsdGVyKChkZXApID0+IHRoaXMubm9kZXNbZGVwXSA9PT0gdW5kZWZpbmVkKTtcblxuICAgICAgcmVtb3ZlRGVwcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIG5vZGUuZGVwZW5kZW5jaWVzLmRlbGV0ZShkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGFzc2V0IHB1Ymxpc2hpbmcgc3RlcHMgZm9yIGFzc2V0cyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZCwgYW5kIHRoZW4gYnVpbGRcbiAgICogdGhhdCBhcmVuJ3QgdXNlZCBhbnltb3JlLlxuICAgKlxuICAgKiBEbyB0aGlzIGluIHBhcmFsbGVsLCBiZWNhdXNlIHRoZXJlIG1heSBiZSBhIGxvdCBvZiBhc3NldHMgaW4gYW4gYXBwbGljYXRpb24gKHNlZW4gaW4gcHJhY3RpY2U6ID4xMDAgYXNzZXRzKVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlbW92ZVVubmVjZXNzYXJ5QXNzZXRzKGlzVW5uZWNlc3Nhcnk6ICh4OiBBc3NldFB1Ymxpc2hOb2RlKSA9PiBQcm9taXNlPGJvb2xlYW4+KSB7XG4gICAgZGVidWcoJ0NoZWNraW5nIGZvciBwcmV2aW91c2x5IHB1Ymxpc2hlZCBhc3NldHMnKTtcblxuICAgIGNvbnN0IHB1Ymxpc2hlcyA9IHRoaXMubm9kZXNPZlR5cGUoJ2Fzc2V0LXB1Ymxpc2gnKTtcblxuICAgIGNvbnN0IGNsYXNzaWZpZWROb2RlcyA9IGF3YWl0IHBhcmFsbGVsUHJvbWlzZXMoXG4gICAgICA4LFxuICAgICAgcHVibGlzaGVzLm1hcCgoYXNzZXROb2RlKSA9PiBhc3luYygpID0+IFthc3NldE5vZGUsIGF3YWl0IGlzVW5uZWNlc3NhcnkoYXNzZXROb2RlKV0gYXMgY29uc3QpKTtcblxuICAgIGNvbnN0IGFscmVhZHlQdWJsaXNoZWQgPSBjbGFzc2lmaWVkTm9kZXMuZmlsdGVyKChbXywgdW5uZWNlc3NhcnldKSA9PiB1bm5lY2Vzc2FyeSkubWFwKChbYXNzZXROb2RlLCBfXSkgPT4gYXNzZXROb2RlKTtcbiAgICBmb3IgKGNvbnN0IGFzc2V0Tm9kZSBvZiBhbHJlYWR5UHVibGlzaGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZU5vZGUoYXNzZXROb2RlKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgJHtwdWJsaXNoZXMubGVuZ3RofSB0b3RhbCBhc3NldHMsICR7cHVibGlzaGVzLmxlbmd0aCAtIGFscmVhZHlQdWJsaXNoZWQubGVuZ3RofSBzdGlsbCBuZWVkIHRvIGJlIHB1Ymxpc2hlZGApO1xuXG4gICAgLy8gTm93IGFsc28gcmVtb3ZlIGFueSBhc3NldCBidWlsZCBzdGVwcyB0aGF0IGRvbid0IGhhdmUgYW55IGRlcGVuZGVuY2llcyBvbiB0aGVtIGFueW1vcmVcbiAgICBjb25zdCB1bnVzZWRCdWlsZHMgPSB0aGlzLm5vZGVzT2ZUeXBlKCdhc3NldC1idWlsZCcpLmZpbHRlcihidWlsZCA9PiB0aGlzLmRlcGVuZGVlcyhidWlsZCkubGVuZ3RoID09PSAwKTtcbiAgICBmb3IgKGNvbnN0IHVudXNlZEJ1aWxkIG9mIHVudXNlZEJ1aWxkcykge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlKHVudXNlZEJ1aWxkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVJlYWR5UG9vbCgpIHtcbiAgICBjb25zdCBhY3RpdmVDb3VudCA9IE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZmlsdGVyKCh4KSA9PiB4LmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLkRFUExPWUlORykubGVuZ3RoO1xuICAgIGNvbnN0IHBlbmRpbmdDb3VudCA9IE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZmlsdGVyKCh4KSA9PiB4LmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLlBFTkRJTkcpLmxlbmd0aDtcblxuICAgIGNvbnN0IG5ld2x5UmVhZHkgPSBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLmZpbHRlcigoeCkgPT5cbiAgICAgIHguZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuUEVORElORyAmJlxuICAgICAgQXJyYXkuZnJvbSh4LmRlcGVuZGVuY2llcykuZXZlcnkoKGlkKSA9PiB0aGlzLm5vZGUoaWQpLmRlcGxveW1lbnRTdGF0ZSA9PT0gRGVwbG95bWVudFN0YXRlLkNPTVBMRVRFRCkpO1xuXG4gICAgLy8gQWRkIG5ld2x5IGF2YWlsYWJsZSBub2RlcyB0byB0aGUgcmVhZHkgcG9vbFxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBuZXdseVJlYWR5KSB7XG4gICAgICBub2RlLmRlcGxveW1lbnRTdGF0ZSA9IERlcGxveW1lbnRTdGF0ZS5RVUVVRUQ7XG4gICAgICB0aGlzLnJlYWR5UG9vbC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBub2RlcyBmcm9tIHRoZSByZWFkeSBwb29sIHRoYXQgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWQgZGVwbG95aW5nXG4gICAgcmV0YWluT25seSh0aGlzLnJlYWR5UG9vbCwgKG5vZGUpID0+IG5vZGUuZGVwbG95bWVudFN0YXRlID09PSBEZXBsb3ltZW50U3RhdGUuUVVFVUVEKTtcblxuICAgIC8vIFNvcnQgYnkgcmV2ZXJzZSBwcmlvcml0eVxuICAgIHRoaXMucmVhZHlQb29sLnNvcnQoKGEsIGIpID0+IChiLnByaW9yaXR5ID8/IDApIC0gKGEucHJpb3JpdHkgPz8gMCkpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlQb29sLmxlbmd0aCA9PT0gMCAmJiBhY3RpdmVDb3VudCA9PT0gMCAmJiBwZW5kaW5nQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCBjeWNsZSA9IHRoaXMuZmluZEN5Y2xlKCkgPz8gWydObyBjeWNsZSBmb3VuZCEnXTtcbiAgICAgIHRyYWNlKGBDeWNsZSAke2N5Y2xlLmpvaW4oJyAtPiAnKX0gaW4gZ3JhcGggJHt0aGlzfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbWFrZSBwcm9ncmVzcyBhbnltb3JlLCBkZXBlbmRlbmN5IGN5Y2xlIGJldHdlZW4gcmVtYWluaW5nIGFydGlmYWN0czogJHtjeWNsZS5qb2luKCcgLT4gJyl9IChydW4gd2l0aCAtdnYgZm9yIGZ1bGwgZ3JhcGgpYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBza2lwUmVzdCgpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKSkge1xuICAgICAgaWYgKFtEZXBsb3ltZW50U3RhdGUuUVVFVUVELCBEZXBsb3ltZW50U3RhdGUuUEVORElOR10uaW5jbHVkZXMobm9kZS5kZXBsb3ltZW50U3RhdGUpKSB7XG4gICAgICAgIG5vZGUuZGVwbG95bWVudFN0YXRlID0gRGVwbG95bWVudFN0YXRlLlNLSVBQRUQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgY3ljbGVzIGluIGEgZ3JhcGhcbiAgICpcbiAgICogTm90IHRoZSBmYXN0ZXN0LCBidXQgZWZmZWN0aXZlIGFuZCBzaG91bGQgYmUgcmFyZVxuICAgKi9cbiAgcHVibGljIGZpbmRDeWNsZSgpOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpKSB7XG4gICAgICBjb25zdCBjeWNsZSA9IHJlY3Vyc2Uobm9kZUlkLCBbbm9kZUlkXSk7XG4gICAgICBpZiAoY3ljbGUpIHsgcmV0dXJuIGN5Y2xlOyB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKG5vZGVJZDogc3RyaW5nLCBwYXRoOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkIHtcbiAgICAgIGlmIChzZWVuLmhhcyhub2RlSWQpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBzZWxmLm5vZGVzW25vZGVJZF0uZGVwZW5kZW5jaWVzID8/IFtdKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwYXRoLmluZGV4T2YoZGVwKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5wYXRoLnNsaWNlKGluZGV4KSwgZGVwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjeWNsZSA9IHJlY3Vyc2UoZGVwLCBbLi4ucGF0aCwgZGVwXSk7XG4gICAgICAgICAgaWYgKGN5Y2xlKSB7IHJldHVybiBjeWNsZTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNlZW4uYWRkKG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGBlbmRgIG5vZGUgaXMgcmVhY2hhYmxlIGZyb20gdGhlIGBzdGFydGAgbm9kZSwgZm9sbG93aW5nIHRoZSBkZXBlbmRlbmN5IGFycm93c1xuICAgKi9cbiAgcHVibGljIHJlYWNoYWJsZShzdGFydDogc3RyaW5nLCBlbmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gcmVjdXJzZShzdGFydCk7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKGN1cnJlbnQ6IHN0cmluZykge1xuICAgICAgaWYgKHNlZW4uaGFzKGN1cnJlbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKGN1cnJlbnQpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2VsZi5ub2Rlc1tjdXJyZW50XS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKHJlY3Vyc2UoZGVwKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya0dyYXBoQWN0aW9ucyB7XG4gIGRlcGxveVN0YWNrOiAoc3RhY2tOb2RlOiBTdGFja05vZGUpID0+IFByb21pc2U8dm9pZD47XG4gIGJ1aWxkQXNzZXQ6IChhc3NldE5vZGU6IEFzc2V0QnVpbGROb2RlKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwdWJsaXNoQXNzZXQ6IChhc3NldE5vZGU6IEFzc2V0UHVibGlzaE5vZGUpID0+IFByb21pc2U8dm9pZD47XG59XG5cbmZ1bmN0aW9uIHN1bSh4czogbnVtYmVyW10pIHtcbiAgbGV0IHJldCA9IDA7XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIHJldCArPSB4O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHJldGFpbk9ubHk8QT4oeHM6IEFbXSwgcHJlZDogKHg6IEEpID0+IGJvb2xlYW4pIHtcbiAgeHMuc3BsaWNlKDAsIHhzLmxlbmd0aCwgLi4ueHMuZmlsdGVyKHByZWQpKTtcbn1cblxuZnVuY3Rpb24gZ3YoaWQ6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KSB7XG4gIGNvbnN0IGF0dHJTdHJpbmcgPSBPYmplY3QuZW50cmllcyhhdHRycyA/PyB7fSkuZmxhdE1hcCgoW2ssIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQgPyBbYCR7a309XCIke3Z9XCJgXSA6IFtdKS5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIGF0dHJTdHJpbmcgPyBgXCIke3NpbXBsaWZ5SWQoaWQpfVwiIFske2F0dHJTdHJpbmd9XWAgOiBgXCIke3NpbXBsaWZ5SWQoaWQpfVwiYDtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlJZChpZDogc3RyaW5nKSB7XG4gIHJldHVybiBpZC5yZXBsYWNlKC8oWzAtOWEtZl17Nn0pWzAtOWEtZl17Nix9L2csICckMScpO1xufSJdfQ==
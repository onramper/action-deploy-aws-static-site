"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contentHash = void 0;
const child_process_1 = require("child_process");
const crypto = require("crypto");
const fs_1 = require("fs");
const os = require("os");
const path = require("path");
const util_1 = require("util");
const jszip = require("jszip");
const archive_1 = require("../lib/private/archive");
const fs_extra_1 = require("../lib/private/fs-extra");
const exec = util_1.promisify(child_process_1.exec);
test('zipDirectory can take a directory and produce a zip from it', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const extractDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive.extract'));
    try {
        const zipFile = path.join(stagingDir, 'output.zip');
        const originalDir = path.join(__dirname, 'test-archive');
        await archive_1.zipDirectory(originalDir, zipFile);
        // unzip and verify that the resulting tree is the same
        await exec(`unzip ${zipFile}`, { cwd: extractDir });
        await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeTruthy();
        // inspect the zile file to check that dates are reset
        const zip = await fs_1.promises.readFile(zipFile);
        const zipData = await jszip.loadAsync(zip);
        const dates = Object.values(zipData.files).map(file => file.date.toISOString());
        expect(dates[0]).toBe('1980-01-01T00:00:00.000Z');
        expect(new Set(dates).size).toBe(1);
        // check that mode is preserved
        const stat = await fs_1.promises.stat(path.join(extractDir, 'executable.txt'));
        // eslint-disable-next-line no-bitwise
        const isExec = (stat.mode & fs_1.constants.S_IXUSR) || (stat.mode & fs_1.constants.S_IXGRP) || (stat.mode & fs_1.constants.S_IXOTH);
        expect(isExec).toBeTruthy();
    }
    finally {
        fs_extra_1.rmRfSync(stagingDir);
        fs_extra_1.rmRfSync(extractDir);
    }
});
test('md5 hash of a zip stays consistent across invocations', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const zipFile1 = path.join(stagingDir, 'output.zip');
    const zipFile2 = path.join(stagingDir, 'output.zip');
    const originalDir = path.join(__dirname, 'test-archive');
    await archive_1.zipDirectory(originalDir, zipFile1);
    await new Promise(ok => setTimeout(ok, 2000)); // wait 2s
    await archive_1.zipDirectory(originalDir, zipFile2);
    const hash1 = contentHash(await fs_1.promises.readFile(zipFile1));
    const hash2 = contentHash(await fs_1.promises.readFile(zipFile2));
    expect(hash1).toEqual(hash2);
});
test('zipDirectory follows symlinks', async () => {
    const stagingDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive'));
    const extractDir = await fs_1.promises.mkdtemp(path.join(os.tmpdir(), 'test.archive.follow'));
    try {
        const originalDir = path.join(__dirname, 'test-archive-follow', 'data');
        const zipFile = path.join(stagingDir, 'output.zip');
        await expect(archive_1.zipDirectory(originalDir, zipFile)).resolves.toBeUndefined();
        await expect(exec(`unzip ${zipFile}`, { cwd: extractDir })).resolves.toBeDefined();
        await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeDefined();
    }
    finally {
        fs_extra_1.rmRfSync(stagingDir);
        fs_extra_1.rmRfSync(extractDir);
    }
});
function contentHash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}
exports.contentHash = contentHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXJjaGl2ZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlEQUE4QztBQUM5QyxpQ0FBaUM7QUFDakMsMkJBQStDO0FBQy9DLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixvREFBc0Q7QUFDdEQsc0RBQW1EO0FBQ25ELE1BQU0sSUFBSSxHQUFHLGdCQUFTLENBQUMsb0JBQUssQ0FBQyxDQUFDO0FBRTlCLElBQUksQ0FBQyw2REFBNkQsRUFBRSxLQUFLLElBQUksRUFBRTtJQUM3RSxNQUFNLFVBQVUsR0FBRyxNQUFNLGFBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxNQUFNLGFBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLElBQUk7UUFDRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNwRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUN6RCxNQUFNLHNCQUFZLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXpDLHVEQUF1RDtRQUN2RCxNQUFNLElBQUksQ0FBQyxTQUFTLE9BQU8sRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7UUFFcEQsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsV0FBVyxJQUFJLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFbkYsc0RBQXNEO1FBQ3RELE1BQU0sR0FBRyxHQUFHLE1BQU0sYUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2QyxNQUFNLE9BQU8sR0FBRyxNQUFNLEtBQUssQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ2hGLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztRQUNsRCxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBDLCtCQUErQjtRQUMvQixNQUFNLElBQUksR0FBRyxNQUFNLGFBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLHNDQUFzQztRQUN0QyxNQUFNLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsY0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLGNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNySCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7S0FDN0I7WUFBUztRQUNSLG1CQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckIsbUJBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUN0QjtBQUNILENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLHVEQUF1RCxFQUFFLEtBQUssSUFBSSxFQUFFO0lBQ3ZFLE1BQU0sVUFBVSxHQUFHLE1BQU0sYUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBQzVFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3JELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3JELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sc0JBQVksQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDMUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVU7SUFDekQsTUFBTSxzQkFBWSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUUxQyxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsTUFBTSxhQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDdkQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLE1BQU0sYUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBRXZELE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsK0JBQStCLEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDL0MsTUFBTSxVQUFVLEdBQUcsTUFBTSxhQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7SUFDNUUsTUFBTSxVQUFVLEdBQUcsTUFBTSxhQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLHFCQUFxQixDQUFDLENBQUMsQ0FBQztJQUNuRixJQUFJO1FBQ0YsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDeEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFcEQsTUFBTSxNQUFNLENBQUMsc0JBQVksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDMUUsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsT0FBTyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNuRixNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxXQUFXLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNyRjtZQUFTO1FBQ1IsbUJBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNyQixtQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3RCO0FBQ0gsQ0FBQyxDQUFDLENBQUM7QUFFSCxTQUFnQixXQUFXLENBQUMsSUFBZ0M7SUFDMUQsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEUsQ0FBQztBQUZELGtDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyBhcyBfZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBjb25zdGFudHMsIHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMganN6aXAgZnJvbSAnanN6aXAnO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vbGliL3ByaXZhdGUvYXJjaGl2ZSc7XG5pbXBvcnQgeyBybVJmU3luYyB9IGZyb20gJy4uL2xpYi9wcml2YXRlL2ZzLWV4dHJhJztcbmNvbnN0IGV4ZWMgPSBwcm9taXNpZnkoX2V4ZWMpO1xuXG50ZXN0KCd6aXBEaXJlY3RvcnkgY2FuIHRha2UgYSBkaXJlY3RvcnkgYW5kIHByb2R1Y2UgYSB6aXAgZnJvbSBpdCcsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhZ2luZ0RpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdC5hcmNoaXZlJykpO1xuICBjb25zdCBleHRyYWN0RGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0LmFyY2hpdmUuZXh0cmFjdCcpKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB6aXBGaWxlID0gcGF0aC5qb2luKHN0YWdpbmdEaXIsICdvdXRwdXQuemlwJyk7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlJyk7XG4gICAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlKTtcblxuICAgIC8vIHVuemlwIGFuZCB2ZXJpZnkgdGhhdCB0aGUgcmVzdWx0aW5nIHRyZWUgaXMgdGhlIHNhbWVcbiAgICBhd2FpdCBleGVjKGB1bnppcCAke3ppcEZpbGV9YCwgeyBjd2Q6IGV4dHJhY3REaXIgfSk7XG5cbiAgICBhd2FpdCBleHBlY3QoZXhlYyhgZGlmZiAtYnVyICR7b3JpZ2luYWxEaXJ9ICR7ZXh0cmFjdERpcn1gKSkucmVzb2x2ZXMudG9CZVRydXRoeSgpO1xuXG4gICAgLy8gaW5zcGVjdCB0aGUgemlsZSBmaWxlIHRvIGNoZWNrIHRoYXQgZGF0ZXMgYXJlIHJlc2V0XG4gICAgY29uc3QgemlwID0gYXdhaXQgZnMucmVhZEZpbGUoemlwRmlsZSk7XG4gICAgY29uc3QgemlwRGF0YSA9IGF3YWl0IGpzemlwLmxvYWRBc3luYyh6aXApO1xuICAgIGNvbnN0IGRhdGVzID0gT2JqZWN0LnZhbHVlcyh6aXBEYXRhLmZpbGVzKS5tYXAoZmlsZSA9PiBmaWxlLmRhdGUudG9JU09TdHJpbmcoKSk7XG4gICAgZXhwZWN0KGRhdGVzWzBdKS50b0JlKCcxOTgwLTAxLTAxVDAwOjAwOjAwLjAwMFonKTtcbiAgICBleHBlY3QobmV3IFNldChkYXRlcykuc2l6ZSkudG9CZSgxKTtcblxuICAgIC8vIGNoZWNrIHRoYXQgbW9kZSBpcyBwcmVzZXJ2ZWRcbiAgICBjb25zdCBzdGF0ID0gYXdhaXQgZnMuc3RhdChwYXRoLmpvaW4oZXh0cmFjdERpciwgJ2V4ZWN1dGFibGUudHh0JykpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNFeGVjID0gKHN0YXQubW9kZSAmIGNvbnN0YW50cy5TX0lYVVNSKSB8fCAoc3RhdC5tb2RlICYgY29uc3RhbnRzLlNfSVhHUlApIHx8IChzdGF0Lm1vZGUgJiBjb25zdGFudHMuU19JWE9USCk7XG4gICAgZXhwZWN0KGlzRXhlYykudG9CZVRydXRoeSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHJtUmZTeW5jKHN0YWdpbmdEaXIpO1xuICAgIHJtUmZTeW5jKGV4dHJhY3REaXIpO1xuICB9XG59KTtcblxudGVzdCgnbWQ1IGhhc2ggb2YgYSB6aXAgc3RheXMgY29uc2lzdGVudCBhY3Jvc3MgaW52b2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHN0YWdpbmdEaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3Rlc3QuYXJjaGl2ZScpKTtcbiAgY29uc3QgemlwRmlsZTEgPSBwYXRoLmpvaW4oc3RhZ2luZ0RpciwgJ291dHB1dC56aXAnKTtcbiAgY29uc3QgemlwRmlsZTIgPSBwYXRoLmpvaW4oc3RhZ2luZ0RpciwgJ291dHB1dC56aXAnKTtcbiAgY29uc3Qgb3JpZ2luYWxEaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC1hcmNoaXZlJyk7XG4gIGF3YWl0IHppcERpcmVjdG9yeShvcmlnaW5hbERpciwgemlwRmlsZTEpO1xuICBhd2FpdCBuZXcgUHJvbWlzZShvayA9PiBzZXRUaW1lb3V0KG9rLCAyMDAwKSk7IC8vIHdhaXQgMnNcbiAgYXdhaXQgemlwRGlyZWN0b3J5KG9yaWdpbmFsRGlyLCB6aXBGaWxlMik7XG5cbiAgY29uc3QgaGFzaDEgPSBjb250ZW50SGFzaChhd2FpdCBmcy5yZWFkRmlsZSh6aXBGaWxlMSkpO1xuICBjb25zdCBoYXNoMiA9IGNvbnRlbnRIYXNoKGF3YWl0IGZzLnJlYWRGaWxlKHppcEZpbGUyKSk7XG5cbiAgZXhwZWN0KGhhc2gxKS50b0VxdWFsKGhhc2gyKTtcbn0pO1xuXG50ZXN0KCd6aXBEaXJlY3RvcnkgZm9sbG93cyBzeW1saW5rcycsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhZ2luZ0RpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdC5hcmNoaXZlJykpO1xuICBjb25zdCBleHRyYWN0RGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0LmFyY2hpdmUuZm9sbG93JykpO1xuICB0cnkge1xuICAgIGNvbnN0IG9yaWdpbmFsRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3QtYXJjaGl2ZS1mb2xsb3cnLCAnZGF0YScpO1xuICAgIGNvbnN0IHppcEZpbGUgPSBwYXRoLmpvaW4oc3RhZ2luZ0RpciwgJ291dHB1dC56aXAnKTtcblxuICAgIGF3YWl0IGV4cGVjdCh6aXBEaXJlY3Rvcnkob3JpZ2luYWxEaXIsIHppcEZpbGUpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgYXdhaXQgZXhwZWN0KGV4ZWMoYHVuemlwICR7emlwRmlsZX1gLCB7IGN3ZDogZXh0cmFjdERpciB9KSkucmVzb2x2ZXMudG9CZURlZmluZWQoKTtcbiAgICBhd2FpdCBleHBlY3QoZXhlYyhgZGlmZiAtYnVyICR7b3JpZ2luYWxEaXJ9ICR7ZXh0cmFjdERpcn1gKSkucmVzb2x2ZXMudG9CZURlZmluZWQoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBybVJmU3luYyhzdGFnaW5nRGlyKTtcbiAgICBybVJmU3luYyhleHRyYWN0RGlyKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250ZW50SGFzaChkYXRhOiBzdHJpbmcgfCBCdWZmZXIgfCBEYXRhVmlldykge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufSJdfQ==